/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'bitmain_axi.ko_18dd4cac57272383_debug'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

struct kernfs_open_file;
struct seq_file;
struct percpu_ref;
struct notifier_block;
struct page;
struct work_struct;
struct ctl_table;
struct mm_struct;
struct thread_struct;
struct mod_kallsyms;
struct bus_type;
struct device;
struct dir_context;
struct file_lock;
struct kqid;
struct dquot;
struct kiocb;
struct bin_attribute;
struct vm_fault;
struct bug_entry;
struct exception_table_entry;
struct kernel_param;
struct module_attribute;
struct attribute;
struct module;
struct kparam_array;
struct kparam_string;
struct kernel_param_ops;
struct kobj_uevent_env;
struct kset_uevent_ops;
struct kobj_type;
struct kset;
struct sysfs_ops;
struct kobj_ns_type_operations;
struct kernfs_syscall_ops;
struct task_delay_info;
struct sighand_struct;
struct signal_struct;
struct cftype;
struct kernfs_ops;
struct kernfs_root;
struct cgroup_root;
struct cgroup;
struct css_set;
struct cgroup_subsys;
struct kernfs_node;
struct ida_bitmap;
struct idr_layer;
struct group_info;
struct cred;
struct key;
struct hrtimer_clock_base;
struct hrtimer_cpu_base;
struct zone;
struct per_cpu_pageset;
struct pglist_data;
struct pid;
struct user_struct;
struct core_state;
struct pgd_t;
struct completion;
struct vm_operations_struct;
struct vm_area_struct;
struct file;
struct address_space;
struct ctl_table_poll;
struct task_struct;
struct compat_timespec;
struct timespec;
struct file_operations;
struct kernel_symbol;
struct device_dma_parameters;
struct dev_pin_info;
struct dev_pm_domain;
struct class;
struct class_attribute;
struct device_type;
struct device_attribute;
struct dev_pm_ops;
struct pm_subsys_data;
struct wakeup_source;
struct seq_operations;
struct fiemap_extent_info;
struct kstat;
struct iattr;
struct delayed_call;
struct fiemap_extent;
struct super_operations;
struct file_system_type;
struct fasync_struct;
struct lock_manager_operations;
struct file_lock_operations;
struct file_lock_context;
struct inode_operations;
struct address_space_operations;
struct qc_state;
struct qc_dqblk;
struct qc_info;
struct quotactl_ops;
struct kprojid_t;
struct dquot_operations;
struct quota_format_ops;
struct quota_format_type;
struct radix_tree_node;
struct list_lru_node;
struct qstr;
struct super_block;
struct dentry_operations;
struct inode;
struct dentry;
struct block_device;
struct fault_env;
struct pte_t;
struct pmd_t;
struct shrink_control;
struct attribute_group;
struct elf64_sym;
struct siginfo;
union restart_block::$F2266E4114E0B21CE2AD1A50412A9076;

/* 101 */
struct atomic_t
{
  int counter;
};

/* 1 */
struct kref
{
  atomic_t refcount;
};

/* 100 */
struct list_head
{
  list_head *next;
  list_head *prev;
};

/* 2 */
struct kobject
{
  const char *name;
  list_head entry;
  kobject *parent;
  kset *kset;
  kobj_type *ktype;
  kernfs_node *sd;
  kref kref;
  unsigned __int32 state_initialized : 1;
  unsigned __int32 state_in_sysfs : 1;
  unsigned __int32 state_add_uevent_sent : 1;
  unsigned __int32 state_remove_uevent_sent : 1;
  unsigned __int32 uevent_suppress : 1;
};

/* 178 */
typedef unsigned __int16 u16;

/* 282 */
struct arch_spinlock_t
{
  u16 owner;
  u16 next;
};

/* 281 */
struct raw_spinlock
{
  arch_spinlock_t raw_lock;
};

/* 461 */
union spinlock::$46AC2B4BF8FFDB08A79F47BF9EBF542E
{
  raw_spinlock rlock;
};

/* 460 */
struct spinlock
{
  union
  {
    raw_spinlock rlock;
  };
};

/* 27 */
typedef spinlock spinlock_t;

/* 99 */
struct kset
{
  list_head list;
  spinlock_t list_lock;
  kobject kobj;
  const kset_uevent_ops *uevent_ops;
};

/* 98 */
struct kobj_type
{
  void (*release)(kobject *);
  const sysfs_ops *sysfs_ops;
  attribute **default_attrs;
  const kobj_ns_type_operations *(*child_ns_type)(kobject *);
  const void *(*namespace)(kobject *);
};

/* 37 */
struct rb_node
{
  unsigned __int64 __rb_parent_color;
  rb_node *rb_right;
  rb_node *rb_left;
};

/* 24 */
struct rb_root
{
  rb_node *rb_node;
};

/* 111 */
struct kernfs_elem_dir
{
  unsigned __int64 subdirs;
  rb_root children;
  kernfs_root *root;
};

/* 110 */
struct kernfs_elem_symlink
{
  kernfs_node *target_kn;
};

/* 112 */
struct kernfs_open_node;

/* 295 */
typedef __int64 __kernel_loff_t;

/* 113 */
typedef __kernel_loff_t loff_t;

/* 109 */
struct kernfs_elem_attr
{
  const kernfs_ops *ops;
  kernfs_open_node *open;
  loff_t size;
  kernfs_node *notify_next;
};

/* 473 */
union kernfs_node::$8652C698344606644B46A9E29BF98190
{
  kernfs_elem_dir dir;
  kernfs_elem_symlink symlink;
  kernfs_elem_attr attr;
};

/* 103 */
typedef unsigned __int16 umode_t;

/* 108 */
struct kernfs_iattrs;

/* 180 */
struct kernfs_node
{
  atomic_t count;
  atomic_t active;
  kernfs_node *parent;
  const char *name;
  rb_node rb;
  const void *ns;
  unsigned int hash;
  union
  {
    kernfs_elem_dir dir;
    kernfs_elem_symlink symlink;
    kernfs_elem_attr attr;
  };
  void *priv;
  unsigned __int16 flags;
  umode_t mode;
  unsigned int ino;
  kernfs_iattrs *iattr;
};

/* 97 */
struct kset_uevent_ops
{
  int (*const filter)(kset *, kobject *);
  const char *(*const name)(kset *, kobject *);
  int (*const uevent)(kset *, kobject *, kobj_uevent_env *);
};

/* 298 */
typedef __int64 __kernel_long_t;

/* 432 */
typedef __kernel_long_t __kernel_ssize_t;

/* 87 */
typedef __kernel_ssize_t ssize_t;

/* 210 */
typedef unsigned __int64 __kernel_ulong_t;

/* 433 */
typedef __kernel_ulong_t __kernel_size_t;

/* 85 */
typedef __kernel_size_t size_t;

/* 102 */
struct sysfs_ops
{
  ssize_t (*show)(kobject *, attribute *, char *);
  ssize_t (*store)(kobject *, attribute *, const char *, size_t);
};

/* 88 */
struct __attribute__((aligned(8))) attribute
{
  const char *name;
  umode_t mode;
};

/* 106 */
enum kobj_ns_type : __int32
{
  kobj_ns_type::KOBJ_NS_TYPE_NONE = 0x0,
  kobj_ns_type::KOBJ_NS_TYPE_NET = 0x1,
  kobj_ns_type::KOBJ_NS_TYPES = 0x2,
};

/* 104 */
typedef bool bool;

/* 3 */
struct sock;

/* 105 */
struct kobj_ns_type_operations
{
  kobj_ns_type type;
  bool (*current_may_mount)(void);
  void *(*grab_current_ns)(void);
  const void *(*netlink_ns)(sock *);
  const void *(*initial_ns)(void);
  void (*drop_ns)(void *);
};

/* 171 */
struct idr
{
  idr_layer *hint;
  idr_layer *top;
  int layers;
  int cur;
  spinlock_t lock;
  int id_free_cnt;
  idr_layer *id_free;
};

/* 169 */
struct ida
{
  idr idr;
  ida_bitmap *free_bitmap;
};

/* 462 */
struct __wait_queue_head
{
  spinlock_t lock;
  list_head task_list;
};

/* 162 */
typedef __wait_queue_head wait_queue_head_t;

/* 168 */
struct kernfs_root
{
  kernfs_node *kn;
  unsigned int flags;
  ida ino_ida;
  kernfs_syscall_ops *syscall_ops;
  list_head supers;
  wait_queue_head_t deactivate_waitq;
};

/* 167 */
struct kernfs_ops
{
  int (*seq_show)(seq_file *, void *);
  void *(*seq_start)(seq_file *, loff_t *);
  void *(*seq_next)(seq_file *, void *, loff_t *);
  void (*seq_stop)(seq_file *, void *);
  ssize_t (*read)(kernfs_open_file *, char *, size_t, loff_t);
  size_t atomic_write_len;
  bool prealloc;
  ssize_t (*write)(kernfs_open_file *, char *, size_t, loff_t);
  int (*mmap)(kernfs_open_file *, vm_area_struct *);
};

/* 96 */
struct kobj_uevent_env
{
  char *argv[3];
  char *envp[32];
  int envp_idx;
  char buf[2048];
  int buflen;
};

/* 174 */
struct callback_head
{
  callback_head *next;
  void (*func)(callback_head *);
};

/* 475 */
union idr_layer::$D43E13ADBC1115580B3038F4A41646CE
{
  unsigned __int64 bitmap[4];
  callback_head callback_head;
};

/* 187 */
struct idr_layer
{
  int prefix;
  int layer;
  idr_layer *ary[256];
  int count;
  union
  {
    unsigned __int64 bitmap[4];
    callback_head callback_head;
  };
};

/* 186 */
struct ida_bitmap
{
  __int64 nr_busy;
  unsigned __int64 bitmap[15];
};

/* 107 */
struct kernfs_syscall_ops
{
  int (*remount_fs)(kernfs_root *, int *, char *);
  int (*show_options)(seq_file *, kernfs_root *);
  int (*mkdir)(kernfs_node *, const char *, umode_t);
  int (*rmdir)(kernfs_node *);
  int (*rename)(kernfs_node *, kernfs_node *, const char *);
  int (*show_path)(seq_file *, kernfs_node *, kernfs_root *);
};

/* 148 */
typedef unsigned __int64 u64;

/* 214 */
struct optimistic_spin_queue
{
  atomic_t tail;
};

/* 21 */
struct __attribute__((aligned(8))) mutex
{
  atomic_t count;
  spinlock_t wait_lock;
  list_head wait_list;
  task_struct *owner;
  optimistic_spin_queue osq;
};

/* 7 */
struct seq_file
{
  char *buf;
  size_t size;
  size_t from;
  size_t count;
  size_t pad_until;
  loff_t index;
  loff_t read_pos;
  u64 version;
  mutex lock;
  const seq_operations *op;
  int poll_event;
  const file *file;
  void *private;
};

/* 6 */
struct kernfs_open_file
{
  kernfs_node *kn;
  file *file;
  void *priv;
  mutex mutex;
  mutex prealloc_mutex;
  int event;
  list_head list;
  char *prealloc_buf;
  size_t atomic_write_len;
  bool mmapped;
  const vm_operations_struct *vm_ops;
};

/* 259 */
typedef u64 pteval_t;

/* 254 */
struct pgprot_t
{
  pteval_t pgprot;
};

/* 491 */
struct vm_area_struct::$62AE47D3A423FC3B927A38B006BC8551
{
  rb_node rb;
  unsigned __int64 rb_subtree_last;
};

/* 251 */
struct anon_vma;

/* 253 */
struct vm_userfaultfd_ctx
{
};

/* 252 */
struct vm_area_struct
{
  unsigned __int64 vm_start;
  unsigned __int64 vm_end;
  vm_area_struct *vm_next;
  vm_area_struct *vm_prev;
  rb_node vm_rb;
  unsigned __int64 rb_subtree_gap;
  mm_struct *vm_mm;
  pgprot_t vm_page_prot;
  unsigned __int64 vm_flags;
  vm_area_struct::$62AE47D3A423FC3B927A38B006BC8551 shared;
  list_head anon_vma_chain;
  anon_vma *anon_vma;
  const vm_operations_struct *vm_ops;
  unsigned __int64 vm_pgoff;
  file *vm_file;
  void *vm_private_data;
  vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

/* 44 */
struct llist_node
{
  llist_node *next;
};

/* 146 */
struct sched_class;

/* 152 */
typedef unsigned int u32;

/* 151 */
struct __attribute__((aligned(8))) load_weight
{
  unsigned __int64 weight;
  u32 inv_weight;
};

/* 150 */
struct sched_avg
{
  u64 last_update_time;
  u64 load_sum;
  u32 util_sum;
  u32 period_contrib;
  unsigned __int64 load_avg;
  unsigned __int64 util_avg;
};

/* 43 */
struct __attribute__((aligned(128))) sched_entity
{
  load_weight load;
  rb_node run_node;
  list_head group_node;
  unsigned int on_rq;
  u64 exec_start;
  u64 sum_exec_runtime;
  u64 vruntime;
  u64 prev_sum_exec_runtime;
  u64 nr_migrations;
  __attribute__((aligned(32))) sched_avg avg;
};

/* 42 */
struct sched_rt_entity
{
  list_head run_list;
  unsigned __int64 timeout;
  unsigned __int64 watchdog_stamp;
  unsigned int time_slice;
  unsigned __int16 on_rq;
  unsigned __int16 on_list;
  sched_rt_entity *back;
};

/* 149 */
typedef __int64 s64;

/* 430 */
union ktime
{
  s64 tv64;
};

/* 161 */
typedef ktime ktime_t;

/* 209 */
struct timerqueue_node
{
  rb_node node;
  ktime_t expires;
};

/* 208 */
enum hrtimer_restart : __int32
{
  hrtimer_restart::HRTIMER_NORESTART = 0x0,
  hrtimer_restart::HRTIMER_RESTART = 0x1,
};

/* 93 */
typedef unsigned __int8 u8;

/* 147 */
struct __attribute__((aligned(8))) hrtimer
{
  timerqueue_node node;
  ktime_t _softexpires;
  hrtimer_restart (*function)(hrtimer *);
  hrtimer_clock_base *base;
  u8 state;
  u8 is_rel;
};

/* 41 */
struct sched_dl_entity
{
  rb_node rb_node;
  u64 dl_runtime;
  u64 dl_deadline;
  u64 dl_period;
  u64 dl_bw;
  s64 runtime;
  u64 deadline;
  unsigned int flags;
  int dl_throttled;
  int dl_boosted;
  int dl_yielded;
  hrtimer dl_timer;
};

/* 269 */
struct cpumask
{
  unsigned __int64 bits[1];
};

/* 40 */
typedef cpumask cpumask_t;

/* 39 */
struct sched_info
{
  unsigned __int64 pcount;
  unsigned __int64 run_delay;
  unsigned __int64 last_arrival;
  unsigned __int64 last_queued;
};

/* 38 */
struct plist_node
{
  int prio;
  list_head prio_list;
  list_head node_list;
};

/* 36 */
struct task_rss_stat
{
  int events;
  int count[4];
};

/* 285 */
struct restart_block
{
  __int64 (*fn)(restart_block *);
  union
  {
    restart_block::$F2266E4114E0B21CE2AD1A50412A9076::$9F8590F102EB2841150ECC2E0574E358 futex;
    restart_block::$F2266E4114E0B21CE2AD1A50412A9076::$22992958518223BE0044C695E246E9E2 nanosleep;
    restart_block::$F2266E4114E0B21CE2AD1A50412A9076::$F3CAA52711B0FBBABA04D84B2645ECC4 poll;
  };
};

/* 236 */
typedef int __kernel_pid_t;

/* 284 */
typedef __kernel_pid_t pid_t;

/* 175 */
struct hlist_node
{
  hlist_node *next;
  hlist_node **pprev;
};

/* 145 */
struct pid_link
{
  hlist_node node;
  pid *pid;
};

/* 22 */
typedef unsigned __int64 cputime_t;

/* 26 */
typedef raw_spinlock raw_spinlock_t;

/* 35 */
struct __attribute__((aligned(8))) prev_cputime
{
  cputime_t utime;
  cputime_t stime;
  raw_spinlock_t lock;
};

/* 34 */
struct task_cputime
{
  cputime_t utime;
  cputime_t stime;
  unsigned __int64 sum_exec_runtime;
};

/* 144 */
struct nameidata;

/* 243 */
struct sem_undo_list;

/* 33 */
struct sysv_sem
{
  sem_undo_list *undo_list;
};

/* 32 */
struct sysv_shm
{
  list_head shm_clist;
};

/* 143 */
struct fs_struct;

/* 142 */
struct files_struct;

/* 141 */
struct nsproxy;

/* 31 */
struct sigset_t
{
  unsigned __int64 sig[1];
};

/* 30 */
struct sigpending
{
  list_head list;
  sigset_t signal;
};

/* 138 */
struct audit_context;

/* 235 */
typedef unsigned int __kernel_uid32_t;

/* 266 */
typedef __kernel_uid32_t uid_t;

/* 29 */
struct kuid_t
{
  uid_t val;
};

/* 25 */
struct wake_q_node
{
  wake_q_node *next;
};

/* 137 */
struct rt_mutex_waiter;

/* 136 */
struct bio_list;

/* 135 */
struct blk_plug;

/* 134 */
struct reclaim_state;

/* 133 */
struct backing_dev_info;

/* 132 */
struct io_context;

/* 131 */
typedef siginfo siginfo_t;

/* 23 */
struct task_io_accounting
{
  u64 rchar;
  u64 wchar;
  u64 syscr;
  u64 syscw;
  u64 read_bytes;
  u64 write_bytes;
  u64 cancelled_write_bytes;
};

/* 130 */
struct robust_list_head;

/* 129 */
struct compat_robust_list_head;

/* 128 */
struct futex_pi_state;

/* 4 */
struct perf_event_context;

/* 127 */
struct pipe_inode_info;

/* 122 */
typedef unsigned int __u32;

/* 20 */
struct page_frag
{
  page *page;
  __u32 offset;
  __u32 size;
};

/* 283 */
struct __attribute__((aligned(128))) task_struct
{
  volatile __int64 state;
  void *stack;
  atomic_t usage;
  unsigned int flags;
  unsigned int ptrace;
  llist_node wake_entry;
  int on_cpu;
  unsigned int wakee_flips;
  unsigned __int64 wakee_flip_decay_ts;
  task_struct *last_wakee;
  int wake_cpu;
  int on_rq;
  int prio;
  int static_prio;
  int normal_prio;
  unsigned int rt_priority;
  const sched_class *sched_class;
  sched_entity se;
  sched_rt_entity rt;
  sched_dl_entity dl;
  unsigned int policy;
  int nr_cpus_allowed;
  cpumask_t cpus_allowed;
  sched_info sched_info;
  list_head tasks;
  plist_node pushable_tasks;
  rb_node pushable_dl_tasks;
  mm_struct *mm;
  mm_struct *active_mm;
  u32 vmacache_seqnum;
  vm_area_struct *vmacache[4];
  task_rss_stat rss_stat;
  int exit_state;
  int exit_code;
  int exit_signal;
  int pdeath_signal;
  unsigned __int64 jobctl;
  unsigned int personality;
  unsigned __int32 sched_reset_on_fork : 1;
  unsigned __int32 sched_contributes_to_load : 1;
  unsigned __int32 sched_migrated : 1;
  unsigned __int32 sched_remote_wakeup : 1;
  unsigned __int32 : 28;
  unsigned __int32 in_execve : 1;
  unsigned __int32 in_iowait : 1;
  unsigned __int64 atomic_flags;
  restart_block restart_block;
  pid_t pid;
  pid_t tgid;
  task_struct *real_parent;
  task_struct *parent;
  list_head children;
  list_head sibling;
  task_struct *group_leader;
  list_head ptraced;
  list_head ptrace_entry;
  pid_link pids[3];
  list_head thread_group;
  list_head thread_node;
  completion *vfork_done;
  int *set_child_tid;
  int *clear_child_tid;
  cputime_t utime;
  cputime_t stime;
  cputime_t utimescaled;
  cputime_t stimescaled;
  cputime_t gtime;
  prev_cputime prev_cputime;
  unsigned __int64 nvcsw;
  unsigned __int64 nivcsw;
  u64 start_time;
  u64 real_start_time;
  unsigned __int64 min_flt;
  unsigned __int64 maj_flt;
  task_cputime cputime_expires;
  list_head cpu_timers[3];
  const cred *real_cred;
  const cred *cred;
  char comm[16];
  nameidata *nameidata;
  sysv_sem sysvsem;
  sysv_shm sysvshm;
  fs_struct *fs;
  files_struct *files;
  nsproxy *nsproxy;
  signal_struct *signal;
  sighand_struct *sighand;
  sigset_t blocked;
  sigset_t real_blocked;
  sigset_t saved_sigmask;
  sigpending pending;
  unsigned __int64 sas_ss_sp;
  size_t sas_ss_size;
  unsigned int sas_ss_flags;
  callback_head *task_works;
  audit_context *audit_context;
  kuid_t loginuid;
  unsigned int sessionid;
  u32 parent_exec_id;
  u32 self_exec_id;
  spinlock_t alloc_lock;
  raw_spinlock_t pi_lock;
  wake_q_node wake_q;
  rb_root pi_waiters;
  rb_node *pi_waiters_leftmost;
  rt_mutex_waiter *pi_blocked_on;
  void *journal_info;
  bio_list *bio_list;
  blk_plug *plug;
  reclaim_state *reclaim_state;
  backing_dev_info *backing_dev_info;
  io_context *io_context;
  unsigned __int64 ptrace_message;
  siginfo_t *last_siginfo;
  task_io_accounting ioac;
  u64 acct_rss_mem1;
  u64 acct_vm_mem1;
  cputime_t acct_timexpd;
  css_set *cgroups;
  list_head cg_list;
  robust_list_head *robust_list;
  compat_robust_list_head *compat_robust_list;
  list_head pi_state_list;
  futex_pi_state *pi_state_cache;
  perf_event_context *perf_event_ctxp[2];
  mutex perf_event_mutex;
  list_head perf_event_list;
  callback_head rcu;
  pipe_inode_info *splice_pipe;
  page_frag task_frag;
  task_delay_info *delays;
  int nr_dirtied;
  int nr_dirtied_pause;
  unsigned __int64 dirty_paused_when;
  u64 timer_slack_ns;
  u64 default_timer_slack_ns;
  int pagefault_disabled;
  task_struct *oom_reaper_list;
  thread_struct thread;
};

/* 334 */
struct seq_operations
{
  void *(*start)(seq_file *, loff_t *);
  void (*stop)(seq_file *, void *);
  void *(*next)(seq_file *, void *, loff_t *);
  int (*show)(seq_file *, void *);
};

/* 463 */
union file::$B5D8E076F408A137EC3C35F8032C006D
{
  llist_node fu_llist;
  callback_head fu_rcuhead;
};

/* 390 */
struct vfsmount;

/* 68 */
struct path
{
  vfsmount *mnt;
  dentry *dentry;
};

/* 164 */
struct atomic64_t
{
  __int64 counter;
};

/* 185 */
typedef atomic64_t atomic_long_t;

/* 394 */
typedef unsigned int fmode_t;

/* 280 */
struct arch_rwlock_t
{
  volatile unsigned int lock;
};

/* 358 */
struct rwlock_t
{
  arch_rwlock_t raw_lock;
};

/* 357 */
enum pid_type : __int32
{
  pid_type::PIDTYPE_PID = 0x0,
  pid_type::PIDTYPE_PGID = 0x1,
  pid_type::PIDTYPE_SID = 0x2,
  pid_type::PIDTYPE_MAX = 0x3,
};

/* 75 */
struct fown_struct
{
  rwlock_t lock;
  pid *pid;
  pid_type pid_type;
  kuid_t uid;
  kuid_t euid;
  int signum;
};

/* 74 */
struct file_ra_state
{
  unsigned __int64 start;
  unsigned int size;
  unsigned int async_size;
  unsigned int ra_pages;
  unsigned int mmap_miss;
  loff_t prev_pos;
};

/* 255 */
struct file
{
  file::$B5D8E076F408A137EC3C35F8032C006D f_u;
  path f_path;
  inode *f_inode;
  const file_operations *f_op;
  spinlock_t f_lock;
  atomic_long_t f_count;
  unsigned int f_flags;
  fmode_t f_mode;
  mutex f_pos_lock;
  loff_t f_pos;
  fown_struct f_owner;
  const cred *f_cred;
  file_ra_state f_ra;
  u64 f_version;
  void *private_data;
  list_head f_ep_links;
  list_head f_tfile_llink;
  address_space *f_mapping;
};

/* 250 */
struct vm_operations_struct
{
  void (*open)(vm_area_struct *);
  void (*close)(vm_area_struct *);
  int (*mremap)(vm_area_struct *);
  int (*fault)(vm_area_struct *, vm_fault *);
  int (*pmd_fault)(vm_area_struct *, unsigned __int64, pmd_t *, unsigned int);
  void (*map_pages)(fault_env *, unsigned __int64, unsigned __int64);
  int (*page_mkwrite)(vm_area_struct *, vm_fault *);
  int (*pfn_mkwrite)(vm_area_struct *, vm_fault *);
  int (*access)(vm_area_struct *, unsigned __int64, void *, int, int);
  const char *(*name)(vm_area_struct *);
  page *(*find_special_page)(vm_area_struct *, unsigned __int64);
};

/* 181 */
struct rw_semaphore
{
  atomic_long_t count;
  list_head wait_list;
  raw_spinlock_t wait_lock;
  optimistic_spin_queue osq;
  task_struct *owner;
};

/* 16 */
struct mm_rss_stat
{
  atomic_long_t count[4];
};

/* 246 */
struct linux_binfmt;

/* 267 */
typedef cpumask cpumask_var_t[1];

/* 15 */
struct mm_context_t
{
  atomic64_t id;
  void *vdso;
};

/* 244 */
struct kioctx_table;

/* 14 */
typedef page *pgtable_t;

/* 262 */
typedef void (*work_func_t)(work_struct *);

/* 11 */
struct work_struct
{
  atomic_long_t data;
  list_head entry;
  work_func_t func;
};

/* 17 */
struct mm_struct
{
  vm_area_struct *mmap;
  rb_root mm_rb;
  u32 vmacache_seqnum;
  unsigned __int64 (*get_unmapped_area)(file *, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64);
  unsigned __int64 mmap_base;
  unsigned __int64 mmap_legacy_base;
  unsigned __int64 task_size;
  unsigned __int64 highest_vm_end;
  pgd_t *pgd;
  atomic_t mm_users;
  atomic_t mm_count;
  atomic_long_t nr_ptes;
  atomic_long_t nr_pmds;
  int map_count;
  spinlock_t page_table_lock;
  rw_semaphore mmap_sem;
  list_head mmlist;
  unsigned __int64 hiwater_rss;
  unsigned __int64 hiwater_vm;
  unsigned __int64 total_vm;
  unsigned __int64 locked_vm;
  unsigned __int64 pinned_vm;
  unsigned __int64 data_vm;
  unsigned __int64 exec_vm;
  unsigned __int64 stack_vm;
  unsigned __int64 def_flags;
  unsigned __int64 start_code;
  unsigned __int64 end_code;
  unsigned __int64 start_data;
  unsigned __int64 end_data;
  unsigned __int64 start_brk;
  unsigned __int64 brk;
  unsigned __int64 start_stack;
  unsigned __int64 arg_start;
  unsigned __int64 arg_end;
  unsigned __int64 env_start;
  unsigned __int64 env_end;
  unsigned __int64 saved_auxv[44];
  mm_rss_stat rss_stat;
  linux_binfmt *binfmt;
  cpumask_var_t cpu_vm_mask_var;
  mm_context_t context;
  unsigned __int64 flags;
  core_state *core_state;
  spinlock_t ioctx_lock;
  kioctx_table *ioctx_table;
  file *exe_file;
  pgtable_t pmd_huge_pte;
  bool tlb_flush_pending;
  atomic_long_t hugetlb_usage;
  work_struct async_put_work;
};

/* 297 */
typedef int __kernel_clockid_t;

/* 207 */
typedef __kernel_clockid_t clockid_t;

/* 206 */
struct timerqueue_head
{
  rb_root head;
  timerqueue_node *next;
};

/* 203 */
struct __attribute__((aligned(32))) hrtimer_clock_base
{
  hrtimer_cpu_base *cpu_base;
  int index;
  clockid_t clockid;
  timerqueue_head active;
  ktime_t (*get_time)(void);
  ktime_t offset;
};

/* 455 */
struct restart_block::$F2266E4114E0B21CE2AD1A50412A9076::$9F8590F102EB2841150ECC2E0574E358
{
  u32 *uaddr;
  u32 val;
  u32 flags;
  u32 bitset;
  u64 time;
  u32 *uaddr2;
};

/* 456 */
struct restart_block::$F2266E4114E0B21CE2AD1A50412A9076::$22992958518223BE0044C695E246E9E2
{
  clockid_t clockid;
  timespec *rmtp;
  compat_timespec *compat_rmtp;
  u64 expires;
};

/* 287 */
struct pollfd;

/* 457 */
struct restart_block::$F2266E4114E0B21CE2AD1A50412A9076::$F3CAA52711B0FBBABA04D84B2645ECC4
{
  pollfd *ufds;
  int nfds;
  int has_timeout;
  unsigned __int64 tv_sec;
  unsigned __int64 tv_nsec;
};

/* 458 */
union restart_block::$F2266E4114E0B21CE2AD1A50412A9076
{
  restart_block::$F2266E4114E0B21CE2AD1A50412A9076::$9F8590F102EB2841150ECC2E0574E358 futex;
  restart_block::$F2266E4114E0B21CE2AD1A50412A9076::$22992958518223BE0044C695E246E9E2 nanosleep;
  restart_block::$F2266E4114E0B21CE2AD1A50412A9076::$F3CAA52711B0FBBABA04D84B2645ECC4 poll;
};

/* 229 */
struct hlist_head
{
  hlist_node *first;
};

/* 230 */
struct pid_namespace;

/* 228 */
struct upid
{
  int nr;
  pid_namespace *ns;
  hlist_node pid_chain;
};

/* 227 */
struct pid
{
  atomic_t count;
  unsigned int level;
  hlist_head tasks[3];
  callback_head rcu;
  upid numbers[1];
};

/* 248 */
struct completion
{
  unsigned int done;
  wait_queue_head_t wait;
};

/* 296 */
typedef unsigned int __kernel_gid32_t;

/* 265 */
typedef __kernel_gid32_t gid_t;

/* 192 */
struct kgid_t
{
  gid_t val;
};

/* 431 */
struct kernel_cap_struct
{
  __u32 cap[2];
};

/* 191 */
typedef kernel_cap_struct kernel_cap_t;

/* 189 */
struct user_namespace;

/* 190 */
struct cred
{
  atomic_t usage;
  kuid_t uid;
  kgid_t gid;
  kuid_t suid;
  kgid_t sgid;
  kuid_t euid;
  kgid_t egid;
  kuid_t fsuid;
  kgid_t fsgid;
  unsigned int securebits;
  kernel_cap_t cap_inheritable;
  kernel_cap_t cap_permitted;
  kernel_cap_t cap_effective;
  kernel_cap_t cap_bset;
  kernel_cap_t cap_ambient;
  unsigned __int8 jit_keyring;
  key *session_keyring;
  key *process_keyring;
  key *thread_keyring;
  key *request_key_auth;
  user_struct *user;
  user_namespace *user_ns;
  group_info *group_info;
  callback_head rcu;
};

/* 157 */
struct cpu_itimer
{
  cputime_t expires;
  cputime_t incr;
  u32 error;
  u32 incr_error;
};

/* 163 */
struct task_cputime_atomic
{
  atomic64_t utime;
  atomic64_t stime;
  atomic64_t sum_exec_runtime;
};

/* 160 */
struct __attribute__((aligned(8))) thread_group_cputimer
{
  task_cputime_atomic cputime_atomic;
  bool running;
  bool checking_timer;
};

/* 156 */
struct tty_struct;

/* 270 */
struct seqcount
{
  unsigned int sequence;
};

/* 159 */
struct seqlock_t
{
  seqcount seqcount;
  spinlock_t lock;
};

/* 155 */
struct rlimit
{
  __kernel_ulong_t rlim_cur;
  __kernel_ulong_t rlim_max;
};

/* 158 */
struct pacct_struct
{
  int ac_flag;
  __int64 ac_exitcode;
  unsigned __int64 ac_mem;
  cputime_t ac_utime;
  cputime_t ac_stime;
  unsigned __int64 ac_minflt;
  unsigned __int64 ac_majflt;
};

/* 154 */
struct taskstats;

/* 153 */
struct tty_audit_buf;

/* 140 */
struct signal_struct
{
  atomic_t sigcnt;
  atomic_t live;
  int nr_threads;
  list_head thread_head;
  wait_queue_head_t wait_chldexit;
  task_struct *curr_target;
  sigpending shared_pending;
  int group_exit_code;
  int notify_count;
  task_struct *group_exit_task;
  int group_stop_count;
  unsigned int flags;
  unsigned __int32 is_child_subreaper : 1;
  unsigned __int32 has_child_subreaper : 1;
  int posix_timer_id;
  list_head posix_timers;
  hrtimer real_timer;
  pid *leader_pid;
  ktime_t it_real_incr;
  cpu_itimer it[2];
  thread_group_cputimer cputimer;
  task_cputime cputime_expires;
  list_head cpu_timers[3];
  pid *tty_old_pgrp;
  int leader;
  tty_struct *tty;
  seqlock_t stats_lock;
  cputime_t utime;
  cputime_t stime;
  cputime_t cutime;
  cputime_t cstime;
  cputime_t gtime;
  cputime_t cgtime;
  prev_cputime prev_cputime;
  unsigned __int64 nvcsw;
  unsigned __int64 nivcsw;
  unsigned __int64 cnvcsw;
  unsigned __int64 cnivcsw;
  unsigned __int64 min_flt;
  unsigned __int64 maj_flt;
  unsigned __int64 cmin_flt;
  unsigned __int64 cmaj_flt;
  unsigned __int64 inblock;
  unsigned __int64 oublock;
  unsigned __int64 cinblock;
  unsigned __int64 coublock;
  unsigned __int64 maxrss;
  unsigned __int64 cmaxrss;
  task_io_accounting ioac;
  unsigned __int64 sum_sched_runtime;
  rlimit rlim[16];
  pacct_struct pacct;
  taskstats *stats;
  unsigned int audit_tty;
  tty_audit_buf *tty_audit_buf;
  bool oom_flag_origin;
  __int16 oom_score_adj;
  __int16 oom_score_adj_min;
  mm_struct *oom_mm;
  mutex cred_guard_mutex;
};

/* 241 */
typedef void __signalfn_t(int);

/* 233 */
typedef __signalfn_t *__sighandler_t;

/* 240 */
typedef void __restorefn_t(void);

/* 232 */
typedef __restorefn_t *__sigrestore_t;

/* 231 */
struct sigaction
{
  __sighandler_t sa_handler;
  unsigned __int64 sa_flags;
  __sigrestore_t sa_restorer;
  sigset_t sa_mask;
};

/* 165 */
struct k_sigaction
{
  sigaction sa;
};

/* 139 */
struct sighand_struct
{
  atomic_t count;
  k_sigaction action[64];
  spinlock_t siglock;
  wait_queue_head_t signalfd_wqh;
};

/* 445 */
struct siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$781F622659705A3ED26C10F885D10ED1
{
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
};

/* 238 */
typedef int __kernel_timer_t;

/* 239 */
union sigval
{
  int sival_int;
  void *sival_ptr;
};

/* 237 */
typedef sigval sigval_t;

/* 446 */
struct __attribute__((aligned(8))) siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$7C3D8B216523BFC55EF04D224E88BF5C
{
  __kernel_timer_t _tid;
  int _overrun;
  sigval_t _sigval;
  int _sys_private;
};

/* 447 */
struct siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$B0AD34E5C8A152814DB2F16036208CE6
{
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
  sigval_t _sigval;
};

/* 234 */
typedef __kernel_long_t __kernel_clock_t;

/* 448 */
struct siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$F1366510234E27C8C23A16A0CF6CF0CC
{
  __kernel_pid_t _pid;
  __kernel_uid32_t _uid;
  int _status;
  __kernel_clock_t _utime;
  __kernel_clock_t _stime;
};

/* 449 */
struct siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$3919AB08E68A7BD9475DC5E030BAE3FD::$2DE75F7F3DCDA3E4E8C63DE5E21AF0AC::$662BF2F748E3912036E0D25CDC9D9EE4
{
  void *_lower;
  void *_upper;
};

/* 450 */
union siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$3919AB08E68A7BD9475DC5E030BAE3FD::$2DE75F7F3DCDA3E4E8C63DE5E21AF0AC
{
  siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$3919AB08E68A7BD9475DC5E030BAE3FD::$2DE75F7F3DCDA3E4E8C63DE5E21AF0AC::$662BF2F748E3912036E0D25CDC9D9EE4 _addr_bnd;
  __u32 _pkey;
};

/* 451 */
struct siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$3919AB08E68A7BD9475DC5E030BAE3FD
{
  void *_addr;
  __int16 _addr_lsb;
  union
  {
    siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$3919AB08E68A7BD9475DC5E030BAE3FD::$2DE75F7F3DCDA3E4E8C63DE5E21AF0AC::$662BF2F748E3912036E0D25CDC9D9EE4 _addr_bnd;
    __u32 _pkey;
  };
};

/* 452 */
struct __attribute__((aligned(8))) siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$E846C0F3C79235E8199DB2C84888EFF9
{
  __int64 _band;
  int _fd;
};

/* 453 */
struct siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$4B29161E04CAD4BCDD788B201A5E8E5E
{
  void *_call_addr;
  int _syscall;
  unsigned int _arch;
};

/* 454 */
union siginfo::$C5D9B75353AAABC7A29A2303E701AA5C
{
  int _pad[28];
  siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$781F622659705A3ED26C10F885D10ED1 _kill;
  siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$7C3D8B216523BFC55EF04D224E88BF5C _timer;
  siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$B0AD34E5C8A152814DB2F16036208CE6 _rt;
  siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$F1366510234E27C8C23A16A0CF6CF0CC _sigchld;
  siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$3919AB08E68A7BD9475DC5E030BAE3FD _sigfault;
  siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$E846C0F3C79235E8199DB2C84888EFF9 _sigpoll;
  siginfo::$C5D9B75353AAABC7A29A2303E701AA5C::$4B29161E04CAD4BCDD788B201A5E8E5E _sigsys;
};

/* 444 */
struct siginfo
{
  int si_signo;
  int si_errno;
  int si_code;
  siginfo::$C5D9B75353AAABC7A29A2303E701AA5C _sifields;
};

/* 173 */
struct css_set
{
  atomic_t refcount;
  hlist_node hlist;
  list_head tasks;
  list_head mg_tasks;
  list_head cgrp_links;
  cgroup *dfl_cgrp;
  list_head mg_preload_node;
  list_head mg_node;
  cgroup *mg_src_cgrp;
  cgroup *mg_dst_cgrp;
  css_set *mg_dst_cset;
  list_head task_iters;
  bool dead;
  callback_head callback_head;
};

/* 492 */
union page::$AEAE9E2FEFCD2FAB3F3A51E12FB3DA1A
{
  address_space *mapping;
  void *s_mem;
  atomic_t compound_mapcount;
};

/* 493 */
union page::$1548AEE869E6B5FA0126AD6E97B33283
{
  unsigned __int64 index;
  void *freelist;
};

/* 494 */
struct page::$49FDC4B16EA06CA5B216850EF4C380F8::$C2619E1100102B6E8F5D4B39445EFDDB::$F481EC19A7EB8676C649728AA25E03E0::$34157686918C88ADDB14C11D63ECF3D3
{
  unsigned __int32 inuse : 16;
  unsigned __int32 objects : 15;
  unsigned __int32 frozen : 1;
};

/* 495 */
union page::$49FDC4B16EA06CA5B216850EF4C380F8::$C2619E1100102B6E8F5D4B39445EFDDB::$F481EC19A7EB8676C649728AA25E03E0
{
  atomic_t _mapcount;
  unsigned int active;
  struct
  {
    unsigned __int32 inuse : 16;
    unsigned __int32 objects : 15;
    unsigned __int32 frozen : 1;
  };
  int units;
};

/* 496 */
struct page::$49FDC4B16EA06CA5B216850EF4C380F8::$C2619E1100102B6E8F5D4B39445EFDDB
{
  union
  {
    atomic_t _mapcount;
    unsigned int active;
    struct
    {
      unsigned __int32 inuse : 16;
      unsigned __int32 objects : 15;
      unsigned __int32 frozen : 1;
    };
    int units;
  };
  atomic_t _refcount;
};

/* 497 */
union page::$49FDC4B16EA06CA5B216850EF4C380F8
{
  unsigned int counters;
  struct
  {
    union
    {
      atomic_t _mapcount;
      unsigned int active;
      struct
      {
        unsigned __int32 inuse : 16;
        unsigned __int32 objects : 15;
        unsigned __int32 frozen : 1;
      };
      int units;
    };
    atomic_t _refcount;
  };
};

/* 257 */
struct dev_pagemap;

/* 498 */
struct page::$FEBA299BA06B14EAFC685D2717C69BC6::$28099A4E4B70B6D11EF5DB4F925A6FFF
{
  page *next;
  int pages;
  int pobjects;
};

/* 499 */
struct page::$FEBA299BA06B14EAFC685D2717C69BC6::$4A6A5982C037E2F095EFA05C72B44DE2
{
  unsigned __int64 compound_head;
  unsigned int compound_dtor;
  unsigned int compound_order;
};

/* 500 */
union page::$FEBA299BA06B14EAFC685D2717C69BC6
{
  list_head lru;
  dev_pagemap *pgmap;
  struct
  {
    page *next;
    int pages;
    int pobjects;
  };
  callback_head callback_head;
  struct
  {
    unsigned __int64 compound_head;
    unsigned int compound_dtor;
    unsigned int compound_order;
  };
};

/* 256 */
struct kmem_cache;

/* 501 */
union page::$EE31D6E21B6E72653D3BE3D59BA5515C
{
  unsigned __int64 private;
  spinlock_t ptl;
  kmem_cache *slab_cache;
};

/* 10 */
struct page
{
  unsigned __int64 flags;
  union
  {
    address_space *mapping;
    void *s_mem;
    atomic_t compound_mapcount;
  };
  union
  {
    unsigned __int64 index;
    void *freelist;
  };
  union
  {
    unsigned int counters;
    struct
    {
      union
      {
        atomic_t _mapcount;
        unsigned int active;
        struct
        {
          unsigned __int32 inuse : 16;
          unsigned __int32 objects : 15;
          unsigned __int32 frozen : 1;
        };
        int units;
      };
      atomic_t _refcount;
    };
  };
  union
  {
    list_head lru;
    dev_pagemap *pgmap;
    struct
    {
      page *next;
      int pages;
      int pobjects;
    };
    callback_head callback_head;
    struct
    {
      unsigned __int64 compound_head;
      unsigned int compound_dtor;
      unsigned int compound_order;
    };
  };
  union
  {
    unsigned __int64 private;
    spinlock_t ptl;
    kmem_cache *slab_cache;
  };
};

/* 126 */
struct __attribute__((aligned(8))) task_delay_info
{
  spinlock_t lock;
  unsigned int flags;
  u64 blkio_start;
  u64 blkio_delay;
  u64 swapin_delay;
  u32 blkio_count;
  u32 swapin_count;
  u64 freepages_start;
  u64 freepages_delay;
  u32 freepages_count;
};

/* 273 */
struct cpu_context
{
  unsigned __int64 x19;
  unsigned __int64 x20;
  unsigned __int64 x21;
  unsigned __int64 x22;
  unsigned __int64 x23;
  unsigned __int64 x24;
  unsigned __int64 x25;
  unsigned __int64 x26;
  unsigned __int64 x27;
  unsigned __int64 x28;
  unsigned __int64 fp;
  unsigned __int64 sp;
  unsigned __int64 pc;
};

/* 278 */
struct __attribute__((aligned(16))) user_fpsimd_state
{
  unsigned __int128 vregs[32];
  __u32 fpsr;
  __u32 fpcr;
};

/* 439 */
struct __attribute__((aligned(16))) fpsimd_state::$C1EBEF6A9B6C06B8B4C39AC13AB14EB5::$60BFCF7CA6F434DDCA4F9F14F79F0D30
{
  unsigned __int128 vregs[32];
  u32 fpsr;
  u32 fpcr;
};

/* 440 */
union fpsimd_state::$C1EBEF6A9B6C06B8B4C39AC13AB14EB5
{
  user_fpsimd_state user_fpsimd;
  struct __attribute__((aligned(16)))
  {
    unsigned __int128 vregs[32];
    u32 fpsr;
    u32 fpcr;
  };
};

/* 272 */
struct __attribute__((aligned(16))) fpsimd_state
{
  union
  {
    user_fpsimd_state user_fpsimd;
    struct __attribute__((aligned(16)))
    {
      unsigned __int128 vregs[32];
      u32 fpsr;
      u32 fpcr;
    };
  };
  unsigned int cpu;
};

/* 18 */
struct perf_event;

/* 271 */
struct debug_info
{
  int suspended_step;
  int bps_disabled;
  int wps_disabled;
  perf_event *hbp_break[16];
  perf_event *hbp_watch[16];
};

/* 19 */
struct thread_struct
{
  cpu_context cpu_context;
  unsigned __int64 tp_value;
  unsigned __int64 tp2_value;
  fpsimd_state fpsimd_state;
  unsigned __int64 fault_address;
  unsigned __int64 fault_code;
  debug_info debug;
};

/* 205 */
typedef seqcount seqcount_t;

/* 400 */
struct hlist_bl_node
{
  hlist_bl_node *next;
  hlist_bl_node **pprev;
};

/* 121 */
typedef unsigned __int64 __u64;

/* 467 */
struct lockref::$8784DDDEC4F269D6C83851A73C1F2187::$AEEEF0908C303B51493A2C30B2CD252A
{
  spinlock_t lock;
  int count;
};

/* 468 */
union lockref::$8784DDDEC4F269D6C83851A73C1F2187
{
  __u64 lock_count;
  struct
  {
    spinlock_t lock;
    int count;
  };
};

/* 399 */
struct lockref
{
  union
  {
    __u64 lock_count;
    struct
    {
      spinlock_t lock;
      int count;
    };
  };
};

/* 469 */
union dentry::$F03198F59BB5B110A103CBC825C57379
{
  list_head d_lru;
  wait_queue_head_t *d_wait;
};

/* 470 */
union dentry::$3B49588AADC70A3FDC7C3D53565E8A90
{
  hlist_node d_alias;
  hlist_bl_node d_in_lookup_hash;
  callback_head d_rcu;
};

/* 398 */
struct dentry
{
  unsigned int d_flags;
  seqcount_t d_seq;
  hlist_bl_node d_hash;
  dentry *d_parent;
  qstr d_name;
  inode *d_inode;
  unsigned __int8 d_iname[32];
  lockref d_lockref;
  const dentry_operations *d_op;
  super_block *d_sb;
  unsigned __int64 d_time;
  void *d_fsdata;
  union
  {
    list_head d_lru;
    wait_queue_head_t *d_wait;
  };
  list_head d_child;
  list_head d_subdirs;
  dentry::$3B49588AADC70A3FDC7C3D53565E8A90 d_u;
};

/* 361 */
struct posix_acl;

/* 464 */
union inode::$4FAF459BA209DB8A26ECB5403EE4E15D
{
  const unsigned int i_nlink;
  unsigned int __i_nlink;
};

/* 436 */
typedef __u32 __kernel_dev_t;

/* 330 */
typedef __kernel_dev_t dev_t;

/* 290 */
typedef __kernel_long_t __kernel_time_t;

/* 289 */
struct timespec
{
  __kernel_time_t tv_sec;
  __int64 tv_nsec;
};

/* 376 */
typedef unsigned __int64 blkcnt_t;

/* 465 */
union inode::$7B2567D70A0237F3EBB83C38CE08E764
{
  hlist_head i_dentry;
  callback_head i_rcu;
};

/* 335 */
typedef unsigned int gfp_t;

/* 76 */
struct radix_tree_root
{
  gfp_t gfp_mask;
  radix_tree_node *rnode;
};

/* 258 */
struct address_space
{
  inode *host;
  radix_tree_root page_tree;
  spinlock_t tree_lock;
  atomic_t i_mmap_writable;
  rb_root i_mmap;
  rw_semaphore i_mmap_rwsem;
  unsigned __int64 nrpages;
  unsigned __int64 nrexceptional;
  unsigned __int64 writeback_index;
  const address_space_operations *a_ops;
  unsigned __int64 flags;
  spinlock_t private_lock;
  gfp_t gfp_mask;
  list_head private_list;
  void *private_data;
};

/* 362 */
struct cdev;

/* 466 */
union inode::$8073E762935E536BF05FF9D7402CEB32
{
  pipe_inode_info *i_pipe;
  block_device *i_bdev;
  cdev *i_cdev;
  char *i_link;
  unsigned int i_dir_seq;
};

/* 397 */
struct inode
{
  umode_t i_mode;
  unsigned __int16 i_opflags;
  kuid_t i_uid;
  kgid_t i_gid;
  unsigned int i_flags;
  posix_acl *i_acl;
  posix_acl *i_default_acl;
  const inode_operations *i_op;
  super_block *i_sb;
  address_space *i_mapping;
  unsigned __int64 i_ino;
  union
  {
    const unsigned int i_nlink;
    unsigned int __i_nlink;
  };
  dev_t i_rdev;
  loff_t i_size;
  timespec i_atime;
  timespec i_mtime;
  timespec i_ctime;
  spinlock_t i_lock;
  unsigned __int16 i_bytes;
  unsigned int i_blkbits;
  blkcnt_t i_blocks;
  unsigned __int64 i_state;
  rw_semaphore i_rwsem;
  unsigned __int64 dirtied_when;
  unsigned __int64 dirtied_time_when;
  hlist_node i_hash;
  list_head i_io_list;
  list_head i_lru;
  list_head i_sb_list;
  list_head i_wb_list;
  union
  {
    hlist_head i_dentry;
    callback_head i_rcu;
  };
  u64 i_version;
  atomic_t i_count;
  atomic_t i_dio_count;
  atomic_t i_writecount;
  const file_operations *i_fop;
  file_lock_context *i_flctx;
  address_space i_data;
  list_head i_devices;
  union
  {
    pipe_inode_info *i_pipe;
    block_device *i_bdev;
    cdev *i_cdev;
    char *i_link;
    unsigned int i_dir_seq;
  };
  __u32 i_generation;
  __u32 i_fsnotify_mask;
  hlist_head i_fsnotify_marks;
  void *i_private;
};

/* 62 */
struct iov_iter;

/* 58 */
struct poll_table_struct;

/* 340 */
typedef void *fl_owner_t;

/* 291 */
struct file_operations
{
  module *owner;
  loff_t (*llseek)(file *, loff_t, int);
  ssize_t (*read)(file *, char *, size_t, loff_t *);
  ssize_t (*write)(file *, const char *, size_t, loff_t *);
  ssize_t (*read_iter)(kiocb *, iov_iter *);
  ssize_t (*write_iter)(kiocb *, iov_iter *);
  int (*iterate)(file *, dir_context *);
  int (*iterate_shared)(file *, dir_context *);
  unsigned int (*poll)(file *, poll_table_struct *);
  __int64 (*unlocked_ioctl)(file *, unsigned int, unsigned __int64);
  __int64 (*compat_ioctl)(file *, unsigned int, unsigned __int64);
  int (*mmap)(file *, vm_area_struct *);
  int (*open)(inode *, file *);
  int (*flush)(file *, fl_owner_t);
  int (*release)(inode *, file *);
  int (*fsync)(file *, loff_t, loff_t, int);
  int (*fasync)(int, file *, int);
  int (*lock)(file *, int, file_lock *);
  ssize_t (*sendpage)(file *, page *, int, size_t, loff_t *, int);
  unsigned __int64 (*get_unmapped_area)(file *, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64);
  int (*check_flags)(int);
  int (*flock)(file *, int, file_lock *);
  ssize_t (*splice_write)(pipe_inode_info *, file *, loff_t *, size_t, unsigned int);
  ssize_t (*splice_read)(file *, loff_t *, pipe_inode_info *, size_t, unsigned int);
  int (*setlease)(file *, __int64, file_lock **, void **);
  __int64 (*fallocate)(file *, int, loff_t, loff_t);
  void (*show_fdinfo)(seq_file *, file *);
  ssize_t (*copy_file_range)(file *, loff_t, file *, loff_t, size_t, unsigned int);
  int (*clone_file_range)(file *, loff_t, file *, loff_t, u64);
  ssize_t (*dedupe_file_range)(file *, u64, u64, file *, u64);
};

/* 73 */
struct vm_fault
{
  unsigned int flags;
  gfp_t gfp_mask;
  unsigned __int64 pgoff;
  void *virtual_address;
  page *cow_page;
  page *page;
  void *entry;
};

/* 426 */
typedef u64 pmdval_t;

/* 420 */
struct pmd_t
{
  pmdval_t pmd;
};

/* 418 */
struct fault_env
{
  vm_area_struct *vma;
  unsigned __int64 address;
  unsigned int flags;
  pmd_t *pmd;
  pte_t *pte;
  spinlock_t *ptl;
  pgtable_t prealloc_pte;
};

/* 260 */
typedef u64 pgdval_t;

/* 247 */
struct pgd_t
{
  pgdval_t pgd;
};

/* 249 */
struct core_thread
{
  task_struct *task;
  core_thread *next;
};

/* 245 */
struct core_state
{
  atomic_t nr_threads;
  core_thread dumper;
  completion startup;
};

/* 204 */
struct __attribute__((aligned(128))) hrtimer_cpu_base
{
  raw_spinlock_t lock;
  seqcount_t seq;
  hrtimer *running;
  unsigned int cpu;
  unsigned int active_bases;
  unsigned int clock_was_set_seq;
  bool migration_enabled;
  bool nohz_active;
  unsigned __int32 in_hrtirq : 1;
  unsigned __int32 hres_active : 1;
  unsigned __int32 hang_detected : 1;
  ktime_t expires_next;
  hrtimer *next_timer;
  unsigned int nr_events;
  unsigned int nr_retries;
  unsigned int nr_hangs;
  unsigned int max_hang_time;
  hrtimer_clock_base clock_base[4];
};

/* 124 */
typedef int s32;

/* 45 */
typedef s32 compat_time_t;

/* 288 */
struct compat_timespec
{
  compat_time_t tv_sec;
  s32 tv_nsec;
};

/* 294 */
typedef int __s32;

/* 429 */
typedef __s32 int32_t;

/* 197 */
typedef int32_t key_serial_t;

/* 476 */
union key::$8F7DEF0814BC0067EA29EA16A4BB90EB
{
  list_head graveyard_link;
  rb_node serial_node;
};

/* 194 */
struct key_user;

/* 196 */
typedef __kernel_time_t time_t;

/* 477 */
union key::$625BD7610F25A48429A4664E687CF749
{
  time_t expiry;
  time_t revoked_at;
};

/* 407 */
typedef __u32 uint32_t;

/* 195 */
typedef uint32_t key_perm_t;

/* 201 */
struct key_type;

/* 200 */
struct keyring_index_key
{
  key_type *type;
  const char *description;
  size_t desc_len;
};

/* 478 */
struct key::$78A14D6C56B7078A54B37B3CF5F6A3BA::$178B31464327098BBCAFA523F9DE62F2
{
  key_type *type;
  char *description;
};

/* 479 */
union key::$78A14D6C56B7078A54B37B3CF5F6A3BA
{
  keyring_index_key index_key;
  struct
  {
    key_type *type;
    char *description;
  };
};

/* 198 */
union key_payload
{
  void *rcu_data0;
  void *data[4];
};

/* 202 */
struct assoc_array_ptr;

/* 199 */
struct assoc_array
{
  assoc_array_ptr *root;
  unsigned __int64 nr_leaves_on_tree;
};

/* 480 */
struct key::$26F4A9177EE560B22F24C246ABC0F317::$FA1F96C4209A82444F7F77101C731C3B
{
  list_head name_link;
  assoc_array keys;
};

/* 481 */
union key::$26F4A9177EE560B22F24C246ABC0F317
{
  key_payload payload;
  struct
  {
    list_head name_link;
    assoc_array keys;
  };
  int reject_error;
};

/* 193 */
struct key
{
  atomic_t usage;
  key_serial_t serial;
  union
  {
    list_head graveyard_link;
    rb_node serial_node;
  };
  rw_semaphore sem;
  key_user *user;
  void *security;
  union
  {
    time_t expiry;
    time_t revoked_at;
  };
  time_t last_used_at;
  kuid_t uid;
  kgid_t gid;
  key_perm_t perm;
  unsigned __int16 quotalen;
  unsigned __int16 datalen;
  unsigned __int64 flags;
  union
  {
    keyring_index_key index_key;
    struct
    {
      key_type *type;
      char *description;
    };
  };
  union
  {
    key_payload payload;
    struct
    {
      list_head name_link;
      assoc_array keys;
    };
    int reject_error;
  };
  int (*restrict_link)(key *, const key_type *, const key_payload *);
};

/* 242 */
struct user_struct
{
  atomic_t __count;
  atomic_t processes;
  atomic_t sigpending;
  atomic_t inotify_watches;
  atomic_t inotify_devs;
  atomic_long_t epoll_watches;
  unsigned __int64 mq_bytes;
  unsigned __int64 locked_shm;
  unsigned __int64 unix_inflight;
  atomic_long_t pipe_bufs;
  key *uid_keyring;
  key *session_keyring;
  hlist_node uidhash_node;
  kuid_t uid;
  atomic_long_t locked_vm;
};

/* 188 */
struct group_info
{
  atomic_t usage;
  int ngroups;
  kgid_t gid[];
};

/* 184 */
typedef void percpu_ref_func_t(percpu_ref *);

/* 8 */
struct percpu_ref
{
  atomic_long_t count;
  unsigned __int64 percpu_count_ptr;
  percpu_ref_func_t *release;
  percpu_ref_func_t *confirm_switch;
  __int8 force_atomic : 1;
  callback_head rcu;
};

/* 176 */
struct cgroup_subsys_state
{
  cgroup *cgroup;
  cgroup_subsys *ss;
  percpu_ref refcnt;
  cgroup_subsys_state *parent;
  list_head sibling;
  list_head children;
  int id;
  unsigned int flags;
  u64 serial_nr;
  atomic_t online_cnt;
  callback_head callback_head;
  work_struct destroy_work;
};

/* 179 */
struct cgroup_file
{
  kernfs_node *kn;
};

/* 172 */
struct cgroup
{
  cgroup_subsys_state self;
  unsigned __int64 flags;
  int id;
  int level;
  int populated_cnt;
  kernfs_node *kn;
  cgroup_file procs_file;
  cgroup_file events_file;
  u16 subtree_control;
  u16 subtree_ss_mask;
  u16 old_subtree_control;
  u16 old_subtree_ss_mask;
  cgroup_root *root;
  list_head cset_links;
  list_head pidlists;
  mutex pidlist_mutex;
  wait_queue_head_t offline_waitq;
  work_struct release_agent_work;
  int ancestor_ids[];
};

/* 441 */
struct qstr::$0AE0310CAA73BD15E9D8A41539807709::$19297B8565531AC76857E0FF223BC140
{
  u32 hash;
  u32 len;
};

/* 442 */
union qstr::$0AE0310CAA73BD15E9D8A41539807709
{
  struct
  {
    u32 hash;
    u32 len;
  };
  u64 hash_len;
};

/* 391 */
struct qstr
{
  union
  {
    struct
    {
      u32 hash;
      u32 len;
    };
    u64 hash_len;
  };
  const unsigned __int8 *name;
};

/* 396 */
struct __attribute__((aligned(32))) dentry_operations
{
  int (*d_revalidate)(dentry *, unsigned int);
  int (*d_weak_revalidate)(dentry *, unsigned int);
  int (*d_hash)(const dentry *, qstr *);
  int (*d_compare)(const dentry *, unsigned int, const char *, const qstr *);
  int (*d_delete)(const dentry *);
  int (*d_init)(dentry *);
  void (*d_release)(dentry *);
  void (*d_prune)(dentry *);
  void (*d_iput)(dentry *, inode *);
  char *(*d_dname)(dentry *, char *, int);
  vfsmount *(*d_automount)(path *);
  int (*d_manage)(dentry *, bool);
  dentry *(*d_real)(dentry *, const inode *, unsigned int);
};

/* 346 */
struct export_operations;

/* 345 */
struct xattr_handler;

/* 344 */
struct fscrypt_operations;

/* 395 */
struct hlist_bl_head
{
  hlist_bl_node *first;
};

/* 343 */
struct mtd_info;

/* 378 */
typedef __int64 qsize_t;

/* 370 */
struct mem_dqinfo
{
  quota_format_type *dqi_format;
  int dqi_fmt_id;
  list_head dqi_dirty_list;
  unsigned __int64 dqi_flags;
  unsigned int dqi_bgrace;
  unsigned int dqi_igrace;
  qsize_t dqi_max_spc_limit;
  qsize_t dqi_max_ino_limit;
  void *dqi_priv;
};

/* 71 */
struct quota_info
{
  unsigned int flags;
  mutex dqio_mutex;
  mutex dqonoff_mutex;
  inode *files[3];
  mem_dqinfo info[3];
  const quota_format_ops *ops[3];
};

/* 183 */
enum rcu_sync_type : __int32
{
  rcu_sync_type::RCU_SYNC = 0x0,
  rcu_sync_type::RCU_SCHED_SYNC = 0x1,
  rcu_sync_type::RCU_BH_SYNC = 0x2,
};

/* 182 */
struct __attribute__((aligned(8))) rcu_sync
{
  int gp_state;
  int gp_count;
  wait_queue_head_t gp_wait;
  int cb_state;
  callback_head cb_head;
  rcu_sync_type gp_type;
};

/* 349 */
struct __attribute__((aligned(8))) percpu_rw_semaphore
{
  rcu_sync rss;
  unsigned int *read_count;
  rw_semaphore rw_sem;
  wait_queue_head_t writer;
  int readers_block;
};

/* 70 */
struct sb_writers
{
  int frozen;
  wait_queue_head_t wait_unfrozen;
  percpu_rw_semaphore rw_sem[3];
};

/* 393 */
struct shrinker
{
  unsigned __int64 (*count_objects)(shrinker *, shrink_control *);
  unsigned __int64 (*scan_objects)(shrinker *, shrink_control *);
  int seeks;
  __int64 batch;
  unsigned __int64 flags;
  list_head list;
  atomic_long_t *nr_deferred;
};

/* 261 */
struct workqueue_struct;

/* 69 */
struct list_lru
{
  list_lru_node *node;
};

/* 392 */
struct super_block
{
  list_head s_list;
  dev_t s_dev;
  unsigned __int8 s_blocksize_bits;
  unsigned __int64 s_blocksize;
  loff_t s_maxbytes;
  file_system_type *s_type;
  const super_operations *s_op;
  const dquot_operations *dq_op;
  const quotactl_ops *s_qcop;
  const export_operations *s_export_op;
  unsigned __int64 s_flags;
  unsigned __int64 s_iflags;
  unsigned __int64 s_magic;
  dentry *s_root;
  rw_semaphore s_umount;
  int s_count;
  atomic_t s_active;
  const xattr_handler **s_xattr;
  const fscrypt_operations *s_cop;
  hlist_bl_head s_anon;
  list_head s_mounts;
  block_device *s_bdev;
  backing_dev_info *s_bdi;
  mtd_info *s_mtd;
  hlist_node s_instances;
  unsigned int s_quota_types;
  quota_info s_dquot;
  sb_writers s_writers;
  char s_id[32];
  u8 s_uuid[16];
  void *s_fs_info;
  unsigned int s_max_links;
  fmode_t s_mode;
  u32 s_time_gran;
  mutex s_vfs_rename_mutex;
  char *s_subtype;
  char *s_options;
  const dentry_operations *s_d_op;
  int cleancache_poolid;
  shrinker s_shrink;
  atomic_long_t s_remove_count;
  int s_readonly_remount;
  workqueue_struct *s_dio_done_wq;
  hlist_head s_pins;
  user_namespace *s_user_ns;
  __attribute__((aligned(128))) list_lru s_dentry_lru;
  __attribute__((aligned(128))) list_lru s_inode_lru;
  callback_head rcu;
  work_struct destroy_work;
  mutex s_sync_lock;
  int s_stack_depth;
  __attribute__((aligned(32))) spinlock_t s_inode_list_lock;
  list_head s_inodes;
  spinlock_t s_inode_wblist_lock;
  list_head s_inodes_wb;
};

/* 360 */
struct __attribute__((aligned(128))) inode_operations
{
  dentry *(*lookup)(inode *, dentry *, unsigned int);
  const char *(*get_link)(dentry *, inode *, delayed_call *);
  int (*permission)(inode *, int);
  posix_acl *(*get_acl)(inode *, int);
  int (*readlink)(dentry *, char *, int);
  int (*create)(inode *, dentry *, umode_t, bool);
  int (*link)(dentry *, inode *, dentry *);
  int (*unlink)(inode *, dentry *);
  int (*symlink)(inode *, dentry *, const char *);
  int (*mkdir)(inode *, dentry *, umode_t);
  int (*rmdir)(inode *, dentry *);
  int (*mknod)(inode *, dentry *, umode_t, dev_t);
  int (*rename)(inode *, dentry *, inode *, dentry *, unsigned int);
  int (*setattr)(dentry *, iattr *);
  int (*getattr)(vfsmount *, dentry *, kstat *);
  ssize_t (*listxattr)(dentry *, char *, size_t);
  int (*fiemap)(inode *, fiemap_extent_info *, u64, u64);
  int (*update_time)(inode *, timespec *, int);
  int (*atomic_open)(inode *, dentry *, file *, unsigned int, umode_t, int *);
  int (*tmpfile)(inode *, dentry *, umode_t);
  int (*set_acl)(inode *, posix_acl *, int);
};

/* 359 */
struct file_lock_context
{
  spinlock_t flc_lock;
  list_head flc_flock;
  list_head flc_posix;
  list_head flc_lease;
};

/* 513 */
struct radix_tree_node::$7CCE6C15E71D2D82D210B1B7C514DBFC::$0B048D1E327EBE07DDD68998B73B3342
{
  radix_tree_node *parent;
  void *private_data;
};

/* 514 */
union radix_tree_node::$7CCE6C15E71D2D82D210B1B7C514DBFC
{
  struct
  {
    radix_tree_node *parent;
    void *private_data;
  };
  callback_head callback_head;
};

/* 387 */
struct radix_tree_node
{
  unsigned __int8 shift;
  unsigned __int8 offset;
  unsigned int count;
  union
  {
    struct
    {
      radix_tree_node *parent;
      void *private_data;
    };
    callback_head callback_head;
  };
  list_head private_list;
  void *slots[64];
  unsigned __int64 tags[3][1];
};

/* 63 */
struct writeback_control;

/* 366 */
typedef unsigned __int64 sector_t;

/* 368 */
enum migrate_mode : __int32
{
  migrate_mode::MIGRATE_ASYNC = 0x0,
  migrate_mode::MIGRATE_SYNC_LIGHT = 0x1,
  migrate_mode::MIGRATE_SYNC = 0x2,
};

/* 367 */
typedef unsigned int isolate_mode_t;

/* 61 */
struct swap_info_struct;

/* 369 */
struct address_space_operations
{
  int (*writepage)(page *, writeback_control *);
  int (*readpage)(file *, page *);
  int (*writepages)(address_space *, writeback_control *);
  int (*set_page_dirty)(page *);
  int (*readpages)(file *, address_space *, list_head *, unsigned int);
  int (*write_begin)(file *, address_space *, loff_t, unsigned int, unsigned int, page **, void **);
  int (*write_end)(file *, address_space *, loff_t, unsigned int, unsigned int, page *, void *);
  sector_t (*bmap)(address_space *, sector_t);
  void (*invalidatepage)(page *, unsigned int, unsigned int);
  int (*releasepage)(page *, gfp_t);
  void (*freepage)(page *);
  ssize_t (*direct_IO)(kiocb *, iov_iter *);
  int (*migratepage)(address_space *, page *, page *, migrate_mode);
  bool (*isolate_page)(page *, isolate_mode_t);
  void (*putback_page)(page *);
  int (*launder_page)(page *);
  int (*is_partially_uptodate)(page *, unsigned __int64, unsigned __int64);
  void (*is_dirty_writeback)(page *, bool *, bool *);
  int (*error_remove_page)(address_space *, page *);
  int (*swap_activate)(swap_info_struct *, file *, sector_t *);
  void (*swap_deactivate)(file *);
};

/* 365 */
struct hd_struct;

/* 364 */
struct gendisk;

/* 363 */
struct request_queue;

/* 416 */
struct block_device
{
  dev_t bd_dev;
  int bd_openers;
  inode *bd_inode;
  super_block *bd_super;
  mutex bd_mutex;
  void *bd_claiming;
  void *bd_holder;
  int bd_holders;
  bool bd_write_holder;
  list_head bd_holder_disks;
  block_device *bd_contains;
  unsigned int bd_block_size;
  hd_struct *bd_part;
  unsigned int bd_part_count;
  int bd_invalidated;
  gendisk *bd_disk;
  request_queue *bd_queue;
  list_head bd_list;
  unsigned __int64 bd_private;
  int bd_fsfreeze_count;
  mutex bd_fsfreeze_mutex;
};

/* 50 */
enum module_state : __int32
{
  module_state::MODULE_STATE_LIVE = 0x0,
  module_state::MODULE_STATE_COMING = 0x1,
  module_state::MODULE_STATE_GOING = 0x2,
  module_state::MODULE_STATE_UNFORMED = 0x3,
};

/* 89 */
struct module_param_attrs;

/* 49 */
struct module_kobject
{
  kobject kobj;
  module *mod;
  kobject *drivers_dir;
  module_param_attrs *mp;
  completion *kobj_completion;
};

/* 84 */
struct latch_tree_node
{
  rb_node node[2];
};

/* 83 */
struct mod_tree_node
{
  module *mod;
  latch_tree_node node;
};

/* 48 */
struct module_layout
{
  void *base;
  unsigned int size;
  unsigned int text_size;
  unsigned int ro_size;
  unsigned int ro_after_init_size;
  mod_tree_node mtn;
};

/* 82 */
typedef elf64_sym Elf64_Sym;

/* 46 */
struct mod_kallsyms
{
  Elf64_Sym *symtab;
  unsigned int num_symtab;
  char *strtab;
};

/* 78 */
struct module_sect_attrs;

/* 77 */
struct module_notes_attrs;

/* 90 */
struct __attribute__((aligned(128))) module
{
  module_state state;
  list_head list;
  char name[56];
  module_kobject mkobj;
  module_attribute *modinfo_attrs;
  const char *version;
  const char *srcversion;
  kobject *holders_dir;
  const kernel_symbol *syms;
  const unsigned __int64 *crcs;
  unsigned int num_syms;
  mutex param_lock;
  kernel_param *kp;
  unsigned int num_kp;
  unsigned int num_gpl_syms;
  const kernel_symbol *gpl_syms;
  const unsigned __int64 *gpl_crcs;
  bool async_probe_requested;
  const kernel_symbol *gpl_future_syms;
  const unsigned __int64 *gpl_future_crcs;
  unsigned int num_gpl_future_syms;
  unsigned int num_exentries;
  exception_table_entry *extable;
  int (*init)(void);
  __attribute__((aligned(64))) module_layout core_layout;
  module_layout init_layout;
  unsigned int taints;
  unsigned int num_bugs;
  list_head bug_list;
  bug_entry *bug_table;
  mod_kallsyms *kallsyms;
  mod_kallsyms core_kallsyms;
  module_sect_attrs *sect_attrs;
  module_notes_attrs *notes_attrs;
  char *args;
  void *percpu;
  unsigned int percpu_size;
  list_head source_list;
  list_head target_list;
  void (*exit)(void);
  atomic_t refcnt;
};

/* 67 */
struct __attribute__((aligned(8))) kiocb
{
  file *ki_filp;
  loff_t ki_pos;
  void (*ki_complete)(kiocb *, __int64, __int64);
  void *private;
  int ki_flags;
};

/* 341 */
typedef int (*filldir_t)(dir_context *, const char *, int, loff_t, u64, unsigned int);

/* 59 */
struct dir_context
{
  const filldir_t actor;
  loff_t pos;
};

/* 354 */
struct nlm_lockowner;

/* 352 */
struct nfs_lock_info
{
  u32 state;
  nlm_lockowner *owner;
  list_head list;
};

/* 353 */
struct nfs4_lock_state;

/* 351 */
struct nfs4_lock_info
{
  nfs4_lock_state *owner;
};

/* 509 */
struct __attribute__((aligned(8))) file_lock::$2AF5E210190BF6CAE5315EA35B2128EC::$310E5EF773B5782C842C3B1068C651F1
{
  list_head link;
  int state;
};

/* 510 */
union file_lock::$2AF5E210190BF6CAE5315EA35B2128EC
{
  nfs_lock_info nfs_fl;
  nfs4_lock_info nfs4_fl;
  file_lock::$2AF5E210190BF6CAE5315EA35B2128EC::$310E5EF773B5782C842C3B1068C651F1 afs;
};

/* 60 */
struct file_lock
{
  file_lock *fl_next;
  list_head fl_list;
  hlist_node fl_link;
  list_head fl_block;
  fl_owner_t fl_owner;
  unsigned int fl_flags;
  unsigned __int8 fl_type;
  unsigned int fl_pid;
  int fl_link_cpu;
  pid *fl_nspid;
  wait_queue_head_t fl_wait;
  file *fl_file;
  loff_t fl_start;
  loff_t fl_end;
  fasync_struct *fl_fasync;
  unsigned __int64 fl_break_time;
  unsigned __int64 fl_downgrade_time;
  const file_lock_operations *fl_ops;
  const lock_manager_operations *fl_lmops;
  file_lock::$2AF5E210190BF6CAE5315EA35B2128EC fl_u;
};

/* 419 */
struct pte_t
{
  pteval_t pte;
};

/* 5 */
struct cgroup_taskset;

/* 177 */
struct __attribute__((aligned(8))) cgroup_subsys
{
  cgroup_subsys_state *(*css_alloc)(cgroup_subsys_state *);
  int (*css_online)(cgroup_subsys_state *);
  void (*css_offline)(cgroup_subsys_state *);
  void (*css_released)(cgroup_subsys_state *);
  void (*css_free)(cgroup_subsys_state *);
  void (*css_reset)(cgroup_subsys_state *);
  int (*can_attach)(cgroup_taskset *);
  void (*cancel_attach)(cgroup_taskset *);
  void (*attach)(cgroup_taskset *);
  void (*post_attach)(void);
  int (*can_fork)(task_struct *);
  void (*cancel_fork)(task_struct *);
  void (*fork)(task_struct *);
  void (*exit)(task_struct *);
  void (*free)(task_struct *);
  void (*bind)(cgroup_subsys_state *);
  __int8 early_init : 1;
  __int8 implicit_on_dfl : 1;
  __int8 broken_hierarchy : 1;
  __int8 warned_broken_hierarchy : 1;
  int id;
  const char *name;
  const char *legacy_name;
  cgroup_root *root;
  idr css_idr;
  list_head cfts;
  cftype *dfl_cftypes;
  cftype *legacy_cftypes;
  unsigned int depends_on;
};

/* 170 */
struct cgroup_root
{
  kernfs_root *kf_root;
  unsigned int subsys_mask;
  int hierarchy_id;
  cgroup cgrp;
  int cgrp_ancestor_id_storage;
  atomic_t nr_cgrps;
  list_head root_list;
  unsigned int flags;
  idr cgroup_idr;
  char release_agent_path[4096];
  char name[64];
};

/* 319 */
struct lock_class_key
{
};

/* 348 */
struct file_system_type
{
  const char *name;
  int fs_flags;
  dentry *(*mount)(file_system_type *, int, const char *, void *);
  void (*kill_sb)(super_block *);
  module *owner;
  file_system_type *next;
  hlist_head fs_supers;
  lock_class_key s_lock_key;
  lock_class_key s_umount_key;
  lock_class_key s_vfs_rename_key;
  lock_class_key s_writers_key[];
  lock_class_key i_lock_key;
  lock_class_key i_mutex_key;
  lock_class_key i_mutex_dir_key;
};

/* 57 */
struct kstatfs;

/* 347 */
struct super_operations
{
  inode *(*alloc_inode)(super_block *);
  void (*destroy_inode)(inode *);
  void (*dirty_inode)(inode *, int);
  int (*write_inode)(inode *, writeback_control *);
  int (*drop_inode)(inode *);
  void (*evict_inode)(inode *);
  void (*put_super)(super_block *);
  int (*sync_fs)(super_block *, int);
  int (*freeze_super)(super_block *);
  int (*freeze_fs)(super_block *);
  int (*thaw_super)(super_block *);
  int (*unfreeze_fs)(super_block *);
  int (*statfs)(dentry *, kstatfs *);
  int (*remount_fs)(super_block *, int *, char *);
  void (*umount_begin)(super_block *);
  int (*show_options)(seq_file *, dentry *);
  int (*show_devname)(seq_file *, dentry *);
  int (*show_path)(seq_file *, dentry *);
  int (*show_stats)(seq_file *, dentry *);
  ssize_t (*quota_read)(super_block *, int, char *, size_t, loff_t);
  ssize_t (*quota_write)(super_block *, int, const char *, size_t, loff_t);
  dquot **(*get_dquots)(inode *);
  int (*bdev_try_to_free_page)(super_block *, page *, gfp_t);
  __int64 (*nr_cached_objects)(super_block *, shrink_control *);
  __int64 (*free_cached_objects)(super_block *, shrink_control *);
};

/* 379 */
struct dquot_operations
{
  int (*write_dquot)(dquot *);
  dquot *(*alloc_dquot)(super_block *, int);
  void (*destroy_dquot)(dquot *);
  int (*acquire_dquot)(dquot *);
  int (*release_dquot)(dquot *);
  int (*mark_dirty)(dquot *);
  int (*write_info)(super_block *, int);
  qsize_t *(*get_reserved_space)(inode *);
  int (*get_projid)(inode *, kprojid_t *);
  int (*get_next_id)(super_block *, kqid *);
};

/* 386 */
typedef __kernel_uid32_t projid_t;

/* 377 */
struct kprojid_t
{
  projid_t val;
};

/* 459 */
union kqid::$8A7A73CA27554BDDE75B0D5A35B43C30
{
  kuid_t uid;
  kgid_t gid;
  kprojid_t projid;
};

/* 385 */
enum quota_type : __int32
{
  quota_type::USRQUOTA = 0x0,
  quota_type::GRPQUOTA = 0x1,
  quota_type::PRJQUOTA = 0x2,
};

/* 65 */
struct kqid
{
  union
  {
    kuid_t uid;
    kgid_t gid;
    kprojid_t projid;
  };
  quota_type type;
};

/* 374 */
struct quotactl_ops
{
  int (*quota_on)(super_block *, int, int, path *);
  int (*quota_off)(super_block *, int);
  int (*quota_enable)(super_block *, unsigned int);
  int (*quota_disable)(super_block *, unsigned int);
  int (*quota_sync)(super_block *, int);
  int (*set_info)(super_block *, int, qc_info *);
  int (*get_dqblk)(super_block *, kqid, qc_dqblk *);
  int (*get_nextdqblk)(super_block *, kqid *, qc_dqblk *);
  int (*set_dqblk)(super_block *, kqid, qc_dqblk *);
  int (*get_state)(super_block *, qc_state *);
  int (*rm_xquota)(super_block *, unsigned int);
};

/* 383 */
struct quota_format_type
{
  int qf_fmt_id;
  const quota_format_ops *qf_ops;
  module *qf_owner;
  quota_format_type *qf_next;
};

/* 380 */
struct quota_format_ops
{
  int (*check_quota_file)(super_block *, int);
  int (*read_file_info)(super_block *, int);
  int (*write_file_info)(super_block *, int);
  int (*free_file_info)(super_block *, int);
  int (*read_dqblk)(dquot *);
  int (*commit_dqblk)(dquot *);
  int (*release_dqblk)(dquot *);
  int (*get_next_id)(super_block *, kqid *);
};

/* 423 */
struct mem_cgroup;

/* 422 */
struct shrink_control
{
  gfp_t gfp_mask;
  unsigned __int64 nr_to_scan;
  int nid;
  mem_cgroup *memcg;
};

/* 389 */
struct list_lru_one
{
  list_head list;
  __int64 nr_items;
};

/* 388 */
struct __attribute__((aligned(128))) list_lru_node
{
  spinlock_t lock;
  list_lru_one lru;
};

/* 339 */
struct delayed_call
{
  void (*fn)(void *);
  void *arg;
};

/* 338 */
struct iattr
{
  unsigned int ia_valid;
  umode_t ia_mode;
  kuid_t ia_uid;
  kgid_t ia_gid;
  loff_t ia_size;
  timespec ia_atime;
  timespec ia_mtime;
  timespec ia_ctime;
  file *ia_file;
};

/* 337 */
struct kstat
{
  u64 ino;
  dev_t dev;
  umode_t mode;
  unsigned int nlink;
  kuid_t uid;
  kgid_t gid;
  dev_t rdev;
  loff_t size;
  timespec atime;
  timespec mtime;
  timespec ctime;
  unsigned __int64 blksize;
  unsigned __int64 blocks;
};

/* 336 */
struct fiemap_extent_info
{
  unsigned int fi_flags;
  unsigned int fi_extents_mapped;
  unsigned int fi_extents_max;
  fiemap_extent *fi_extents_start;
};

/* 86 */
struct module_attribute
{
  attribute attr;
  ssize_t (*show)(module_attribute *, module_kobject *, char *);
  ssize_t (*store)(module_attribute *, module_kobject *, const char *, size_t);
  void (*setup)(module *, const char *);
  int (*test)(module *);
  void (*free)(module *);
};

/* 293 */
struct kernel_symbol
{
  unsigned __int64 value;
  const char *name;
};

/* 94 */
typedef char s8;

/* 437 */
union kernel_param::$EB65E7CF02C3583BBBE2C6D9B344BA81
{
  void *arg;
  const kparam_string *str;
  const kparam_array *arr;
};

/* 81 */
struct kernel_param
{
  const char *name;
  module *mod;
  const kernel_param_ops *ops;
  const u16 perm;
  s8 level;
  u8 flags;
  union
  {
    void *arg;
    const kparam_string *str;
    const kparam_array *arr;
  };
};

/* 80 */
struct exception_table_entry
{
  int insn;
  int fixup;
};

/* 79 */
struct bug_entry
{
  int bug_addr_disp;
  int file_disp;
  unsigned __int16 line;
  unsigned __int16 flags;
};

/* 118 */
typedef __u32 Elf64_Word;

/* 123 */
typedef unsigned __int16 __u16;

/* 117 */
typedef __u16 Elf64_Half;

/* 116 */
typedef __u64 Elf64_Addr;

/* 115 */
typedef __u64 Elf64_Xword;

/* 438 */
struct elf64_sym
{
  Elf64_Word st_name;
  unsigned __int8 st_info;
  unsigned __int8 st_other;
  Elf64_Half st_shndx;
  Elf64_Addr st_value;
  Elf64_Xword st_size;
};

/* 350 */
struct fasync_struct
{
  spinlock_t fa_lock;
  int magic;
  int fa_fd;
  fasync_struct *fa_next;
  file *fa_file;
  callback_head fa_rcu;
};

/* 356 */
struct file_lock_operations
{
  void (*fl_copy_lock)(file_lock *, file_lock *);
  void (*fl_release_private)(file_lock *);
};

/* 355 */
struct lock_manager_operations
{
  int (*lm_compare_owner)(file_lock *, file_lock *);
  unsigned __int64 (*lm_owner_key)(file_lock *);
  fl_owner_t (*lm_get_owner)(fl_owner_t);
  void (*lm_put_owner)(fl_owner_t);
  void (*lm_notify)(file_lock *);
  int (*lm_grant)(file_lock *, int);
  bool (*lm_break)(file_lock *);
  int (*lm_change)(file_lock *, int, list_head *);
  void (*lm_setup)(file_lock *, void **);
};

/* 166 */
struct cftype
{
  char name[64];
  unsigned __int64 private;
  size_t max_write_len;
  unsigned int flags;
  unsigned int file_offset;
  cgroup_subsys *ss;
  list_head node;
  kernfs_ops *kf_ops;
  u64 (*read_u64)(cgroup_subsys_state *, cftype *);
  s64 (*read_s64)(cgroup_subsys_state *, cftype *);
  int (*seq_show)(seq_file *, void *);
  void *(*seq_start)(seq_file *, loff_t *);
  void *(*seq_next)(seq_file *, void *, loff_t *);
  void (*seq_stop)(seq_file *, void *);
  int (*write_u64)(cgroup_subsys_state *, cftype *, u64);
  int (*write_s64)(cgroup_subsys_state *, cftype *, s64);
  ssize_t (*write)(kernfs_open_file *, char *, size_t, loff_t);
};

/* 120 */
typedef __int64 __s64;

/* 384 */
typedef __s64 time64_t;

/* 64 */
struct mem_dqblk
{
  qsize_t dqb_bhardlimit;
  qsize_t dqb_bsoftlimit;
  qsize_t dqb_curspace;
  qsize_t dqb_rsvspace;
  qsize_t dqb_ihardlimit;
  qsize_t dqb_isoftlimit;
  qsize_t dqb_curinodes;
  time64_t dqb_btime;
  time64_t dqb_itime;
};

/* 66 */
struct dquot
{
  hlist_node dq_hash;
  list_head dq_inuse;
  list_head dq_free;
  list_head dq_dirty;
  mutex dq_lock;
  atomic_t dq_count;
  wait_queue_head_t dq_wait_unused;
  super_block *dq_sb;
  kqid dq_id;
  loff_t dq_off;
  unsigned __int64 dq_flags;
  mem_dqblk dq_dqb;
};

/* 373 */
struct qc_info
{
  int i_fieldmask;
  unsigned int i_flags;
  unsigned int i_spc_timelimit;
  unsigned int i_ino_timelimit;
  unsigned int i_rt_spc_timelimit;
  unsigned int i_spc_warnlimit;
  unsigned int i_ino_warnlimit;
  unsigned int i_rt_spc_warnlimit;
};

/* 372 */
struct __attribute__((aligned(8))) qc_dqblk
{
  int d_fieldmask;
  u64 d_spc_hardlimit;
  u64 d_spc_softlimit;
  u64 d_ino_hardlimit;
  u64 d_ino_softlimit;
  u64 d_space;
  u64 d_ino_count;
  s64 d_ino_timer;
  s64 d_spc_timer;
  int d_ino_warns;
  int d_spc_warns;
  u64 d_rt_spc_hardlimit;
  u64 d_rt_spc_softlimit;
  u64 d_rt_space;
  s64 d_rt_spc_timer;
  int d_rt_spc_warns;
};

/* 375 */
struct qc_type_state
{
  unsigned int flags;
  unsigned int spc_timelimit;
  unsigned int ino_timelimit;
  unsigned int rt_spc_timelimit;
  unsigned int spc_warnlimit;
  unsigned int ino_warnlimit;
  unsigned int rt_spc_warnlimit;
  unsigned __int64 ino;
  blkcnt_t blocks;
  blkcnt_t nextents;
};

/* 371 */
struct qc_state
{
  unsigned int s_incoredqs;
  qc_type_state s_state[3];
};

/* 342 */
struct fiemap_extent
{
  __u64 fe_logical;
  __u64 fe_physical;
  __u64 fe_length;
  __u64 fe_reserved64[2];
  __u32 fe_flags;
  __u32 fe_reserved[3];
};

/* 95 */
struct kernel_param_ops
{
  unsigned int flags;
  int (*set)(const char *, const kernel_param *);
  int (*get)(char *, const kernel_param *);
  void (*free)(void *);
};

/* 92 */
struct kparam_string
{
  unsigned int maxlen;
  char *string;
};

/* 91 */
struct kparam_array
{
  unsigned int max;
  unsigned int elemsize;
  unsigned int *num;
  const kernel_param_ops *ops;
  void *elem;
};

/* 213 */
typedef int (*notifier_fn_t)(notifier_block *, unsigned __int64, void *);

/* 9 */
struct __attribute__((aligned(8))) notifier_block
{
  notifier_fn_t notifier_call;
  notifier_block *next;
  int priority;
};

/* 264 */
typedef int proc_handler(ctl_table *, int, void *, size_t *, loff_t *);

/* 12 */
struct ctl_table
{
  const char *procname;
  void *data;
  int maxlen;
  umode_t mode;
  ctl_table *child;
  proc_handler *proc_handler;
  ctl_table_poll *poll;
  void *extra1;
  void *extra2;
};

/* 263 */
struct ctl_table_poll
{
  atomic_t event;
  wait_queue_head_t wait;
};

/* 13 */
struct uprobes_state
{
};

/* 28 */
struct seccomp
{
};

/* 47 */
struct mod_arch_specific
{
};

/* 51 */
enum probe_type : __int32
{
  probe_type::PROBE_DEFAULT_STRATEGY = 0x0,
  probe_type::PROBE_PREFER_ASYNCHRONOUS = 0x1,
  probe_type::PROBE_FORCE_SYNCHRONOUS = 0x2,
};

/* 313 */
struct of_device_id;

/* 312 */
struct acpi_device_id;

/* 331 */
struct pm_message
{
  int event;
};

/* 317 */
typedef pm_message pm_message_t;

/* 311 */
struct driver_private;

/* 52 */
struct device_driver
{
  const char *name;
  bus_type *bus;
  module *owner;
  const char *mod_name;
  bool suppress_bind_attrs;
  probe_type probe_type;
  const of_device_id *of_match_table;
  const acpi_device_id *acpi_match_table;
  int (*probe)(device *);
  int (*remove)(device *);
  void (*shutdown)(device *);
  int (*suspend)(device *, pm_message_t);
  int (*resume)(device *);
  const attribute_group **groups;
  const dev_pm_ops *pm;
  driver_private *p;
};

/* 316 */
struct iommu_ops;

/* 315 */
struct subsys_private;

/* 53 */
struct bus_type
{
  const char *name;
  const char *dev_name;
  device *dev_root;
  device_attribute *dev_attrs;
  const attribute_group **bus_groups;
  const attribute_group **dev_groups;
  const attribute_group **drv_groups;
  int (*match)(device *, device_driver *);
  int (*uevent)(device *, kobj_uevent_env *);
  int (*probe)(device *);
  int (*remove)(device *);
  void (*shutdown)(device *);
  int (*online)(device *);
  int (*offline)(device *);
  int (*suspend)(device *, pm_message_t);
  int (*resume)(device *);
  const dev_pm_ops *pm;
  const iommu_ops *iommu_ops;
  subsys_private *p;
  lock_class_key lock_key;
};

/* 308 */
struct device_private;

/* 325 */
struct __attribute__((aligned(8))) timer_list
{
  hlist_node entry;
  unsigned __int64 expires;
  void (*function)(unsigned __int64);
  unsigned __int64 data;
  u32 flags;
};

/* 323 */
struct wake_irq;

/* 327 */
enum rpm_request : __int32
{
  rpm_request::RPM_REQ_NONE = 0x0,
  rpm_request::RPM_REQ_IDLE = 0x1,
  rpm_request::RPM_REQ_SUSPEND = 0x2,
  rpm_request::RPM_REQ_AUTOSUSPEND = 0x3,
  rpm_request::RPM_REQ_RESUME = 0x4,
};

/* 326 */
enum rpm_status : __int32
{
  rpm_status::RPM_ACTIVE = 0x0,
  rpm_status::RPM_RESUMING = 0x1,
  rpm_status::RPM_SUSPENDED = 0x2,
  rpm_status::RPM_SUSPENDING = 0x3,
};

/* 321 */
struct dev_pm_qos;

/* 55 */
struct dev_pm_info
{
  pm_message_t power_state;
  unsigned __int32 can_wakeup : 1;
  unsigned __int32 async_suspend : 1;
  __int8 is_prepared : 1;
  __int8 is_suspended : 1;
  __int8 is_noirq_suspended : 1;
  __int8 is_late_suspended : 1;
  __int8 early_init : 1;
  __int8 direct_complete : 1;
  __attribute__((aligned(4))) spinlock_t lock;
  list_head entry;
  completion completion;
  wakeup_source *wakeup;
  __int8 wakeup_path : 1;
  __int8 syscore : 1;
  __int8 no_pm_callbacks : 1;
  timer_list suspend_timer;
  unsigned __int64 timer_expires;
  work_struct work;
  wait_queue_head_t wait_queue;
  wake_irq *wakeirq;
  atomic_t usage_count;
  atomic_t child_count;
  unsigned __int32 disable_depth : 3;
  unsigned __int32 idle_notification : 1;
  unsigned __int32 request_pending : 1;
  unsigned __int32 deferred_resume : 1;
  unsigned __int32 run_wake : 1;
  unsigned __int32 runtime_auto : 1;
  __int8 ignore_children : 1;
  unsigned __int32 no_callbacks : 1;
  unsigned __int32 irq_safe : 1;
  unsigned __int32 use_autosuspend : 1;
  unsigned __int32 timer_autosuspends : 1;
  unsigned __int32 memalloc_noio : 1;
  rpm_request request;
  rpm_status runtime_status;
  int runtime_error;
  int autosuspend_delay;
  unsigned __int64 last_busy;
  unsigned __int64 active_jiffies;
  unsigned __int64 suspended_jiffies;
  unsigned __int64 accounting_timestamp;
  pm_subsys_data *subsys_data;
  void (*set_latency_tolerance)(device *, s32);
  dev_pm_qos *qos;
};

/* 304 */
struct dma_coherent_mem;

/* 303 */
struct cma;

/* 403 */
struct dma_map_ops;

/* 54 */
struct __attribute__((aligned(8))) dev_archdata
{
  dma_map_ops *dma_ops;
  void *iommu;
  bool dma_coherent;
};

/* 302 */
struct device_node;

/* 301 */
struct fwnode_handle;

/* 329 */
struct __attribute__((aligned(8))) klist_node
{
  void *n_klist;
  list_head n_node;
  kref n_ref;
};

/* 300 */
struct iommu_group;

/* 299 */
struct iommu_fwspec;

/* 56 */
struct __attribute__((aligned(8))) device
{
  device *parent;
  device_private *p;
  kobject kobj;
  const char *init_name;
  const device_type *type;
  mutex mutex;
  bus_type *bus;
  device_driver *driver;
  void *platform_data;
  void *driver_data;
  dev_pm_info power;
  dev_pm_domain *pm_domain;
  dev_pin_info *pins;
  u64 *dma_mask;
  u64 coherent_dma_mask;
  unsigned __int64 dma_pfn_offset;
  device_dma_parameters *dma_parms;
  list_head dma_pools;
  dma_coherent_mem *dma_mem;
  cma *cma_area;
  dev_archdata archdata;
  device_node *of_node;
  fwnode_handle *fwnode;
  dev_t devt;
  u32 id;
  spinlock_t devres_lock;
  list_head devres_head;
  klist_node knode_class;
  class *class;
  const attribute_group **groups;
  void (*release)(device *);
  iommu_group *iommu_group;
  iommu_fwspec *iommu_fwspec;
  __int8 offline_disabled : 1;
  __int8 offline : 1;
};

/* 425 */
struct attribute_group
{
  const char *name;
  umode_t (*is_visible)(kobject *, attribute *, int);
  umode_t (*is_bin_visible)(kobject *, bin_attribute *, int);
  attribute **attrs;
  bin_attribute **bin_attrs;
};

/* 320 */
struct dev_pm_ops
{
  int (*prepare)(device *);
  void (*complete)(device *);
  int (*suspend)(device *);
  int (*resume)(device *);
  int (*freeze)(device *);
  int (*thaw)(device *);
  int (*poweroff)(device *);
  int (*restore)(device *);
  int (*suspend_late)(device *);
  int (*resume_early)(device *);
  int (*freeze_late)(device *);
  int (*thaw_early)(device *);
  int (*poweroff_late)(device *);
  int (*restore_early)(device *);
  int (*suspend_noirq)(device *);
  int (*resume_noirq)(device *);
  int (*freeze_noirq)(device *);
  int (*thaw_noirq)(device *);
  int (*poweroff_noirq)(device *);
  int (*restore_noirq)(device *);
  int (*runtime_suspend)(device *);
  int (*runtime_resume)(device *);
  int (*runtime_idle)(device *);
};

/* 318 */
struct device_attribute
{
  attribute attr;
  ssize_t (*show)(device *, device_attribute *, char *);
  ssize_t (*store)(device *, device_attribute *, const char *, size_t);
};

/* 314 */
struct device_type
{
  const char *name;
  const attribute_group **groups;
  int (*uevent)(device *, kobj_uevent_env *);
  char *(*devnode)(device *, umode_t *, kuid_t *, kgid_t *);
  void (*release)(device *);
  const dev_pm_ops *pm;
};

/* 324 */
struct __attribute__((aligned(8))) wakeup_source
{
  const char *name;
  list_head entry;
  spinlock_t lock;
  wake_irq *wakeirq;
  timer_list timer;
  unsigned __int64 timer_expires;
  ktime_t total_time;
  ktime_t max_time;
  ktime_t last_time;
  ktime_t start_prevent_time;
  ktime_t prevent_sleep_time;
  unsigned __int64 event_count;
  unsigned __int64 active_count;
  unsigned __int64 relax_count;
  unsigned __int64 expire_count;
  unsigned __int64 wakeup_count;
  __int8 active : 1;
  __int8 autosleep_enabled : 1;
};

/* 328 */
struct pm_domain_data;

/* 322 */
struct pm_subsys_data
{
  spinlock_t lock;
  unsigned int refcount;
  list_head clock_list;
  pm_domain_data *domain_data;
};

/* 307 */
struct dev_pm_domain
{
  dev_pm_ops ops;
  void (*detach)(device *, bool);
  int (*activate)(device *);
  void (*sync)(device *);
  void (*dismiss)(device *);
};

/* 333 */
struct pinctrl;

/* 332 */
struct pinctrl_state;

/* 306 */
struct dev_pin_info
{
  pinctrl *p;
  pinctrl_state *default_state;
  pinctrl_state *init_state;
  pinctrl_state *sleep_state;
  pinctrl_state *idle_state;
};

/* 305 */
struct device_dma_parameters
{
  unsigned int max_segment_size;
  unsigned __int64 segment_boundary_mask;
};

/* 309 */
struct class
{
  const char *name;
  module *owner;
  class_attribute *class_attrs;
  const attribute_group **dev_groups;
  kobject *dev_kobj;
  int (*dev_uevent)(device *, kobj_uevent_env *);
  char *(*devnode)(device *, umode_t *);
  void (*class_release)(class *);
  void (*dev_release)(device *);
  int (*suspend)(device *, pm_message_t);
  int (*resume)(device *);
  const kobj_ns_type_operations *ns_type;
  const void *(*namespace)(device *);
  const dev_pm_ops *pm;
  subsys_private *p;
};

/* 72 */
struct bin_attribute
{
  attribute attr;
  size_t size;
  void *private;
  ssize_t (*read)(file *, kobject *, bin_attribute *, char *, loff_t, size_t);
  ssize_t (*write)(file *, kobject *, bin_attribute *, char *, loff_t, size_t);
  int (*mmap)(file *, kobject *, bin_attribute *, vm_area_struct *);
};

/* 310 */
struct class_attribute
{
  attribute attr;
  ssize_t (*show)(class *, class_attribute *, char *);
  ssize_t (*store)(class *, class_attribute *, const char *, size_t);
};

/* 119 */
typedef __s64 Elf64_Sxword;

/* 443 */
union Elf64_Dyn::$933121F4FA1889599F702E16603DBB9F
{
  Elf64_Xword d_val;
  Elf64_Addr d_ptr;
};

/* 114 */
struct Elf64_Dyn
{
  Elf64_Sxword d_tag;
  Elf64_Dyn::$933121F4FA1889599F702E16603DBB9F d_un;
};

/* 286 */
typedef unsigned __int64 mm_segment_t;

/* 125 */
struct thread_info
{
  unsigned __int64 flags;
  mm_segment_t addr_limit;
  task_struct *task;
  int preempt_count;
  int cpu;
};

/* 211 */
struct cpu_topology
{
  int thread_id;
  int core_id;
  int cluster_id;
  cpumask_t thread_sibling;
  cpumask_t core_sibling;
};

/* 212 */
struct mem_section
{
  unsigned __int64 section_mem_map;
  unsigned __int64 *pageblock_flags;
};

/* 215 */
struct per_cpu_nodestat
{
  s8 stat_threshold;
  s8 vm_node_stat_diff[26];
};

/* 218 */
struct __attribute__((aligned(8))) zoneref
{
  zone *zone;
  int zone_idx;
};

/* 216 */
struct zonelist
{
  zoneref _zonerefs[4];
};

/* 219 */
struct free_area
{
  list_head free_list[6];
  unsigned __int64 nr_free;
};

/* 217 */
struct zone
{
  unsigned __int64 watermark[3];
  unsigned __int64 nr_reserved_highatomic;
  __int64 lowmem_reserve[3];
  pglist_data *zone_pgdat;
  per_cpu_pageset *pageset;
  unsigned __int64 zone_start_pfn;
  unsigned __int64 managed_pages;
  unsigned __int64 spanned_pages;
  unsigned __int64 present_pages;
  const char *name;
  unsigned __int64 nr_isolate_pageblock;
  int initialized;
  free_area free_area[11];
  unsigned __int64 flags;
  spinlock_t lock;
  __attribute__((aligned(128))) unsigned __int64 percpu_drift_mark;
  unsigned __int64 compact_cached_free_pfn;
  unsigned __int64 compact_cached_migrate_pfn[2];
  unsigned int compact_considered;
  unsigned int compact_defer_shift;
  int compact_order_failed;
  bool compact_blockskip_flush;
  bool contiguous;
  __attribute__((aligned(128))) atomic_long_t vm_stat[14];
};

/* 224 */
enum zone_type : __int32
{
  zone_type::ZONE_DMA = 0x0,
  zone_type::ZONE_NORMAL = 0x1,
  zone_type::ZONE_MOVABLE = 0x2,
  zone_type::__MAX_NR_ZONES = 0x3,
};

/* 226 */
struct zone_reclaim_stat
{
  unsigned __int64 recent_rotated[2];
  unsigned __int64 recent_scanned[2];
};

/* 223 */
struct lruvec
{
  list_head lists[5];
  zone_reclaim_stat reclaim_stat;
  atomic_long_t inactive_age;
};

/* 221 */
struct pglist_data
{
  zone node_zones[3];
  zonelist node_zonelists[1];
  int nr_zones;
  unsigned __int64 node_start_pfn;
  unsigned __int64 node_present_pages;
  unsigned __int64 node_spanned_pages;
  int node_id;
  wait_queue_head_t kswapd_wait;
  wait_queue_head_t pfmemalloc_wait;
  task_struct *kswapd;
  int kswapd_order;
  zone_type kswapd_classzone_idx;
  int kcompactd_max_order;
  zone_type kcompactd_classzone_idx;
  wait_queue_head_t kcompactd_wait;
  task_struct *kcompactd;
  unsigned __int64 totalreserve_pages;
  __attribute__((aligned(64))) spinlock_t lru_lock;
  spinlock_t split_queue_lock;
  list_head split_queue;
  unsigned __int64 split_queue_len;
  lruvec lruvec;
  unsigned int inactive_ratio;
  unsigned __int64 flags;
  __attribute__((aligned(128))) per_cpu_nodestat *per_cpu_nodestats;
  atomic_long_t vm_stat[26];
};

/* 225 */
struct per_cpu_pages
{
  int count;
  int high;
  int batch;
  list_head lists[3];
};

/* 220 */
struct __attribute__((aligned(2))) per_cpu_pageset
{
  per_cpu_pages pcp;
  s8 stat_threshold;
  s8 vm_stat_diff[14];
};

/* 222 */
struct zone_padding
{
  char x[];
};

/* 268 */
struct nodemask_t
{
  unsigned __int64 bits[1];
};

/* 277 */
struct static_key
{
  atomic_t enabled;
};

/* 274 */
struct static_key_false
{
  static_key key;
};

/* 276 */
enum ftr_type : __int32
{
  ftr_type::FTR_EXACT = 0x0,
  ftr_type::FTR_LOWER_SAFE = 0x1,
  ftr_type::FTR_HIGHER_SAFE = 0x2,
};

/* 275 */
struct arm64_ftr_bits
{
  bool sign;
  bool strict;
  ftr_type type;
  u8 shift;
  u8 width;
  s64 safe_val;
};

/* 279 */
typedef bool pstate_check_t(unsigned __int64);

/* 292 */
typedef int (*initcall_t)(void);

/* 382 */
struct percpu_counter
{
  raw_spinlock_t lock;
  s64 count;
  list_head list;
  s32 *counters;
};

/* 381 */
struct dqstats
{
  int stat[8];
  percpu_counter counter[8];
};

/* 435 */
typedef u64 phys_addr_t;

/* 402 */
typedef phys_addr_t resource_size_t;

/* 401 */
struct resource
{
  resource_size_t start;
  resource_size_t end;
  const char *name;
  unsigned __int64 flags;
  unsigned __int64 desc;
  resource *parent;
  resource *sibling;
  resource *child;
};

/* 434 */
typedef __u64 uint64_t;

/* 408 */
typedef uint64_t xen_pfn_t;

/* 516 */
struct __attribute__((aligned(8))) start_info::$D8010B2321C7E61E50B4BD9FBC138009::$85D774EF97F7B6CA102A709F124185BE
{
  xen_pfn_t mfn;
  uint32_t evtchn;
};

/* 517 */
struct start_info::$D8010B2321C7E61E50B4BD9FBC138009::$2A3EB83A4A40F91FA37ACA711423D27E
{
  uint32_t info_off;
  uint32_t info_size;
};

/* 518 */
union start_info::$D8010B2321C7E61E50B4BD9FBC138009
{
  start_info::$D8010B2321C7E61E50B4BD9FBC138009::$85D774EF97F7B6CA102A709F124185BE domU;
  start_info::$D8010B2321C7E61E50B4BD9FBC138009::$2A3EB83A4A40F91FA37ACA711423D27E dom0;
};

/* 428 */
typedef char __s8;

/* 406 */
typedef __s8 int8_t;

/* 404 */
struct start_info
{
  char magic[32];
  unsigned __int64 nr_pages;
  unsigned __int64 shared_info;
  uint32_t flags;
  xen_pfn_t store_mfn;
  uint32_t store_evtchn;
  start_info::$D8010B2321C7E61E50B4BD9FBC138009 console;
  unsigned __int64 pt_base;
  unsigned __int64 nr_pt_frames;
  unsigned __int64 mfn_list;
  unsigned __int64 mod_start;
  unsigned __int64 mod_len;
  int8_t cmd_line[1024];
  unsigned __int64 first_p2m_pfn;
  unsigned __int64 nr_p2m_frames;
};

/* 427 */
typedef unsigned __int8 __u8;

/* 415 */
typedef __u8 uint8_t;

/* 409 */
typedef uint64_t xen_ulong_t;

/* 413 */
struct pvclock_vcpu_time_info
{
  u32 version;
  u32 pad0;
  u64 tsc_timestamp;
  u64 system_time;
  u32 tsc_to_system_mul;
  s8 tsc_shift;
  u8 flags;
  u8 pad[2];
};

/* 410 */
struct vcpu_info
{
  uint8_t evtchn_upcall_pending;
  uint8_t evtchn_upcall_mask;
  xen_ulong_t evtchn_pending_sel;
  pvclock_vcpu_time_info time;
};

/* 412 */
struct pvclock_wall_clock
{
  u32 version;
  u32 sec;
  u32 nsec;
  u32 sec_hi;
};

/* 411 */
struct arch_shared_info
{
};

/* 405 */
struct shared_info
{
  vcpu_info vcpu_info[1];
  xen_ulong_t evtchn_pending[64];
  xen_ulong_t evtchn_mask[64];
  pvclock_wall_clock wc;
  arch_shared_info arch;
};

/* 414 */
struct arch_vcpu_info
{
};

/* 417 */
typedef void compound_page_dtor(page *);

/* 421 */
struct __attribute__((aligned(8))) tracepoint_func
{
  void *func;
  void *data;
  int prio;
};

/* 424 */
struct kobj_attribute
{
  attribute attr;
  ssize_t (*show)(kobject *, kobj_attribute *, char *);
  ssize_t (*store)(kobject *, kobj_attribute *, const char *, size_t);
};

/* 471 */
union thread_union
{
  thread_info thread_info;
  unsigned __int64 stack[2048];
};

/* 472 */
enum perf_event_task_context : __int32
{
  perf_event_task_context::perf_invalid_context = 0xFFFFFFFF,
  perf_event_task_context::perf_hw_context = 0x0,
  perf_event_task_context::perf_sw_context = 0x1,
  perf_event_task_context::perf_nr_task_contexts = 0x2,
};

/* 474 */
enum cgroup_subsys_id : __int32
{
  cgroup_subsys_id::CGROUP_SUBSYS_COUNT = 0x0,
};

/* 482 */
struct tick_device;

/* 483 */
enum hrtimer_base_type : __int32
{
  hrtimer_base_type::HRTIMER_BASE_MONOTONIC = 0x0,
  hrtimer_base_type::HRTIMER_BASE_REALTIME = 0x1,
  hrtimer_base_type::HRTIMER_BASE_BOOTTIME = 0x2,
  hrtimer_base_type::HRTIMER_BASE_TAI = 0x3,
  hrtimer_base_type::HRTIMER_MAX_CLOCK_BASES = 0x4,
};

/* 484 */
struct blocking_notifier_head
{
  rw_semaphore rwsem;
  notifier_block *head;
};

/* 485 */
enum zone_watermarks : __int32
{
  zone_watermarks::WMARK_MIN = 0x0,
  zone_watermarks::WMARK_LOW = 0x1,
  zone_watermarks::WMARK_HIGH = 0x2,
  zone_watermarks::NR_WMARK = 0x3,
};

/* 486 */
enum lru_list : __int32
{
  lru_list::LRU_INACTIVE_ANON = 0x0,
  lru_list::LRU_ACTIVE_ANON = 0x1,
  lru_list::LRU_INACTIVE_FILE = 0x2,
  lru_list::LRU_ACTIVE_FILE = 0x3,
  lru_list::LRU_UNEVICTABLE = 0x4,
  lru_list::NR_LRU_LISTS = 0x5,
};

/* 487 */
enum node_stat_item : __int32
{
  node_stat_item::NR_LRU_BASE = 0x0,
  node_stat_item::NR_INACTIVE_ANON = 0x0,
  node_stat_item::NR_ACTIVE_ANON = 0x1,
  node_stat_item::NR_INACTIVE_FILE = 0x2,
  node_stat_item::NR_ACTIVE_FILE = 0x3,
  node_stat_item::NR_UNEVICTABLE = 0x4,
  node_stat_item::NR_ISOLATED_ANON = 0x5,
  node_stat_item::NR_ISOLATED_FILE = 0x6,
  node_stat_item::NR_PAGES_SCANNED = 0x7,
  node_stat_item::WORKINGSET_REFAULT = 0x8,
  node_stat_item::WORKINGSET_ACTIVATE = 0x9,
  node_stat_item::WORKINGSET_NODERECLAIM = 0xA,
  node_stat_item::NR_ANON_MAPPED = 0xB,
  node_stat_item::NR_FILE_MAPPED = 0xC,
  node_stat_item::NR_FILE_PAGES = 0xD,
  node_stat_item::NR_FILE_DIRTY = 0xE,
  node_stat_item::NR_WRITEBACK = 0xF,
  node_stat_item::NR_WRITEBACK_TEMP = 0x10,
  node_stat_item::NR_SHMEM = 0x11,
  node_stat_item::NR_SHMEM_THPS = 0x12,
  node_stat_item::NR_SHMEM_PMDMAPPED = 0x13,
  node_stat_item::NR_ANON_THPS = 0x14,
  node_stat_item::NR_UNSTABLE_NFS = 0x15,
  node_stat_item::NR_VMSCAN_WRITE = 0x16,
  node_stat_item::NR_VMSCAN_IMMEDIATE = 0x17,
  node_stat_item::NR_DIRTIED = 0x18,
  node_stat_item::NR_WRITTEN = 0x19,
  node_stat_item::NR_VM_NODE_STAT_ITEMS = 0x1A,
};

/* 488 */
enum zone_stat_item : __int32
{
  zone_stat_item::NR_FREE_PAGES = 0x0,
  zone_stat_item::NR_ZONE_LRU_BASE = 0x1,
  zone_stat_item::NR_ZONE_INACTIVE_ANON = 0x1,
  zone_stat_item::NR_ZONE_ACTIVE_ANON = 0x2,
  zone_stat_item::NR_ZONE_INACTIVE_FILE = 0x3,
  zone_stat_item::NR_ZONE_ACTIVE_FILE = 0x4,
  zone_stat_item::NR_ZONE_UNEVICTABLE = 0x5,
  zone_stat_item::NR_ZONE_WRITE_PENDING = 0x6,
  zone_stat_item::NR_MLOCK = 0x7,
  zone_stat_item::NR_SLAB_RECLAIMABLE = 0x8,
  zone_stat_item::NR_SLAB_UNRECLAIMABLE = 0x9,
  zone_stat_item::NR_PAGETABLE = 0xA,
  zone_stat_item::NR_KERNEL_STACK_KB = 0xB,
  zone_stat_item::NR_BOUNCE = 0xC,
  zone_stat_item::NR_FREE_CMA_PAGES = 0xD,
  zone_stat_item::NR_VM_ZONE_STAT_ITEMS = 0xE,
};

/* 489 */
enum pcpu_fc : __int32
{
  pcpu_fc::PCPU_FC_AUTO = 0x0,
  pcpu_fc::PCPU_FC_EMBED = 0x1,
  pcpu_fc::PCPU_FC_PAGE = 0x2,
  pcpu_fc::PCPU_FC_NR = 0x3,
};

/* 490 */
struct secondary_data
{
  void *stack;
  __int64 status;
};

/* 502 */
enum node_states : __int32
{
  node_states::N_POSSIBLE = 0x0,
  node_states::N_ONLINE = 0x1,
  node_states::N_NORMAL_MEMORY = 0x2,
  node_states::N_HIGH_MEMORY = 0x2,
  node_states::N_MEMORY = 0x2,
  node_states::N_CPU = 0x3,
  node_states::NR_NODE_STATES = 0x4,
};

/* 503 */
struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};

/* 504 */
struct arm64_ftr_reg
{
  const char *name;
  u64 strict_mask;
  u64 sys_val;
  const arm64_ftr_bits *ftr_bits;
};

/* 505 */
enum system_states : __int32
{
  system_states::SYSTEM_BOOTING = 0x0,
  system_states::SYSTEM_RUNNING = 0x1,
  system_states::SYSTEM_HALT = 0x2,
  system_states::SYSTEM_POWER_OFF = 0x3,
  system_states::SYSTEM_RESTART = 0x4,
};

/* 506 */
struct atomic_notifier_head
{
  spinlock_t lock;
  notifier_block *head;
};

/* 507 */
struct __attribute__((aligned(8))) miscdevice
{
  int minor;
  const char *name;
  const file_operations *fops;
  list_head list;
  device *parent;
  device *this_device;
  const attribute_group **groups;
  const char *nodename;
  umode_t mode;
};

/* 508 */
struct ratelimit_state
{
  raw_spinlock_t lock;
  int interval;
  int burst;
  int printed;
  int missed;
  unsigned __int64 begin;
  unsigned __int64 flags;
};

/* 511 */
struct inodes_stat_t
{
  __int64 nr_inodes;
  __int64 nr_unused;
  __int64 dummy[5];
};

/* 512 */
struct files_stat_struct
{
  unsigned __int64 nr_files;
  unsigned __int64 nr_free_files;
  unsigned __int64 max_files;
};

/* 515 */
struct dentry_stat_t
{
  __int64 nr_dentry;
  __int64 nr_unused;
  __int64 age_limit;
  __int64 want_pages;
  __int64 dummy[2];
};

/* 519 */
enum xen_domain_type : __int32
{
  xen_domain_type::XEN_NATIVE = 0x0,
  xen_domain_type::XEN_PV_DOMAIN = 0x1,
  xen_domain_type::XEN_HVM_DOMAIN = 0x2,
};

/* 520 */
struct vm_event_state
{
  unsigned __int64 event[64];
};

/* 521 */
struct tracepoint
{
  const char *name;
  static_key key;
  void (*regfunc)(void);
  void (*unregfunc)(void);
  tracepoint_func *funcs;
};

/* 522 */
struct page_ext_operations
{
  size_t offset;
  size_t size;
  bool (*need)(void);
  void (*init)(void);
};

/* 523 */
typedef kernfs_open_file kernfs_open_file_0;

/* 524 */
typedef vm_area_struct vm_area_struct_0;

/* 525 */
typedef mm_struct mm_struct_0;

/* 526 */
typedef module module_0;

/* 527 */
union __attribute__((aligned(8))) __n64
{
  unsigned __int64 n64_u64[1];
  unsigned __int32 n64_u32[2];
  unsigned __int16 n64_u16[4];
  unsigned __int8 n64_u8[8];
  __int64 n64_i64[1];
  __int32 n64_i32[2];
  __int16 n64_i16[4];
  __int8 n64_i8[8];
  float n64_f32[2];
  double n64_f64[1];
};

/* 528 */
union __attribute__((aligned(8))) __n128
{
  unsigned __int64 n128_u64[2];
  unsigned __int32 n128_u32[4];
  unsigned __int16 n128_u16[8];
  unsigned __int8 n128_u8[16];
  __int64 n128_i64[2];
  __int32 n128_i32[4];
  __int16 n128_i16[8];
  __int8 n128_i8[16];
  float n128_f32[4];
  double n128_f64[2];
};

/* 529 */
typedef __n64 int8x8_t;

/* 530 */
typedef __n64 uint8x8_t;

/* 531 */
typedef __n64 int16x4_t;

/* 532 */
typedef __n64 int32x2_t;

/* 533 */
typedef __n64 uint16x4_t;

/* 534 */
typedef __n64 uint32x2_t;

/* 535 */
typedef __n128 int8x16_t;

/* 536 */
typedef __n128 int16x8_t;

/* 537 */
typedef __n128 int32x4_t;

/* 538 */
typedef __n128 int64x2_t;

/* 539 */
typedef __n128 uint8x16_t;

/* 540 */
typedef __n128 uint16x8_t;

/* 541 */
typedef __n128 uint32x4_t;

/* 542 */
typedef __n128 uint64x2_t;

/* 543 */
typedef __n64 poly8x8_t;

/* 544 */
typedef __n64 poly16x4_t;

/* 545 */
typedef __n128 poly16x8_t;

/* 546 */
typedef __n128 poly8x16_t;

/* 547 */
typedef __n64 float16x4_t;

/* 548 */
typedef __n64 float32x2_t;

/* 549 */
typedef __n128 float16x8_t;

/* 550 */
typedef __n128 float32x4_t;

/* 551 */
typedef __n128 float64x2_t;

/* 552 */
typedef __n128 poly128_t;

/* 553 */
typedef int16x4_t int16x2_t;

/* 554 */
typedef uint16x4_t uint16x2_t;

/* 555 */
typedef float16x4_t float16x2_t;

/* 556 */
struct __va_list_tag
{
  void *__stack;
  void *__gr_top;
  void *__vr_top;
  int __gr_offs;
  int __vr_offs;
};

/* 557 */
typedef __va_list_tag gcc_va_list[1];

