;
; +-------------------------------------------------------------------------+
; |      This file was generated by The Interactive Disassembler (IDA)      |
; |           Copyright (c) 2025 Hex-Rays, <support@hex-rays.com>           |
; |                      License info: 48-2137-ACAB-99                      |
; |                              elf <elv@ven>                              |
; +-------------------------------------------------------------------------+
;
; Input SHA256 : 639DB7819B65F17EF997BC9A13B6A7914F0B44AA158FB6AEFFAFF18ED6F9A90E
; Input MD5    : 61D2EF34DCC2575F445B410FC3BBDBEA
; Input CRC32  : 5A354375
; Compiler     : GNU C++

; File Name   : /home/danielsokil/Lab/HashSource/hashsource_antminer_Ex/bitmain_firmware/_binaries/bitmain_axi.ko_639db7819b65f17e_debug
; Format      : ELF64 for ARM64 (Relocatable)
;
; Source File : 'bitmain_axi.c'
; Source File : 'bitmain_axi.mod.c'

; Processor       : ARM
; ARM architecture: metaarm
; Target assembler: Generic assembler for ARM
; Byte sex        : Little endian


; Segment type: Pure code
AREA .text, CODE, ALIGN=3
CODE64


; Attributes: static

; int __fastcall axi_fpga_dev_open(inode *inode, file *filp)
axi_fpga_dev_open
inode = X0              ; inode *
filp = X1               ; file *
MOV             W0, #0
RET
; End of function axi_fpga_dev_open



; Attributes: static info_from_lumina

; loff_t __fastcall axi_fpga_dev_llseek(file *filp, loff_t offset, int whence)
axi_fpga_dev_llseek
filp = X0               ; file *
whence = X2             ; int
newpos = X1             ; loff_t
CMP             W2, #1
B.EQ            loc_28
CMP             W2, #2
B.EQ            loc_48
CBZ             W2, loc_30

loc_1C
MOV             newpos, #0xFFFFFFFFFFFFFFEA
MOV             filp, newpos
RET

loc_28
filp = X0               ; file *
LDR             whence, [filp,#0x70]
ADD             newpos, newpos, X2

loc_30
whence = X2             ; int
MOV             whence, #0x8000000
CMP             newpos, X2
B.HI            loc_1C
STR             newpos, [filp,#0x70]
MOV             filp, newpos
RET

loc_48
filp = X0               ; file *
whence = X2             ; int
MOV             whence, #0x7FFFFFF
ADD             newpos, newpos, X2
B               loc_30
; End of function axi_fpga_dev_llseek

ALIGN 8


; Attributes: static bp-based frame info_from_lumina

; int __fastcall axi_fpga_dev_mmap(file *filp, vm_area_struct *vma)
axi_fpga_dev_mmap

var_s0=  0

filp = X0               ; file *
vma = X1                ; vm_area_struct *
STP             X29, X30, [SP,#-0x10+var_s0]!
MOV             X9, #0xFFFFFFFFFFFFFFE3
MOV             X8, #0x4000
MOVK            X9, #0xFF9F,LSL#48
MOV             X29, SP
LDP             X4, X5, [vma,#0x48]
MOVK            X8, #0x404,LSL#16
LDR             X7, [vma]
MOV             X3, #0x1000
LDR             X6, [vma,#0x98]
AND             X4, X4, X9
ORR             X5, X5, X8
ORR             X4, X4, #0x60000000000000
STP             X4, X5, [vma,#0x48]
MOV             X2, #0x80000
MOV             filp, vma
ADD             vma, X7, X6
BL              remap_pfn_range
LDP             X29, X30, [SP+var_s0],#0x10
RET
; End of function axi_fpga_dev_mmap



; Attributes: static info_from_lumina

; ssize_t __fastcall axi_fpga_dev_read(file *f, char *buf, size_t len, loff_t *ppos)
axi_fpga_dev_read

var_20= -0x20
var_10= -0x10

f = X0                  ; file *
buf = X1                ; char *
len = X2                ; size_t
ppos = X3               ; loff_t *
LDR             X5, [ppos]
pos = X5                ; loff_t
CMP             buf, #0
MOV             f, #0x7FFFFFF
CCMP            pos, X0, #2, NE
B.HI            loc_150
STP             X29, X30, [SP,#var_20]!
MOV             X4, buf
MRS             X0, SP_EL0
MOV             X29, SP
STR             X19, [SP,#0x20+var_10]
MOV             X19, #0x8000000
SUB             X19, X19, pos
CMP             X19, len
LDR             X0, [X0,#8]
CSEL            X19, X19, len, LS
len = X19               ; size_t
ADDS            X4, X4, len
CCMP            X4, X0, #2, CC
CSET            X2, LS
CBNZ            X2, loc_104

loc_F4
MOV             X0, #0xFFFFFFFFFFFFFFF2
LDR             len, [SP,#0x20+var_10]
LDP             X29, X30, [SP+0x20+var_20],#0x20
RET

loc_104
len = X19               ; size_t
MOV             X0, buf
LDR             buf, =fpga_cache_store_addr
buf = X0                ; char *
STR             X20, [X29,#0x18]
MOV             X2, len
MOV             X20, ppos
LDR             X1, [X1]
ADD             X1, X1, pos
BL              __arch_copy_to_user
CMP             X0, len
B.EQ            loc_158
LDR             X1, [ppos]
SUB             len, len, X0
MOV             X0, len
ADD             len, X1, len
STR             X19, [ppos]
LDR             ppos, [X29,#0x18]
LDR             X19, [SP,#0x20+var_10]
LDP             X29, X30, [SP+0x20+var_20],#0x20
RET

loc_150
buf = X1                ; char *
len = X2                ; size_t
ppos = X3               ; loff_t *
pos = X5                ; loff_t
MOV             X0, #0xFFFFFFFFFFFFFFEA
RET

loc_158
len = X19               ; size_t
ppos = X20              ; loff_t *
LDR             ppos, [X29,#0x18]
B               loc_F4
; End of function axi_fpga_dev_read

off_160 DCQ fpga_cache_store_addr



; __int64 axi_fpga_dev_release()
axi_fpga_dev_release
MOV             W0, #0
RET
; End of function axi_fpga_dev_release

; .text ends


; Segment type: Pure code
AREA .init.text, CODE, ALIGN=3
; ORG 0x170
CODE64


; Alternative name is 'init_module'
; Attributes: static bp-based frame info_from_lumina

; int __cdecl axi_fpga_dev_init()
EXPORT axi_fpga_dev_init
axi_fpga_dev_init

var_s0=  0
var_s10=  0x10
var_s20=  0x20

ret = X20               ; int
STP             X29, X30, [SP,#-0x30+var_s0]!
MOV             X29, SP
STP             X21, X22, [SP,#var_s20]
LDR             X22, =axi_fpga_misc_dev
STP             X19, ret, [SP,#var_s10]
MOV             X0, X22
BL              misc_register
LDR             X19, =aAxiFpgaDev ; "axi_fpga_dev"
MOV             W20, W0
TBZ             W0, #0x1F, loc_1A8
LDR             X0, =unk_410
MOV             X1, X19
BL              printk
B               loc_21C

loc_1A8
MOV             X2, #1
MOV             X1, #0x8000000
MOV             X0, #0x38000000
BL              memremap
LDR             X21, =fpga_cache_store_addr
STR             X0, [X21]
CBNZ            X0, loc_1DC
LDR             X0, =unk_440
MOV             X1, X19
BL              printk
MOV             X0, X22
BL              misc_deregister
B               loc_21C

loc_1DC
MOV             X2, #0x8000000
MOV             W1, #0
BL              __memset_io
MOV             W20, #0
LDR             X2, [X21]
MOV             X1, X19
LDR             X0, =unk_470
BL              printk
LDR             X0, =unk_4A0
MOV             X2, #0x38000000
MOV             X1, X19
BL              printk
LDR             X0, =unk_4D0
MOV             X2, #0x8000000
MOV             X1, X19
BL              printk

loc_21C
MOV             W0, W20
LDP             X19, ret, [SP,#var_s10]
LDP             X21, X22, [SP,#var_s20]
LDP             X29, X30, [SP+var_s0],#0x30
RET
; End of function axi_fpga_dev_init

off_230 DCQ axi_fpga_misc_dev
off_238 DCQ aAxiFpgaDev ; "axi_fpga_dev"
off_240 DCQ unk_410
off_248 DCQ fpga_cache_store_addr
off_250 DCQ unk_440
off_258 DCQ unk_470
off_260 DCQ unk_4A0
off_268 DCQ unk_4D0
; .init.text ends


; Segment type: Pure code
AREA .exit.text, CODE, ALIGN=3
; ORG 0x270
CODE64


; Alternative name is 'cleanup_module'
; Attributes: static bp-based frame info_from_lumina

; void __cdecl axi_fpga_dev_exit()
EXPORT axi_fpga_dev_exit
axi_fpga_dev_exit

var_s0=  0

STP             X29, X30, [SP,#-0x10+var_s0]!
MOV             X29, SP
LDR             X0, =axi_fpga_misc_dev
BL              misc_deregister
LDR             X0, =fpga_cache_store_addr
LDR             X0, [X0]
BL              memunmap
LDP             X29, X30, [SP+var_s0],#0x10
RET
; End of function axi_fpga_dev_exit

ALIGN 8
off_298 DCQ axi_fpga_misc_dev
off_2A0 DCQ fpga_cache_store_addr
; .exit.text ends


; Segment type: Pure data
AREA .rodata, DATA, READONLY, ALIGN=3
; ORG 0x2A8
; const file_operations axi_fpga_dev_fops
axi_fpga_dev_fops file_operations <__this_module, \
                 axi_fpga_dev_llseek, \
                 axi_fpga_dev_read, 0, \
                 0, 0, 0, 0, 0, 0, 0, \
                 axi_fpga_dev_mmap, 0, \
                 0, \
                 axi_fpga_dev_release, \
                 0, 0, 0, 0, 0, 0, 0, 0,\
                 0, 0, 0, 0, 0, 0, 0>
; .rodata ends


; Segment type: Pure data
AREA .modinfo, DATA, READONLY, ALIGN=3
; ORG 0x398
; const char _UNIQUE_ID_license16[21]
__UNIQUE_ID_license16 DCB "license=Dual BSD/GPL",0
ALIGN 0x10
; const char _module_depends[9]
__module_depends DCB "depends=",0
; const char _UNIQUE_ID_vermagic8[67]
__UNIQUE_ID_vermagic8 DCB "vermagic=4.9.0-xilinx-v2019.1-g118"
DCB "8a5d74531 SMP mod_unload aarch64",0
; .modinfo ends


; Segment type: Pure data
AREA .rodata.str1.8, DATA, READONLY, ALIGN=3
; ORG 0x400
aAxiFpgaDev DCB "axi_fpga_dev",0
ALIGN 0x10
unk_410 DCB    1
DCB 0x33 ; 3
DCB 0x25 ; %
DCB 0x73 ; s
DCB 0x3A ; :
DCB 0x20
DCB 0x65 ; e
DCB 0x72 ; r
DCB 0x72 ; r
DCB 0x6F ; o
DCB 0x72 ; r
DCB 0x21 ; !
DCB 0x20
DCB 0x66 ; f
DCB 0x61 ; a
DCB 0x69 ; i
DCB 0x6C ; l
DCB 0x65 ; e
DCB 0x64 ; d
DCB 0x20
DCB 0x74 ; t
DCB 0x6F ; o
DCB 0x20
DCB 0x72 ; r
DCB 0x65 ; e
DCB 0x67 ; g
DCB 0x69 ; i
DCB 0x73 ; s
DCB 0x74 ; t
DCB 0x20
DCB 0x6D ; m
DCB 0x69 ; i
DCB 0x73 ; s
DCB 0x63 ; c
DCB 0x20
DCB 0x64 ; d
DCB 0x65 ; e
DCB 0x76 ; v
DCB 0x2E ; .
DCB  0xA
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
DCB    0
unk_440 DCB    1
DCB 0x33 ; 3
DCB 0x25 ; %
DCB 0x73 ; s
DCB 0x3A ; :
DCB 0x20
DCB 0x65 ; e
DCB 0x72 ; r
DCB 0x72 ; r
DCB 0x6F ; o
DCB 0x72 ; r
DCB 0x21 ; !
DCB 0x20
DCB 0x66 ; f
DCB 0x61 ; a
DCB 0x69 ; i
DCB 0x6C ; l
DCB 0x65 ; e
DCB 0x64 ; d
DCB 0x20
DCB 0x74 ; t
DCB 0x6F ; o
DCB 0x20
DCB 0x72 ; r
DCB 0x65 ; e
DCB 0x6D ; m
DCB 0x61 ; a
DCB 0x70 ; p
DCB 0x20
DCB 0x72 ; r
DCB 0x65 ; e
DCB 0x73 ; s
DCB 0x65 ; e
DCB 0x72 ; r
DCB 0x76 ; v
DCB 0x65 ; e
DCB 0x64 ; d
DCB 0x20
DCB 0x6D ; m
DCB 0x65 ; e
DCB 0x6D ; m
DCB 0x6F ; o
DCB 0x72 ; r
DCB 0x79 ; y
DCB 0x2E ; .
DCB  0xA
DCB    0
DCB    0
unk_470 DCB    1
DCB 0x36 ; 6
DCB 0x25 ; %
DCB 0x73 ; s
DCB 0x3A ; :
DCB 0x20
DCB 0x61 ; a
DCB 0x6C ; l
DCB 0x6C ; l
DCB 0x6F ; o
DCB 0x63 ; c
DCB 0x20
DCB 0x72 ; r
DCB 0x73 ; s
DCB 0x76 ; v
DCB 0x64 ; d
DCB 0x20
DCB 0x6D ; m
DCB 0x65 ; e
DCB 0x6D ; m
DCB 0x2C ; ,
DCB 0x20
DCB 0x20
DCB 0x76 ; v
DCB 0x69 ; i
DCB 0x72 ; r
DCB 0x74 ; t
DCB 0x20
DCB 0x61 ; a
DCB 0x64 ; d
DCB 0x64 ; d
DCB 0x72 ; r
DCB 0x3A ; :
DCB 0x20
DCB 0x30 ; 0
DCB 0x78 ; x
DCB 0x25 ; %
DCB 0x30 ; 0
DCB 0x31 ; 1
DCB 0x36 ; 6
DCB 0x6C ; l
DCB 0x6C ; l
DCB 0x58 ; X
DCB  0xA
DCB    0
DCB    0
DCB    0
DCB    0
unk_4A0 DCB    1
DCB 0x36 ; 6
DCB 0x25 ; %
DCB 0x73 ; s
DCB 0x3A ; :
DCB 0x20
DCB 0x61 ; a
DCB 0x6C ; l
DCB 0x6C ; l
DCB 0x6F ; o
DCB 0x63 ; c
DCB 0x20
DCB 0x72 ; r
DCB 0x73 ; s
DCB 0x76 ; v
DCB 0x64 ; d
DCB 0x20
DCB 0x6D ; m
DCB 0x65 ; e
DCB 0x6D ; m
DCB 0x2C ; ,
DCB 0x20
DCB 0x20
DCB 0x70 ; p
DCB 0x68 ; h
DCB 0x79 ; y
DCB 0x73 ; s
DCB 0x20
DCB 0x61 ; a
DCB 0x64 ; d
DCB 0x64 ; d
DCB 0x72 ; r
DCB 0x3A ; :
DCB 0x20
DCB 0x30 ; 0
DCB 0x78 ; x
DCB 0x25 ; %
DCB 0x30 ; 0
DCB 0x31 ; 1
DCB 0x36 ; 6
DCB 0x6C ; l
DCB 0x6C ; l
DCB 0x58 ; X
DCB  0xA
DCB    0
DCB    0
DCB    0
DCB    0
unk_4D0 DCB    1
DCB 0x36 ; 6
DCB 0x25 ; %
DCB 0x73 ; s
DCB 0x3A ; :
DCB 0x20
DCB 0x61 ; a
DCB 0x6C ; l
DCB 0x6C ; l
DCB 0x6F ; o
DCB 0x63 ; c
DCB 0x20
DCB 0x72 ; r
DCB 0x73 ; s
DCB 0x76 ; v
DCB 0x64 ; d
DCB 0x20
DCB 0x6D ; m
DCB 0x65 ; e
DCB 0x6D ; m
DCB 0x2C ; ,
DCB 0x20
DCB 0x74 ; t
DCB 0x6F ; o
DCB 0x74 ; t
DCB 0x61 ; a
DCB 0x6C ; l
DCB 0x20
DCB 0x73 ; s
DCB 0x69 ; i
DCB 0x7A ; z
DCB 0x65 ; e
DCB 0x3A ; :
DCB 0x20
DCB 0x30 ; 0
DCB 0x78 ; x
DCB 0x25 ; %
DCB 0x30 ; 0
DCB 0x31 ; 1
DCB 0x36 ; 6
DCB 0x6C ; l
DCB 0x6C ; l
DCB 0x58 ; X
DCB  0xA
DCB    0
; .rodata.str1.8 ends


; Segment type: Pure data
AREA .data, DATA, ALIGN=3
; ORG 0x500
; miscdevice axi_fpga_misc_dev
axi_fpga_misc_dev miscdevice <0, aAxiFpgaDev, \ ; "axi_fpga_dev"
            axi_fpga_dev_fops, <0>, 0, \
            0, 0, 0, 0>
; .data ends


; Segment type: Pure data
AREA .gnu.linkonce.this_module, DATA, ALIGN=0
; ORG 0x580
EXPORT __this_module
; module _this_module
__this_module module <module_state::MODULE_STATE_LIVE,\
        <0>, <0x62, 0x69, 0x74, 0x6D, \
        0x61, 0x69, 0x6E, 0x5F, 0x61, \
        0x78, 0x69, 0, 0, 0, 0, 0, 0, 0, \
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
        0, 0, 0, 0, 0>, <0>, 0, 0, 0, 0,\
        0, 0, 0, <0>, 0, 0, 0, 0, 0, 0, \
        0, 0, 0, 0, 0, \
        axi_fpga_dev_init, <0>, <0>, 0, \
        0, <0>, 0, 0, <0>, 0, 0, 0, 0, \
        0, <0>, <0>, axi_fpga_dev_exit, <\
        0>>
; .gnu.linkonce.this_module ends


; Segment type: Uninitialized
AREA .bss, DATA, ALIGN=3
; ORG 0x880
EXPORT fpga_cache_store_addr
; void *fpga_cache_store_addr
fpga_cache_store_addr % 8
; .bss ends


; Segment type: Externs
; __int64 __fastcall misc_deregister(_QWORD)
IMPORT misc_deregister
; int __fastcall remap_pfn_range(_QWORD, _QWORD, _QWORD, _QWORD)
IMPORT remap_pfn_range
; __int64 __fastcall memremap(_QWORD, _QWORD, _QWORD)
IMPORT memremap
; __int64 __fastcall _arch_copy_to_user(_QWORD, _QWORD, _QWORD)
IMPORT __arch_copy_to_user
; __int64 __fastcall memunmap(_QWORD)
IMPORT memunmap
; __int64 __fastcall _memset_io(_QWORD, _QWORD, _QWORD)
IMPORT __memset_io
; __int64 __fastcall printk(_QWORD, _QWORD, _QWORD)
IMPORT printk
; __int64 __fastcall misc_register(_QWORD)
IMPORT misc_register

END
