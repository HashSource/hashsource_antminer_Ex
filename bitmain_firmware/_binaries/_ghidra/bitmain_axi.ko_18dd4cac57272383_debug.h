// Data types exported from: bitmain_axi.ko_18dd4cac57272383_debug
// Generated by Ghidra

#ifndef BITMAIN_AXI_KO_18DD4CAC57272383_DEBUG_TYPES_H
#define BITMAIN_AXI_KO_18DD4CAC57272383_DEBUG_TYPES_H

#include <stdint.h>
#include <stdbool.h>

/* ==================== Enumerations ==================== */

typedef enum {
    SHT_NULL = 0,
    SHT_PROGBITS = 1,
    SHT_SYMTAB = 2,
    SHT_STRTAB = 3,
    SHT_RELA = 4,
    SHT_HASH = 5,
    SHT_DYNAMIC = 6,
    SHT_NOTE = 7,
    SHT_NOBITS = 8,
    SHT_REL = 9,
    SHT_SHLIB = 10,
    SHT_DYNSYM = 11,
    SHT_INIT_ARRAY = 14,
    SHT_FINI_ARRAY = 15,
    SHT_PREINIT_ARRAY = 16,
    SHT_GROUP = 17,
    SHT_SYMTAB_SHNDX = 18,
    SHT_ANDROID_REL = 1610612737,
    SHT_ANDROID_RELA = 1610612738,
    SHT_GNU_ATTRIBUTES = 1879048181,
    SHT_GNU_HASH = 1879048182,
    SHT_GNU_LIBLIST = 1879048183,
    SHT_CHECKSUM = 1879048184,
    SHT_SUNW_move = 1879048186,
    SHT_SUNW_COMDAT = 1879048187,
    SHT_SUNW_syminfo = 1879048188,
    SHT_GNU_verdef = 1879048189,
    SHT_GNU_verneed = 1879048190,
    SHT_GNU_versym = 1879048191,
    SHT_AARCH64_ATTRIBUTES = 1879048195,
} Elf_SectionHeaderType_AARCH64;

typedef enum {
    MIGRATE_UNMOVABLE = 0,
    MM_FILEPAGES = 0,
    ZONELIST_FALLBACK = 0,
    false = 0,
    MAX_ZONELISTS = 1,
    MEMREMAP_WB = 1,
    MIGRATE_MOVABLE = 1,
    MM_ANONPAGES = 1,
    true = 1,
    MEMREMAP_WT = 2,
    MIGRATE_RECLAIMABLE = 2,
    MM_SWAPENTS = 2,
    MIGRATE_HIGHATOMIC = 3,
    MIGRATE_PCPTYPES = 3,
    MM_SHMEMPAGES = 3,
    MEMREMAP_WC = 4,
    MIGRATE_CMA = 4,
    NR_MM_COUNTERS = 4,
    MIGRATE_ISOLATE = 5,
    MIGRATE_TYPES = 6,
    UNAME26 = 131072,
    ADDR_NO_RANDOMIZE = 262144,
    FDPIC_FUNCPTRS = 524288,
    MMAP_PAGE_ZERO = 1048576,
    ADDR_COMPAT_LAYOUT = 2097152,
    READ_IMPLIES_EXEC = 4194304,
    ADDR_LIMIT_32BIT = 8388608,
    SHORT_INODE = 16777216,
    WHOLE_SECONDS = 33554432,
    STICKY_TIMEOUTS = 67108864,
    ADDR_LIMIT_3GB = 134217728,
} anon_enum_32;

typedef enum {
    CGROUP_SUBSYS_COUNT = 0,
} cgroup_subsys_id;

typedef enum {
    FTR_EXACT = 0,
    FTR_LOWER_SAFE = 1,
    FTR_HIGHER_SAFE = 2,
} ftr_type;

typedef enum {
    HRTIMER_BASE_MONOTONIC = 0,
    HRTIMER_BASE_REALTIME = 1,
    HRTIMER_BASE_BOOTTIME = 2,
    HRTIMER_BASE_TAI = 3,
    HRTIMER_MAX_CLOCK_BASES = 4,
} hrtimer_base_type;

typedef enum {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1,
} hrtimer_restart;

typedef enum {
    KOBJ_NS_TYPE_NONE = 0,
    KOBJ_NS_TYPE_NET = 1,
    KOBJ_NS_TYPES = 2,
} kobj_ns_type;

typedef enum {
    LRU_INACTIVE_ANON = 0,
    LRU_ACTIVE_ANON = 1,
    LRU_INACTIVE_FILE = 2,
    LRU_ACTIVE_FILE = 3,
    LRU_UNEVICTABLE = 4,
    NR_LRU_LISTS = 5,
} lru_list;

typedef enum {
    MIGRATE_ASYNC = 0,
    MIGRATE_SYNC_LIGHT = 1,
    MIGRATE_SYNC = 2,
} migrate_mode;

typedef enum {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2,
    MODULE_STATE_UNFORMED = 3,
} module_state;

typedef enum {
    NR_INACTIVE_ANON = 0,
    NR_LRU_BASE = 0,
    NR_ACTIVE_ANON = 1,
    NR_INACTIVE_FILE = 2,
    NR_ACTIVE_FILE = 3,
    NR_UNEVICTABLE = 4,
    NR_ISOLATED_ANON = 5,
    NR_ISOLATED_FILE = 6,
    NR_PAGES_SCANNED = 7,
    WORKINGSET_REFAULT = 8,
    WORKINGSET_ACTIVATE = 9,
    WORKINGSET_NODERECLAIM = 10,
    NR_ANON_MAPPED = 11,
    NR_FILE_MAPPED = 12,
    NR_FILE_PAGES = 13,
    NR_FILE_DIRTY = 14,
    NR_WRITEBACK = 15,
    NR_WRITEBACK_TEMP = 16,
    NR_SHMEM = 17,
    NR_SHMEM_THPS = 18,
    NR_SHMEM_PMDMAPPED = 19,
    NR_ANON_THPS = 20,
    NR_UNSTABLE_NFS = 21,
    NR_VMSCAN_WRITE = 22,
    NR_VMSCAN_IMMEDIATE = 23,
    NR_DIRTIED = 24,
    NR_WRITTEN = 25,
    NR_VM_NODE_STAT_ITEMS = 26,
} node_stat_item;

typedef enum {
    N_POSSIBLE = 0,
    N_ONLINE = 1,
    N_HIGH_MEMORY = 2,
    N_MEMORY = 2,
    N_NORMAL_MEMORY = 2,
    N_CPU = 3,
    NR_NODE_STATES = 4,
} node_states;

typedef enum {
    PCPU_FC_AUTO = 0,
    PCPU_FC_EMBED = 1,
    PCPU_FC_PAGE = 2,
    PCPU_FC_NR = 3,
} pcpu_fc;

typedef enum {
    perf_invalid_context = -1,
    perf_hw_context = 0,
    perf_sw_context = 1,
    perf_nr_task_contexts = 2,
} perf_event_task_context;

typedef enum {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3,
} pid_type;

typedef enum {
    PROBE_DEFAULT_STRATEGY = 0,
    PROBE_PREFER_ASYNCHRONOUS = 1,
    PROBE_FORCE_SYNCHRONOUS = 2,
} probe_type;

typedef enum {
    USRQUOTA = 0,
    GRPQUOTA = 1,
    PRJQUOTA = 2,
} quota_type;

typedef enum {
    RCU_SYNC = 0,
    RCU_SCHED_SYNC = 1,
    RCU_BH_SYNC = 2,
} rcu_sync_type;

typedef enum {
    RPM_REQ_NONE = 0,
    RPM_REQ_IDLE = 1,
    RPM_REQ_SUSPEND = 2,
    RPM_REQ_AUTOSUSPEND = 3,
    RPM_REQ_RESUME = 4,
} rpm_request;

typedef enum {
    RPM_ACTIVE = 0,
    RPM_RESUMING = 1,
    RPM_SUSPENDED = 2,
    RPM_SUSPENDING = 3,
} rpm_status;

typedef enum {
    SYSTEM_BOOTING = 0,
    SYSTEM_RUNNING = 1,
    SYSTEM_HALT = 2,
    SYSTEM_POWER_OFF = 3,
    SYSTEM_RESTART = 4,
} system_states;

typedef enum {
    XEN_NATIVE = 0,
    XEN_PV_DOMAIN = 1,
    XEN_HVM_DOMAIN = 2,
} xen_domain_type;

typedef enum {
    NR_FREE_PAGES = 0,
    NR_ZONE_INACTIVE_ANON = 1,
    NR_ZONE_LRU_BASE = 1,
    NR_ZONE_ACTIVE_ANON = 2,
    NR_ZONE_INACTIVE_FILE = 3,
    NR_ZONE_ACTIVE_FILE = 4,
    NR_ZONE_UNEVICTABLE = 5,
    NR_ZONE_WRITE_PENDING = 6,
    NR_MLOCK = 7,
    NR_SLAB_RECLAIMABLE = 8,
    NR_SLAB_UNRECLAIMABLE = 9,
    NR_PAGETABLE = 10,
    NR_KERNEL_STACK_KB = 11,
    NR_BOUNCE = 12,
    NR_FREE_CMA_PAGES = 13,
    NR_VM_ZONE_STAT_ITEMS = 14,
} zone_stat_item;

typedef enum {
    ZONE_DMA = 0,
    ZONE_NORMAL = 1,
    ZONE_MOVABLE = 2,
    __MAX_NR_ZONES = 3,
} zone_type;

typedef enum {
    WMARK_MIN = 0,
    WMARK_LOW = 1,
    WMARK_HIGH = 2,
    NR_WMARK = 3,
} zone_watermarks;

/* ==================== Forward Declarations ==================== */

typedef struct Elf64_Dyn Elf64_Dyn;
typedef struct Elf64_Ehdr Elf64_Ehdr;
typedef struct Elf64_Rela Elf64_Rela;
typedef struct Elf64_Shdr Elf64_Shdr;
typedef struct Elf64_Sym Elf64_Sym;
typedef struct GnuBuildId GnuBuildId;
typedef struct __wait_queue_head __wait_queue_head;
typedef struct acpi_device_id acpi_device_id;
typedef struct address_space address_space;
typedef struct address_space_operations address_space_operations;
typedef struct anon_struct_16_2_036100f2_for__sigpoll anon_struct_16_2_036100f2_for__sigpoll;
typedef struct anon_struct_16_2_1ccaa948_for_domU anon_struct_16_2_1ccaa948_for_domU;
typedef struct anon_struct_16_2_6c587c7a_for__addr_bnd anon_struct_16_2_6c587c7a_for__addr_bnd;
typedef struct anon_struct_16_2_bf2d6ad5_for_anon_union_16_2_0496ad32_for_radix_tree_node_3_0 anon_struct_16_2_bf2d6ad5_for_anon_union_16_2_0496ad32_for_radix_tree_node_3_0;
typedef struct anon_struct_16_2_c793ed0d_for_anon_union_24_2_a31149a9_for_key_14_1 anon_struct_16_2_c793ed0d_for_anon_union_24_2_a31149a9_for_key_14_1;
typedef struct anon_struct_16_3_1ec73fca_for_anon_union_16_5_86b83ece_for_page_4_4 anon_struct_16_3_1ec73fca_for_anon_union_16_5_86b83ece_for_page_4_4;
typedef struct anon_struct_16_3_349d2ff7_for__sigsys anon_struct_16_3_349d2ff7_for__sigsys;
typedef struct anon_struct_16_3_55e3d276_for__rt anon_struct_16_3_55e3d276_for__rt;
typedef struct anon_struct_16_3_a99975b4_for_anon_union_16_5_86b83ece_for_page_4_2 anon_struct_16_3_a99975b4_for_anon_union_16_5_86b83ece_for_page_4_2;
typedef struct anon_struct_24_2_b8c32279_for_afs anon_struct_24_2_b8c32279_for_afs;
typedef struct anon_struct_24_5_a9d2e8e0_for__timer anon_struct_24_5_a9d2e8e0_for__timer;
typedef struct anon_struct_32_2_435e3c06_for_anon_union_32_3_ecfb39e2_for_key_15_1 anon_struct_32_2_435e3c06_for_anon_union_32_3_ecfb39e2_for_key_15_1;
typedef struct anon_struct_32_2_b72ec8c0_for_shared anon_struct_32_2_b72ec8c0_for_shared;
typedef struct anon_struct_32_3_83228368_for__sigfault anon_struct_32_3_83228368_for__sigfault;
typedef struct anon_struct_32_4_3561e44d_for_nanosleep anon_struct_32_4_3561e44d_for_nanosleep;
typedef struct anon_struct_32_5_1063e6a4_for_poll anon_struct_32_5_1063e6a4_for_poll;
typedef struct anon_struct_32_5_ac353c0e_for__sigchld anon_struct_32_5_ac353c0e_for__sigchld;
typedef struct anon_struct_40_6_daaf18c6_for_futex anon_struct_40_6_daaf18c6_for_futex;
typedef struct anon_struct_4_3_197f4b50_for_anon_union_4_4_c461a3d3_for_anon_struct_8_2_00f704d7_for_anon_union_8_2_8f55150c_for_page_3_1_0_2 anon_struct_4_3_197f4b50_for_anon_union_4_4_c461a3d3_for_anon_struct_8_2_00f704d7_for_anon_union_8_2_8f55150c_for_page_3_1_0_2;
typedef struct anon_struct_528_3_de587f01_for_anon_union_528_2_afce2d22_for_fpsimd_state_0_1 anon_struct_528_3_de587f01_for_anon_union_528_2_afce2d22_for_fpsimd_state_0_1;
typedef struct anon_struct_8_2_00f704d7_for_anon_union_8_2_8f55150c_for_page_3_1 anon_struct_8_2_00f704d7_for_anon_union_8_2_8f55150c_for_page_3_1;
typedef struct anon_struct_8_2_1193de1b_for_dom0 anon_struct_8_2_1193de1b_for_dom0;
typedef struct anon_struct_8_2_239a000b_for_anon_union_8_2_a3c87c50_for_lockref_0_1 anon_struct_8_2_239a000b_for_anon_union_8_2_a3c87c50_for_lockref_0_1;
typedef struct anon_struct_8_2_37e52e62_for__kill anon_struct_8_2_37e52e62_for__kill;
typedef struct anon_struct_8_2_62570ece_for_anon_union_8_2_ae5c065a_for_qstr_0_0 anon_struct_8_2_62570ece_for_anon_union_8_2_ae5c065a_for_qstr_0_0;
typedef struct anon_vma anon_vma;
typedef struct arch_rwlock_t arch_rwlock_t;
typedef struct arch_shared_info arch_shared_info;
typedef struct arch_spinlock_t arch_spinlock_t;
typedef struct arch_vcpu_info arch_vcpu_info;
typedef struct arm64_ftr_bits arm64_ftr_bits;
typedef struct arm64_ftr_reg arm64_ftr_reg;
typedef struct assoc_array assoc_array;
typedef struct assoc_array_ptr assoc_array_ptr;
typedef struct atomic64_t atomic64_t;
typedef struct atomic_notifier_head atomic_notifier_head;
typedef struct atomic_t atomic_t;
typedef struct attribute attribute;
typedef struct attribute_group attribute_group;
typedef struct audit_context audit_context;
typedef struct backing_dev_info backing_dev_info;
typedef struct bin_attribute bin_attribute;
typedef struct bio_list bio_list;
typedef struct blk_plug blk_plug;
typedef struct block_device block_device;
typedef struct blocking_notifier_head blocking_notifier_head;
typedef struct bug_entry bug_entry;
typedef struct bus_type bus_type;
typedef struct callback_head callback_head;
typedef struct cdev cdev;
typedef struct cftype cftype;
typedef struct cgroup cgroup;
typedef struct cgroup_file cgroup_file;
typedef struct cgroup_root cgroup_root;
typedef struct cgroup_subsys cgroup_subsys;
typedef struct cgroup_subsys_state cgroup_subsys_state;
typedef struct cgroup_taskset cgroup_taskset;
typedef struct class class;
typedef struct class_attribute class_attribute;
typedef struct cma cma;
typedef struct compat_robust_list_head compat_robust_list_head;
typedef struct compat_timespec compat_timespec;
typedef struct completion completion;
typedef struct core_state core_state;
typedef struct core_thread core_thread;
typedef struct cpu_context cpu_context;
typedef struct cpu_itimer cpu_itimer;
typedef struct cpu_topology cpu_topology;
typedef struct cpumask cpumask;
typedef struct cred cred;
typedef struct css_set css_set;
typedef struct ctl_table ctl_table;
typedef struct ctl_table_poll ctl_table_poll;
typedef struct debug_info debug_info;
typedef struct delayed_call delayed_call;
typedef struct dentry dentry;
typedef struct dentry_operations dentry_operations;
typedef struct dentry_stat_t dentry_stat_t;
typedef struct dev_archdata dev_archdata;
typedef struct dev_pagemap dev_pagemap;
typedef struct dev_pin_info dev_pin_info;
typedef struct dev_pm_domain dev_pm_domain;
typedef struct dev_pm_info dev_pm_info;
typedef struct dev_pm_ops dev_pm_ops;
typedef struct dev_pm_qos dev_pm_qos;
typedef struct device device;
typedef struct device_attribute device_attribute;
typedef struct device_dma_parameters device_dma_parameters;
typedef struct device_driver device_driver;
typedef struct device_node device_node;
typedef struct device_private device_private;
typedef struct device_type device_type;
typedef struct dir_context dir_context;
typedef struct dma_coherent_mem dma_coherent_mem;
typedef struct dma_map_ops dma_map_ops;
typedef struct dqstats dqstats;
typedef struct dquot dquot;
typedef struct dquot_operations dquot_operations;
typedef struct driver_private driver_private;
typedef struct elf64_sym elf64_sym;
typedef struct exception_table_entry exception_table_entry;
typedef struct export_operations export_operations;
typedef struct fasync_struct fasync_struct;
typedef struct fault_env fault_env;
typedef struct fiemap_extent fiemap_extent;
typedef struct fiemap_extent_info fiemap_extent_info;
typedef struct file file;
typedef struct file_lock file_lock;
typedef struct file_lock_context file_lock_context;
typedef struct file_lock_operations file_lock_operations;
typedef struct file_operations file_operations;
typedef struct file_ra_state file_ra_state;
typedef struct file_system_type file_system_type;
typedef struct files_stat_struct files_stat_struct;
typedef struct files_struct files_struct;
typedef struct fown_struct fown_struct;
typedef struct fpsimd_state fpsimd_state;
typedef struct free_area free_area;
typedef struct fs_struct fs_struct;
typedef struct fscrypt_operations fscrypt_operations;
typedef struct futex_pi_state futex_pi_state;
typedef struct fwnode_handle fwnode_handle;
typedef struct gendisk gendisk;
typedef struct group_info group_info;
typedef struct hd_struct hd_struct;
typedef struct hlist_bl_head hlist_bl_head;
typedef struct hlist_bl_node hlist_bl_node;
typedef struct hlist_head hlist_head;
typedef struct hlist_node hlist_node;
typedef struct hrtimer hrtimer;
typedef struct hrtimer_clock_base hrtimer_clock_base;
typedef struct hrtimer_cpu_base hrtimer_cpu_base;
typedef struct iattr iattr;
typedef struct ida ida;
typedef struct ida_bitmap ida_bitmap;
typedef struct idr idr;
typedef struct idr_layer idr_layer;
typedef struct inode inode;
typedef struct inode_operations inode_operations;
typedef struct inodes_stat_t inodes_stat_t;
typedef struct io_context io_context;
typedef struct iommu_fwspec iommu_fwspec;
typedef struct iommu_group iommu_group;
typedef struct iommu_ops iommu_ops;
typedef struct iov_iter iov_iter;
typedef struct k_sigaction k_sigaction;
typedef struct kernel_cap_struct kernel_cap_struct;
typedef struct kernel_param kernel_param;
typedef struct kernel_param_ops kernel_param_ops;
typedef struct kernel_symbol kernel_symbol;
typedef struct kernfs_elem_attr kernfs_elem_attr;
typedef struct kernfs_elem_dir kernfs_elem_dir;
typedef struct kernfs_elem_symlink kernfs_elem_symlink;
typedef struct kernfs_iattrs kernfs_iattrs;
typedef struct kernfs_node kernfs_node;
typedef struct kernfs_open_file kernfs_open_file;
typedef struct kernfs_open_node kernfs_open_node;
typedef struct kernfs_ops kernfs_ops;
typedef struct kernfs_root kernfs_root;
typedef struct kernfs_syscall_ops kernfs_syscall_ops;
typedef struct key key;
typedef struct key_type key_type;
typedef struct key_user key_user;
typedef struct keyring_index_key keyring_index_key;
typedef struct kgid_t kgid_t;
typedef struct kiocb kiocb;
typedef struct kioctx_table kioctx_table;
typedef struct klist_node klist_node;
typedef struct kmem_cache kmem_cache;
typedef struct kobj_attribute kobj_attribute;
typedef struct kobj_ns_type_operations kobj_ns_type_operations;
typedef struct kobj_type kobj_type;
typedef struct kobj_uevent_env kobj_uevent_env;
typedef struct kobject kobject;
typedef struct kparam_array kparam_array;
typedef struct kparam_string kparam_string;
typedef struct kprojid_t kprojid_t;
typedef struct kqid kqid;
typedef struct kref kref;
typedef struct kset kset;
typedef struct kset_uevent_ops kset_uevent_ops;
typedef struct kstat kstat;
typedef struct kstatfs kstatfs;
typedef struct kuid_t kuid_t;
typedef struct latch_tree_node latch_tree_node;
typedef struct linux_binfmt linux_binfmt;
typedef struct list_head list_head;
typedef struct list_lru list_lru;
typedef struct list_lru_node list_lru_node;
typedef struct list_lru_one list_lru_one;
typedef struct llist_node llist_node;
typedef struct load_weight load_weight;
typedef struct lock_class_key lock_class_key;
typedef struct lock_manager_operations lock_manager_operations;
typedef struct lockref lockref;
typedef struct lruvec lruvec;
typedef struct mem_cgroup mem_cgroup;
typedef struct mem_dqblk mem_dqblk;
typedef struct mem_dqinfo mem_dqinfo;
typedef struct mem_section mem_section;
typedef struct miscdevice miscdevice;
typedef struct mm_context_t mm_context_t;
typedef struct mm_rss_stat mm_rss_stat;
typedef struct mm_struct mm_struct;
typedef struct mod_arch_specific mod_arch_specific;
typedef struct mod_kallsyms mod_kallsyms;
typedef struct mod_tree_node mod_tree_node;
typedef struct module module;
typedef struct module_attribute module_attribute;
typedef struct module_kobject module_kobject;
typedef struct module_layout module_layout;
typedef struct module_notes_attrs module_notes_attrs;
typedef struct module_param_attrs module_param_attrs;
typedef struct module_sect_attrs module_sect_attrs;
typedef struct mtd_info mtd_info;
typedef struct mutex mutex;
typedef struct nameidata nameidata;
typedef struct nfs4_lock_info nfs4_lock_info;
typedef struct nfs4_lock_state nfs4_lock_state;
typedef struct nfs_lock_info nfs_lock_info;
typedef struct nlm_lockowner nlm_lockowner;
typedef struct nodemask_t nodemask_t;
typedef struct notifier_block notifier_block;
typedef struct nsproxy nsproxy;
typedef struct of_device_id of_device_id;
typedef struct optimistic_spin_queue optimistic_spin_queue;
typedef struct pacct_struct pacct_struct;
typedef struct page page;
typedef struct page_ext_operations page_ext_operations;
typedef struct page_frag page_frag;
typedef struct path path;
typedef struct per_cpu_nodestat per_cpu_nodestat;
typedef struct per_cpu_pages per_cpu_pages;
typedef struct per_cpu_pageset per_cpu_pageset;
typedef struct percpu_counter percpu_counter;
typedef struct percpu_ref percpu_ref;
typedef struct percpu_rw_semaphore percpu_rw_semaphore;
typedef struct perf_event perf_event;
typedef struct perf_event_context perf_event_context;
typedef struct pgd_t pgd_t;
typedef struct pglist_data pglist_data;
typedef struct pgprot_t pgprot_t;
typedef struct pid pid;
typedef struct pid_link pid_link;
typedef struct pid_namespace pid_namespace;
typedef struct pinctrl pinctrl;
typedef struct pinctrl_state pinctrl_state;
typedef struct pipe_inode_info pipe_inode_info;
typedef struct plist_node plist_node;
typedef struct pm_domain_data pm_domain_data;
typedef struct pm_message pm_message;
typedef struct pm_subsys_data pm_subsys_data;
typedef struct pmd_t pmd_t;
typedef struct poll_table_struct poll_table_struct;
typedef struct pollfd pollfd;
typedef struct posix_acl posix_acl;
typedef struct prev_cputime prev_cputime;
typedef struct pte_t pte_t;
typedef struct pvclock_vcpu_time_info pvclock_vcpu_time_info;
typedef struct pvclock_wall_clock pvclock_wall_clock;
typedef struct qc_dqblk qc_dqblk;
typedef struct qc_info qc_info;
typedef struct qc_state qc_state;
typedef struct qc_type_state qc_type_state;
typedef struct qstr qstr;
typedef struct quota_format_ops quota_format_ops;
typedef struct quota_format_type quota_format_type;
typedef struct quota_info quota_info;
typedef struct quotactl_ops quotactl_ops;
typedef struct radix_tree_node radix_tree_node;
typedef struct radix_tree_root radix_tree_root;
typedef struct ratelimit_state ratelimit_state;
typedef struct raw_spinlock raw_spinlock;
typedef struct rb_node rb_node;
typedef struct rb_root rb_root;
typedef struct rcu_sync rcu_sync;
typedef struct reclaim_state reclaim_state;
typedef struct request_queue request_queue;
typedef struct resource resource;
typedef struct restart_block restart_block;
typedef struct rlimit rlimit;
typedef struct robust_list_head robust_list_head;
typedef struct rt_mutex_waiter rt_mutex_waiter;
typedef struct rw_semaphore rw_semaphore;
typedef struct rwlock_t rwlock_t;
typedef struct sb_writers sb_writers;
typedef struct sched_avg sched_avg;
typedef struct sched_class sched_class;
typedef struct sched_dl_entity sched_dl_entity;
typedef struct sched_entity sched_entity;
typedef struct sched_info sched_info;
typedef struct sched_rt_entity sched_rt_entity;
typedef struct seccomp seccomp;
typedef struct secondary_data secondary_data;
typedef struct sem_undo_list sem_undo_list;
typedef struct seq_file seq_file;
typedef struct seq_operations seq_operations;
typedef struct seqcount seqcount;
typedef struct seqlock_t seqlock_t;
typedef struct shared_info shared_info;
typedef struct shrink_control shrink_control;
typedef struct shrinker shrinker;
typedef struct sigaction sigaction;
typedef struct sighand_struct sighand_struct;
typedef struct siginfo siginfo;
typedef struct signal_struct signal_struct;
typedef struct sigpending sigpending;
typedef struct sigset_t sigset_t;
typedef struct sock sock;
typedef struct spinlock spinlock;
typedef struct start_info start_info;
typedef struct static_key static_key;
typedef struct static_key_false static_key_false;
typedef struct subsys_private subsys_private;
typedef struct super_block super_block;
typedef struct super_operations super_operations;
typedef struct swap_info_struct swap_info_struct;
typedef struct sysfs_ops sysfs_ops;
typedef struct sysv_sem sysv_sem;
typedef struct sysv_shm sysv_shm;
typedef struct task_cputime task_cputime;
typedef struct task_cputime_atomic task_cputime_atomic;
typedef struct task_delay_info task_delay_info;
typedef struct task_io_accounting task_io_accounting;
typedef struct task_rss_stat task_rss_stat;
typedef struct task_struct task_struct;
typedef struct taskstats taskstats;
typedef struct thread_group_cputimer thread_group_cputimer;
typedef struct thread_info thread_info;
typedef struct thread_struct thread_struct;
typedef struct tick_device tick_device;
typedef struct timer_list timer_list;
typedef struct timerqueue_head timerqueue_head;
typedef struct timerqueue_node timerqueue_node;
typedef struct timespec timespec;
typedef struct timezone timezone;
typedef struct tracepoint tracepoint;
typedef struct tracepoint_func tracepoint_func;
typedef struct tty_audit_buf tty_audit_buf;
typedef struct tty_struct tty_struct;
typedef struct upid upid;
typedef struct uprobes_state uprobes_state;
typedef struct user_fpsimd_state user_fpsimd_state;
typedef struct user_namespace user_namespace;
typedef struct user_struct user_struct;
typedef struct vcpu_info vcpu_info;
typedef struct vfsmount vfsmount;
typedef struct vm_area_struct vm_area_struct;
typedef struct vm_event_state vm_event_state;
typedef struct vm_fault vm_fault;
typedef struct vm_operations_struct vm_operations_struct;
typedef struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
typedef struct wake_irq wake_irq;
typedef struct wake_q_node wake_q_node;
typedef struct wakeup_source wakeup_source;
typedef struct work_struct work_struct;
typedef struct workqueue_struct workqueue_struct;
typedef struct writeback_control writeback_control;
typedef struct xattr_handler xattr_handler;
typedef struct zone zone;
typedef struct zone_padding zone_padding;
typedef struct zone_reclaim_stat zone_reclaim_stat;
typedef struct zonelist zonelist;
typedef struct zoneref zoneref;

/* ==================== Structures ==================== */

struct Elf64_Dyn {
    Elf64_Sxword d_tag;  // offset: 0x0
    anon_union_8_2_f9000a74_for_d_un d_un;  // offset: 0x8
}; // size: 0x10

struct Elf64_Ehdr {
    byte e_ident_magic_num;  // offset: 0x0
    string e_ident_magic_str;  // offset: 0x1
    byte e_ident_class;  // offset: 0x4
    byte e_ident_data;  // offset: 0x5
    byte e_ident_version;  // offset: 0x6
    byte e_ident_osabi;  // offset: 0x7
    byte e_ident_abiversion;  // offset: 0x8
    byte e_ident_pad[7];  // offset: 0x9
    word e_type;  // offset: 0x10
    word e_machine;  // offset: 0x12
    dword e_version;  // offset: 0x14
    qword e_entry;  // offset: 0x18
    qword e_phoff;  // offset: 0x20
    qword e_shoff;  // offset: 0x28
    dword e_flags;  // offset: 0x30
    word e_ehsize;  // offset: 0x34
    word e_phentsize;  // offset: 0x36
    word e_phnum;  // offset: 0x38
    word e_shentsize;  // offset: 0x3a
    word e_shnum;  // offset: 0x3c
    word e_shstrndx;  // offset: 0x3e
}; // size: 0x40

struct Elf64_Rela {
    qword r_offset;  // offset: 0x0
    qword r_info;  // offset: 0x8
    qword r_addend;  // offset: 0x10
}; // size: 0x18

struct Elf64_Shdr {
    dword sh_name;  // offset: 0x0
    Elf_SectionHeaderType_AARCH64 sh_type;  // offset: 0x4
    qword sh_flags;  // offset: 0x8
    qword sh_addr;  // offset: 0x10
    qword sh_offset;  // offset: 0x18
    qword sh_size;  // offset: 0x20
    dword sh_link;  // offset: 0x28
    dword sh_info;  // offset: 0x2c
    qword sh_addralign;  // offset: 0x30
    qword sh_entsize;  // offset: 0x38
}; // size: 0x40

struct Elf64_Sym {
    dword st_name;  // offset: 0x0
    byte st_info;  // offset: 0x4
    byte st_other;  // offset: 0x5
    word st_shndx;  // offset: 0x6
    qword st_value;  // offset: 0x8
    qword st_size;  // offset: 0x10
}; // size: 0x18

struct GnuBuildId {
    dword namesz;  // offset: 0x0
    dword descsz;  // offset: 0x4
    dword type;  // offset: 0x8
    string name;  // offset: 0xc
    byte hash[20];  // offset: 0x10
}; // size: 0x24

struct __wait_queue_head {
    spinlock_t lock;  // offset: 0x0
    list_head task_list;  // offset: 0x8
}; // size: 0x18

struct acpi_device_id {
    // Empty structure
}; // size: 0x1

struct address_space {
    inode * host;  // offset: 0x0
    radix_tree_root page_tree;  // offset: 0x8
    spinlock_t tree_lock;  // offset: 0x18
    atomic_t i_mmap_writable;  // offset: 0x1c
    rb_root i_mmap;  // offset: 0x20
    rw_semaphore i_mmap_rwsem;  // offset: 0x28
    ulong nrpages;  // offset: 0x50
    ulong nrexceptional;  // offset: 0x58
    ulong writeback_index;  // offset: 0x60
    address_space_operations * a_ops;  // offset: 0x68
    ulong flags;  // offset: 0x70
    spinlock_t private_lock;  // offset: 0x78
    gfp_t gfp_mask;  // offset: 0x7c
    list_head private_list;  // offset: 0x80
    void * private_data;  // offset: 0x90
}; // size: 0x98

struct address_space_operations {
    _func_int_page_ptr_writeback_control_ptr * writepage;  // offset: 0x0
    _func_int_file_ptr_page_ptr * readpage;  // offset: 0x8
    _func_int_address_space_ptr_writeback_control_ptr * writepages;  // offset: 0x10
    _func_int_page_ptr * set_page_dirty;  // offset: 0x18
    _func_int_file_ptr_address_space_ptr_list_head_ptr_uint * readpages;  // offset: 0x20
    _func_int_file_ptr_address_space_ptr_loff_t_uint_uint_page_ptr_ptr_void_ptr_ptr * write_begin;  // offset: 0x28
    _func_int_file_ptr_address_space_ptr_loff_t_uint_uint_page_ptr_void_ptr * write_end;  // offset: 0x30
    _func_sector_t_address_space_ptr_sector_t * bmap;  // offset: 0x38
    _func_void_page_ptr_uint_uint * invalidatepage;  // offset: 0x40
    _func_int_page_ptr_gfp_t * releasepage;  // offset: 0x48
    compound_page_dtor * freepage;  // offset: 0x50
    _func_ssize_t_kiocb_ptr_iov_iter_ptr * direct_IO;  // offset: 0x58
    _func_int_address_space_ptr_page_ptr_page_ptr_migrate_mode * migratepage;  // offset: 0x60
    _func_bool_page_ptr_isolate_mode_t * isolate_page;  // offset: 0x68
    compound_page_dtor * putback_page;  // offset: 0x70
    _func_int_page_ptr * launder_page;  // offset: 0x78
    _func_int_page_ptr_ulong_ulong * is_partially_uptodate;  // offset: 0x80
    _func_void_page_ptr_bool_ptr_bool_ptr * is_dirty_writeback;  // offset: 0x88
    _func_int_address_space_ptr_page_ptr * error_remove_page;  // offset: 0x90
    _func_int_swap_info_struct_ptr_file_ptr_sector_t_ptr * swap_activate;  // offset: 0x98
    _func_void_file_ptr * swap_deactivate;  // offset: 0xa0
}; // size: 0xa8

struct anon_struct_16_2_036100f2_for__sigpoll {
    long _band;  // offset: 0x0
    int _fd;  // offset: 0x8
}; // size: 0x10

struct anon_struct_16_2_1ccaa948_for_domU {
    xen_pfn_t mfn;  // offset: 0x0
    uint32_t evtchn;  // offset: 0x8
}; // size: 0x10

struct anon_struct_16_2_6c587c7a_for__addr_bnd {
    void * _lower;  // offset: 0x0
    void * _upper;  // offset: 0x8
}; // size: 0x10

struct anon_struct_16_2_bf2d6ad5_for_anon_union_16_2_0496ad32_for_radix_tree_node_3_0 {
    radix_tree_node * parent;  // offset: 0x0
    void * private_data;  // offset: 0x8
}; // size: 0x10

struct anon_struct_16_2_c793ed0d_for_anon_union_24_2_a31149a9_for_key_14_1 {
    key_type * type;  // offset: 0x0
    char * description;  // offset: 0x8
}; // size: 0x10

struct anon_struct_16_3_1ec73fca_for_anon_union_16_5_86b83ece_for_page_4_4 {
    ulong compound_head;  // offset: 0x0
    uint compound_dtor;  // offset: 0x8
    uint compound_order;  // offset: 0xc
}; // size: 0x10

struct anon_struct_16_3_349d2ff7_for__sigsys {
    void * _call_addr;  // offset: 0x0
    int _syscall;  // offset: 0x8
    uint _arch;  // offset: 0xc
}; // size: 0x10

struct anon_struct_16_3_55e3d276_for__rt {
    __kernel_pid_t _pid;  // offset: 0x0
    __kernel_uid32_t _uid;  // offset: 0x4
    sigval_t _sigval;  // offset: 0x8
}; // size: 0x10

struct anon_struct_16_3_a99975b4_for_anon_union_16_5_86b83ece_for_page_4_2 {
    page * next;  // offset: 0x0
    int pages;  // offset: 0x8
    int pobjects;  // offset: 0xc
}; // size: 0x10

struct anon_struct_24_2_b8c32279_for_afs {
    list_head link;  // offset: 0x0
    int state;  // offset: 0x10
}; // size: 0x18

struct anon_struct_24_5_a9d2e8e0_for__timer {
    __kernel_timer_t _tid;  // offset: 0x0
    int _overrun;  // offset: 0x4
    char _pad[0];  // offset: 0x8
    sigval_t _sigval;  // offset: 0x8
    int _sys_private;  // offset: 0x10
}; // size: 0x18

struct anon_struct_32_2_435e3c06_for_anon_union_32_3_ecfb39e2_for_key_15_1 {
    list_head name_link;  // offset: 0x0
    assoc_array keys;  // offset: 0x10
}; // size: 0x20

struct anon_struct_32_2_b72ec8c0_for_shared {
    rb_node rb;  // offset: 0x0
    ulong rb_subtree_last;  // offset: 0x18
}; // size: 0x20

struct anon_struct_32_3_83228368_for__sigfault {
    void * _addr;  // offset: 0x0
    short _addr_lsb;  // offset: 0x8
    anon_union_16_2_200698a6_for_anon_struct_32_3_83228368_for__sigfault_2 field_2;  // offset: 0x10
}; // size: 0x20

struct anon_struct_32_4_3561e44d_for_nanosleep {
    clockid_t clockid;  // offset: 0x0
    timespec * rmtp;  // offset: 0x8
    compat_timespec * compat_rmtp;  // offset: 0x10
    u64 expires;  // offset: 0x18
}; // size: 0x20

struct anon_struct_32_5_1063e6a4_for_poll {
    pollfd * ufds;  // offset: 0x0
    int nfds;  // offset: 0x8
    int has_timeout;  // offset: 0xc
    ulong tv_sec;  // offset: 0x10
    ulong tv_nsec;  // offset: 0x18
}; // size: 0x20

struct anon_struct_32_5_ac353c0e_for__sigchld {
    __kernel_pid_t _pid;  // offset: 0x0
    __kernel_uid32_t _uid;  // offset: 0x4
    int _status;  // offset: 0x8
    __kernel_clock_t _utime;  // offset: 0x10
    __kernel_clock_t _stime;  // offset: 0x18
}; // size: 0x20

struct anon_struct_40_6_daaf18c6_for_futex {
    u32 * uaddr;  // offset: 0x0
    u32 val;  // offset: 0x8
    u32 flags;  // offset: 0xc
    u32 bitset;  // offset: 0x10
    u64 time;  // offset: 0x18
    u32 * uaddr2;  // offset: 0x20
}; // size: 0x28

struct anon_struct_4_3_197f4b50_for_anon_union_4_4_c461a3d3_for_anon_struct_8_2_00f704d7_for_anon_union_8_2_8f55150c_for_page_3_1_0_2 {
    uint:16 inuse;  // offset: 0x0
    uint:15 objects;  // offset: 0x2
    uint:1 frozen;  // offset: 0x3
}; // size: 0x4

struct anon_struct_528_3_de587f01_for_anon_union_528_2_afce2d22_for_fpsimd_state_0_1 {
    __int128 unsigned vregs[32];  // offset: 0x0
    u32 fpsr;  // offset: 0x200
    u32 fpcr;  // offset: 0x204
}; // size: 0x210

struct anon_struct_8_2_00f704d7_for_anon_union_8_2_8f55150c_for_page_3_1 {
    anon_union_4_4_c461a3d3_for_anon_struct_8_2_00f704d7_for_anon_union_8_2_8f55150c_for_page_3_1_0 field_0;  // offset: 0x0
    atomic_t _refcount;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_1193de1b_for_dom0 {
    uint32_t info_off;  // offset: 0x0
    uint32_t info_size;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_239a000b_for_anon_union_8_2_a3c87c50_for_lockref_0_1 {
    spinlock_t lock;  // offset: 0x0
    int count;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_37e52e62_for__kill {
    __kernel_pid_t _pid;  // offset: 0x0
    __kernel_uid32_t _uid;  // offset: 0x4
}; // size: 0x8

struct anon_struct_8_2_62570ece_for_anon_union_8_2_ae5c065a_for_qstr_0_0 {
    u32 hash;  // offset: 0x0
    u32 len;  // offset: 0x4
}; // size: 0x8

struct anon_vma {
    // Empty structure
}; // size: 0x1

struct arch_rwlock_t {
    uint lock;  // offset: 0x0
}; // size: 0x4

struct arch_shared_info {
    // Empty structure
}; // size: 0x1

struct arch_spinlock_t {
    u16 owner;  // offset: 0x0
    u16 next;  // offset: 0x2
}; // size: 0x4

struct arch_vcpu_info {
    // Empty structure
}; // size: 0x1

struct arm64_ftr_bits {
    bool sign;  // offset: 0x0
    bool strict;  // offset: 0x1
    ftr_type type;  // offset: 0x4
    u8 shift;  // offset: 0x8
    u8 width;  // offset: 0x9
    s64 safe_val;  // offset: 0x10
}; // size: 0x18

struct arm64_ftr_reg {
    char * name;  // offset: 0x0
    u64 strict_mask;  // offset: 0x8
    u64 sys_val;  // offset: 0x10
    arm64_ftr_bits * ftr_bits;  // offset: 0x18
}; // size: 0x20

struct assoc_array {
    assoc_array_ptr * root;  // offset: 0x0
    ulong nr_leaves_on_tree;  // offset: 0x8
}; // size: 0x10

struct assoc_array_ptr {
    // Empty structure
}; // size: 0x1

struct atomic64_t {
    long counter;  // offset: 0x0
}; // size: 0x8

struct atomic_notifier_head {
    spinlock_t lock;  // offset: 0x0
    notifier_block * head;  // offset: 0x8
}; // size: 0x10

struct atomic_t {
    int counter;  // offset: 0x0
}; // size: 0x4

struct attribute {
    char * name;  // offset: 0x0
    umode_t mode;  // offset: 0x8
}; // size: 0x10

struct attribute_group {
    char * name;  // offset: 0x0
    _func_umode_t_kobject_ptr_attribute_ptr_int * is_visible;  // offset: 0x8
    _func_umode_t_kobject_ptr_bin_attribute_ptr_int * is_bin_visible;  // offset: 0x10
    attribute * * attrs;  // offset: 0x18
    bin_attribute * * bin_attrs;  // offset: 0x20
}; // size: 0x28

struct audit_context {
    // Empty structure
}; // size: 0x1

struct backing_dev_info {
    // Empty structure
}; // size: 0x1

struct bin_attribute {
    attribute attr;  // offset: 0x0
    size_t size;  // offset: 0x10
    void * private;  // offset: 0x18
    _func_ssize_t_file_ptr_kobject_ptr_bin_attribute_ptr_char_ptr_loff_t_size_t * read;  // offset: 0x20
    _func_ssize_t_file_ptr_kobject_ptr_bin_attribute_ptr_char_ptr_loff_t_size_t * write;  // offset: 0x28
    _func_int_file_ptr_kobject_ptr_bin_attribute_ptr_vm_area_struct_ptr * mmap;  // offset: 0x30
}; // size: 0x38

struct bio_list {
    // Empty structure
}; // size: 0x1

struct blk_plug {
    // Empty structure
}; // size: 0x1

struct block_device {
    dev_t bd_dev;  // offset: 0x0
    int bd_openers;  // offset: 0x4
    inode * bd_inode;  // offset: 0x8
    super_block * bd_super;  // offset: 0x10
    mutex bd_mutex;  // offset: 0x18
    void * bd_claiming;  // offset: 0x40
    void * bd_holder;  // offset: 0x48
    int bd_holders;  // offset: 0x50
    bool bd_write_holder;  // offset: 0x54
    undefined field_85;  // offset: 0x55
    undefined field_86;  // offset: 0x56
    undefined field_87;  // offset: 0x57
    list_head bd_holder_disks;  // offset: 0x58
    block_device * bd_contains;  // offset: 0x68
    uint bd_block_size;  // offset: 0x70
    undefined field_116;  // offset: 0x74
    undefined field_117;  // offset: 0x75
    undefined field_118;  // offset: 0x76
    undefined field_119;  // offset: 0x77
    hd_struct * bd_part;  // offset: 0x78
    uint bd_part_count;  // offset: 0x80
    int bd_invalidated;  // offset: 0x84
    gendisk * bd_disk;  // offset: 0x88
    request_queue * bd_queue;  // offset: 0x90
    list_head bd_list;  // offset: 0x98
    ulong bd_private;  // offset: 0xa8
    int bd_fsfreeze_count;  // offset: 0xb0
    undefined field_180;  // offset: 0xb4
    undefined field_181;  // offset: 0xb5
    undefined field_182;  // offset: 0xb6
    undefined field_183;  // offset: 0xb7
    mutex bd_fsfreeze_mutex;  // offset: 0xb8
}; // size: 0xe0

struct blocking_notifier_head {
    rw_semaphore rwsem;  // offset: 0x0
    notifier_block * head;  // offset: 0x28
}; // size: 0x30

struct bug_entry {
    int bug_addr_disp;  // offset: 0x0
    int file_disp;  // offset: 0x4
    ushort line;  // offset: 0x8
    ushort flags;  // offset: 0xa
}; // size: 0xc

struct bus_type {
    char * name;  // offset: 0x0
    char * dev_name;  // offset: 0x8
    device * dev_root;  // offset: 0x10
    device_attribute * dev_attrs;  // offset: 0x18
    attribute_group * * bus_groups;  // offset: 0x20
    attribute_group * * dev_groups;  // offset: 0x28
    attribute_group * * drv_groups;  // offset: 0x30
    _func_int_device_ptr_device_driver_ptr * match;  // offset: 0x38
    _func_int_device_ptr_kobj_uevent_env_ptr * uevent;  // offset: 0x40
    _func_int_device_ptr * probe;  // offset: 0x48
    _func_int_device_ptr * remove;  // offset: 0x50
    _func_void_device_ptr * shutdown;  // offset: 0x58
    _func_int_device_ptr * online;  // offset: 0x60
    _func_int_device_ptr * offline;  // offset: 0x68
    _func_int_device_ptr_pm_message_t * suspend;  // offset: 0x70
    _func_int_device_ptr * resume;  // offset: 0x78
    dev_pm_ops * pm;  // offset: 0x80
    iommu_ops * iommu_ops;  // offset: 0x88
    subsys_private * p;  // offset: 0x90
    lock_class_key lock_key;  // offset: 0x98
}; // size: 0x98

struct callback_head {
    callback_head * next;  // offset: 0x0
    _func_void_callback_head_ptr * func;  // offset: 0x8
}; // size: 0x10

struct cdev {
    // Empty structure
}; // size: 0x1

struct cftype {
    char name[64];  // offset: 0x0
    ulong private;  // offset: 0x40
    size_t max_write_len;  // offset: 0x48
    uint flags;  // offset: 0x50
    uint file_offset;  // offset: 0x54
    cgroup_subsys * ss;  // offset: 0x58
    list_head node;  // offset: 0x60
    kernfs_ops * kf_ops;  // offset: 0x70
    _func_u64_cgroup_subsys_state_ptr_cftype_ptr * read_u64;  // offset: 0x78
    _func_s64_cgroup_subsys_state_ptr_cftype_ptr * read_s64;  // offset: 0x80
    _func_int_seq_file_ptr_void_ptr * seq_show;  // offset: 0x88
    _func_void_ptr_seq_file_ptr_loff_t_ptr * seq_start;  // offset: 0x90
    _func_void_ptr_seq_file_ptr_void_ptr_loff_t_ptr * seq_next;  // offset: 0x98
    _func_void_seq_file_ptr_void_ptr * seq_stop;  // offset: 0xa0
    _func_int_cgroup_subsys_state_ptr_cftype_ptr_u64 * write_u64;  // offset: 0xa8
    _func_int_cgroup_subsys_state_ptr_cftype_ptr_s64 * write_s64;  // offset: 0xb0
    _func_ssize_t_kernfs_open_file_ptr_char_ptr_size_t_loff_t * write;  // offset: 0xb8
}; // size: 0xc0

struct cgroup {
    cgroup_subsys_state self;  // offset: 0x0
    ulong flags;  // offset: 0xb8
    int id;  // offset: 0xc0
    int level;  // offset: 0xc4
    int populated_cnt;  // offset: 0xc8
    kernfs_node * kn;  // offset: 0xd0
    cgroup_file procs_file;  // offset: 0xd8
    cgroup_file events_file;  // offset: 0xe0
    u16 subtree_control;  // offset: 0xe8
    u16 subtree_ss_mask;  // offset: 0xea
    u16 old_subtree_control;  // offset: 0xec
    u16 old_subtree_ss_mask;  // offset: 0xee
    cgroup_subsys_state * subsys[0];  // offset: 0xf0
    cgroup_root * root;  // offset: 0xf0
    list_head cset_links;  // offset: 0xf8
    list_head e_csets[0];  // offset: 0x108
    list_head pidlists;  // offset: 0x108
    mutex pidlist_mutex;  // offset: 0x118
    wait_queue_head_t offline_waitq;  // offset: 0x140
    work_struct release_agent_work;  // offset: 0x158
    int ancestor_ids[0];  // offset: 0x178
}; // size: 0x178

struct cgroup_file {
    kernfs_node * kn;  // offset: 0x0
}; // size: 0x8

struct cgroup_root {
    kernfs_root * kf_root;  // offset: 0x0
    uint subsys_mask;  // offset: 0x8
    int hierarchy_id;  // offset: 0xc
    cgroup cgrp;  // offset: 0x10
    int cgrp_ancestor_id_storage;  // offset: 0x188
    atomic_t nr_cgrps;  // offset: 0x18c
    list_head root_list;  // offset: 0x190
    uint flags;  // offset: 0x1a0
    idr cgroup_idr;  // offset: 0x1a8
    char release_agent_path[4096];  // offset: 0x1d0
    char name[64];  // offset: 0x11d0
}; // size: 0x1210

struct cgroup_subsys {
    _func_cgroup_subsys_state_ptr_cgroup_subsys_state_ptr * css_alloc;  // offset: 0x0
    _func_int_cgroup_subsys_state_ptr * css_online;  // offset: 0x8
    _func_void_cgroup_subsys_state_ptr * css_offline;  // offset: 0x10
    _func_void_cgroup_subsys_state_ptr * css_released;  // offset: 0x18
    _func_void_cgroup_subsys_state_ptr * css_free;  // offset: 0x20
    _func_void_cgroup_subsys_state_ptr * css_reset;  // offset: 0x28
    _func_int_cgroup_taskset_ptr * can_attach;  // offset: 0x30
    _func_void_cgroup_taskset_ptr * cancel_attach;  // offset: 0x38
    _func_void_cgroup_taskset_ptr * attach;  // offset: 0x40
    __restorefn_t * post_attach;  // offset: 0x48
    _func_int_task_struct_ptr * can_fork;  // offset: 0x50
    _func_void_task_struct_ptr * cancel_fork;  // offset: 0x58
    _func_void_task_struct_ptr * fork;  // offset: 0x60
    _func_void_task_struct_ptr * exit;  // offset: 0x68
    _func_void_task_struct_ptr * free;  // offset: 0x70
    _func_void_cgroup_subsys_state_ptr * bind;  // offset: 0x78
    bool:1 early_init;  // offset: 0x80
    bool:1 implicit_on_dfl;  // offset: 0x80
    bool:1 broken_hierarchy;  // offset: 0x80
    bool:1 warned_broken_hierarchy;  // offset: 0x80
    int id;  // offset: 0x84
    char * name;  // offset: 0x88
    char * legacy_name;  // offset: 0x90
    cgroup_root * root;  // offset: 0x98
    idr css_idr;  // offset: 0xa0
    list_head cfts;  // offset: 0xc8
    cftype * dfl_cftypes;  // offset: 0xd8
    cftype * legacy_cftypes;  // offset: 0xe0
    uint depends_on;  // offset: 0xe8
}; // size: 0xf0

struct cgroup_subsys_state {
    cgroup * cgroup;  // offset: 0x0
    cgroup_subsys * ss;  // offset: 0x8
    percpu_ref refcnt;  // offset: 0x10
    cgroup_subsys_state * parent;  // offset: 0x48
    list_head sibling;  // offset: 0x50
    list_head children;  // offset: 0x60
    int id;  // offset: 0x70
    uint flags;  // offset: 0x74
    u64 serial_nr;  // offset: 0x78
    atomic_t online_cnt;  // offset: 0x80
    callback_head callback_head;  // offset: 0x88
    work_struct destroy_work;  // offset: 0x98
}; // size: 0xb8

struct cgroup_taskset {
    // Empty structure
}; // size: 0x1

struct class {
    char * name;  // offset: 0x0
    module * owner;  // offset: 0x8
    class_attribute * class_attrs;  // offset: 0x10
    attribute_group * * dev_groups;  // offset: 0x18
    kobject * dev_kobj;  // offset: 0x20
    _func_int_device_ptr_kobj_uevent_env_ptr * dev_uevent;  // offset: 0x28
    _func_char_ptr_device_ptr_umode_t_ptr * devnode;  // offset: 0x30
    _func_void_class_ptr * class_release;  // offset: 0x38
    _func_void_device_ptr * dev_release;  // offset: 0x40
    _func_int_device_ptr_pm_message_t * suspend;  // offset: 0x48
    _func_int_device_ptr * resume;  // offset: 0x50
    kobj_ns_type_operations * ns_type;  // offset: 0x58
    _func_void_ptr_device_ptr * namespace;  // offset: 0x60
    dev_pm_ops * pm;  // offset: 0x68
    subsys_private * p;  // offset: 0x70
}; // size: 0x78

struct class_attribute {
    attribute attr;  // offset: 0x0
    _func_ssize_t_class_ptr_class_attribute_ptr_char_ptr * show;  // offset: 0x10
    _func_ssize_t_class_ptr_class_attribute_ptr_char_ptr_size_t * store;  // offset: 0x18
}; // size: 0x20

struct cma {
    // Empty structure
}; // size: 0x1

struct compat_robust_list_head {
    // Empty structure
}; // size: 0x1

struct compat_timespec {
    compat_time_t tv_sec;  // offset: 0x0
    s32 tv_nsec;  // offset: 0x4
}; // size: 0x8

struct completion {
    uint done;  // offset: 0x0
    wait_queue_head_t wait;  // offset: 0x8
}; // size: 0x20

struct core_state {
    atomic_t nr_threads;  // offset: 0x0
    core_thread dumper;  // offset: 0x8
    completion startup;  // offset: 0x18
}; // size: 0x38

struct core_thread {
    task_struct * task;  // offset: 0x0
    core_thread * next;  // offset: 0x8
}; // size: 0x10

struct cpu_context {
    ulong x19;  // offset: 0x0
    ulong x20;  // offset: 0x8
    ulong x21;  // offset: 0x10
    ulong x22;  // offset: 0x18
    ulong x23;  // offset: 0x20
    ulong x24;  // offset: 0x28
    ulong x25;  // offset: 0x30
    ulong x26;  // offset: 0x38
    ulong x27;  // offset: 0x40
    ulong x28;  // offset: 0x48
    ulong fp;  // offset: 0x50
    ulong sp;  // offset: 0x58
    ulong pc;  // offset: 0x60
}; // size: 0x68

struct cpu_itimer {
    cputime_t expires;  // offset: 0x0
    cputime_t incr;  // offset: 0x8
    u32 error;  // offset: 0x10
    u32 incr_error;  // offset: 0x14
}; // size: 0x18

struct cpu_topology {
    int thread_id;  // offset: 0x0
    int core_id;  // offset: 0x4
    int cluster_id;  // offset: 0x8
    cpumask_t thread_sibling;  // offset: 0x10
    cpumask_t core_sibling;  // offset: 0x18
}; // size: 0x20

struct cpumask {
    ulong bits[1];  // offset: 0x0
}; // size: 0x8

struct cred {
    atomic_t usage;  // offset: 0x0
    kuid_t uid;  // offset: 0x4
    kgid_t gid;  // offset: 0x8
    kuid_t suid;  // offset: 0xc
    kgid_t sgid;  // offset: 0x10
    kuid_t euid;  // offset: 0x14
    kgid_t egid;  // offset: 0x18
    kuid_t fsuid;  // offset: 0x1c
    kgid_t fsgid;  // offset: 0x20
    uint securebits;  // offset: 0x24
    kernel_cap_t cap_inheritable;  // offset: 0x28
    kernel_cap_t cap_permitted;  // offset: 0x30
    kernel_cap_t cap_effective;  // offset: 0x38
    kernel_cap_t cap_bset;  // offset: 0x40
    kernel_cap_t cap_ambient;  // offset: 0x48
    uchar jit_keyring;  // offset: 0x50
    key * session_keyring;  // offset: 0x58
    key * process_keyring;  // offset: 0x60
    key * thread_keyring;  // offset: 0x68
    key * request_key_auth;  // offset: 0x70
    user_struct * user;  // offset: 0x78
    user_namespace * user_ns;  // offset: 0x80
    group_info * group_info;  // offset: 0x88
    callback_head rcu;  // offset: 0x90
}; // size: 0xa0

struct css_set {
    atomic_t refcount;  // offset: 0x0
    hlist_node hlist;  // offset: 0x8
    list_head tasks;  // offset: 0x18
    list_head mg_tasks;  // offset: 0x28
    list_head cgrp_links;  // offset: 0x38
    cgroup * dfl_cgrp;  // offset: 0x48
    cgroup_subsys_state * subsys[0];  // offset: 0x50
    list_head mg_preload_node;  // offset: 0x50
    list_head mg_node;  // offset: 0x60
    cgroup * mg_src_cgrp;  // offset: 0x70
    cgroup * mg_dst_cgrp;  // offset: 0x78
    css_set * mg_dst_cset;  // offset: 0x80
    list_head e_cset_node[0];  // offset: 0x88
    list_head task_iters;  // offset: 0x88
    bool dead;  // offset: 0x98
    callback_head callback_head;  // offset: 0xa0
}; // size: 0xb0

struct ctl_table {
    char * procname;  // offset: 0x0
    void * data;  // offset: 0x8
    int maxlen;  // offset: 0x10
    umode_t mode;  // offset: 0x14
    ctl_table * child;  // offset: 0x18
    proc_handler * proc_handler;  // offset: 0x20
    ctl_table_poll * poll;  // offset: 0x28
    void * extra1;  // offset: 0x30
    void * extra2;  // offset: 0x38
}; // size: 0x40

struct ctl_table_poll {
    atomic_t event;  // offset: 0x0
    wait_queue_head_t wait;  // offset: 0x8
}; // size: 0x20

struct debug_info {
    int suspended_step;  // offset: 0x0
    int bps_disabled;  // offset: 0x4
    int wps_disabled;  // offset: 0x8
    perf_event * hbp_break[16];  // offset: 0x10
    perf_event * hbp_watch[16];  // offset: 0x90
}; // size: 0x110

struct delayed_call {
    _func_void_void_ptr * fn;  // offset: 0x0
    void * arg;  // offset: 0x8
}; // size: 0x10

struct dentry {
    uint d_flags;  // offset: 0x0
    seqcount_t d_seq;  // offset: 0x4
    hlist_bl_node d_hash;  // offset: 0x8
    dentry * d_parent;  // offset: 0x18
    qstr d_name;  // offset: 0x20
    inode * d_inode;  // offset: 0x30
    uchar d_iname[32];  // offset: 0x38
    lockref d_lockref;  // offset: 0x58
    dentry_operations * d_op;  // offset: 0x60
    super_block * d_sb;  // offset: 0x68
    ulong d_time;  // offset: 0x70
    void * d_fsdata;  // offset: 0x78
    anon_union_16_2_a270f79b_for_dentry_12 field_12;  // offset: 0x80
    list_head d_child;  // offset: 0x90
    list_head d_subdirs;  // offset: 0xa0
    anon_union_16_3_1ff3538c_for_d_u d_u;  // offset: 0xb0
}; // size: 0xc0

struct dentry_operations {
    _func_int_dentry_ptr_uint * d_revalidate;  // offset: 0x0
    _func_int_dentry_ptr_uint * d_weak_revalidate;  // offset: 0x8
    _func_int_dentry_ptr_qstr_ptr * d_hash;  // offset: 0x10
    _func_int_dentry_ptr_uint_char_ptr_qstr_ptr * d_compare;  // offset: 0x18
    _func_int_dentry_ptr * d_delete;  // offset: 0x20
    _func_int_dentry_ptr * d_init;  // offset: 0x28
    _func_void_dentry_ptr * d_release;  // offset: 0x30
    _func_void_dentry_ptr * d_prune;  // offset: 0x38
    _func_void_dentry_ptr_inode_ptr * d_iput;  // offset: 0x40
    _func_char_ptr_dentry_ptr_char_ptr_int * d_dname;  // offset: 0x48
    _func_vfsmount_ptr_path_ptr * d_automount;  // offset: 0x50
    _func_int_dentry_ptr_bool * d_manage;  // offset: 0x58
    _func_dentry_ptr_dentry_ptr_inode_ptr_uint * d_real;  // offset: 0x60
    undefined field_104;  // offset: 0x68
    undefined field_105;  // offset: 0x69
    undefined field_106;  // offset: 0x6a
    undefined field_107;  // offset: 0x6b
    undefined field_108;  // offset: 0x6c
    undefined field_109;  // offset: 0x6d
    undefined field_110;  // offset: 0x6e
    undefined field_111;  // offset: 0x6f
    undefined field_112;  // offset: 0x70
    undefined field_113;  // offset: 0x71
    undefined field_114;  // offset: 0x72
    undefined field_115;  // offset: 0x73
    undefined field_116;  // offset: 0x74
    undefined field_117;  // offset: 0x75
    undefined field_118;  // offset: 0x76
    undefined field_119;  // offset: 0x77
    undefined field_120;  // offset: 0x78
    undefined field_121;  // offset: 0x79
    undefined field_122;  // offset: 0x7a
    undefined field_123;  // offset: 0x7b
    undefined field_124;  // offset: 0x7c
    undefined field_125;  // offset: 0x7d
    undefined field_126;  // offset: 0x7e
    undefined field_127;  // offset: 0x7f
}; // size: 0x80

struct dentry_stat_t {
    long nr_dentry;  // offset: 0x0
    long nr_unused;  // offset: 0x8
    long age_limit;  // offset: 0x10
    long want_pages;  // offset: 0x18
    long dummy[2];  // offset: 0x20
}; // size: 0x30

struct dev_archdata {
    dma_map_ops * dma_ops;  // offset: 0x0
    void * iommu;  // offset: 0x8
    bool dma_coherent;  // offset: 0x10
}; // size: 0x18

struct dev_pagemap {
    // Empty structure
}; // size: 0x1

struct dev_pin_info {
    pinctrl * p;  // offset: 0x0
    pinctrl_state * default_state;  // offset: 0x8
    pinctrl_state * init_state;  // offset: 0x10
    pinctrl_state * sleep_state;  // offset: 0x18
    pinctrl_state * idle_state;  // offset: 0x20
}; // size: 0x28

struct dev_pm_domain {
    dev_pm_ops ops;  // offset: 0x0
    _func_void_device_ptr_bool * detach;  // offset: 0xb8
    _func_int_device_ptr * activate;  // offset: 0xc0
    _func_void_device_ptr * sync;  // offset: 0xc8
    _func_void_device_ptr * dismiss;  // offset: 0xd0
}; // size: 0xd8

struct dev_pm_info {
    pm_message_t power_state;  // offset: 0x0
    uint:1 can_wakeup;  // offset: 0x4
    uint:1 async_suspend;  // offset: 0x4
    bool:1 is_prepared;  // offset: 0x4
    bool:1 is_suspended;  // offset: 0x4
    bool:1 is_noirq_suspended;  // offset: 0x4
    bool:1 is_late_suspended;  // offset: 0x4
    bool:1 early_init;  // offset: 0x4
    bool:1 direct_complete;  // offset: 0x4
    undefined field_5;  // offset: 0x5
    undefined field_6;  // offset: 0x6
    undefined field_7;  // offset: 0x7
    spinlock_t lock;  // offset: 0x8
    undefined field_12;  // offset: 0xc
    undefined field_13;  // offset: 0xd
    undefined field_14;  // offset: 0xe
    undefined field_15;  // offset: 0xf
    list_head entry;  // offset: 0x10
    completion completion;  // offset: 0x20
    wakeup_source * wakeup;  // offset: 0x40
    bool:1 wakeup_path;  // offset: 0x48
    bool:1 syscore;  // offset: 0x48
    bool:1 no_pm_callbacks;  // offset: 0x48
    undefined field_73;  // offset: 0x49
    undefined field_74;  // offset: 0x4a
    undefined field_75;  // offset: 0x4b
    undefined field_76;  // offset: 0x4c
    undefined field_77;  // offset: 0x4d
    undefined field_78;  // offset: 0x4e
    undefined field_79;  // offset: 0x4f
    timer_list suspend_timer;  // offset: 0x50
    ulong timer_expires;  // offset: 0x80
    work_struct work;  // offset: 0x88
    wait_queue_head_t wait_queue;  // offset: 0xa8
    wake_irq * wakeirq;  // offset: 0xc0
    atomic_t usage_count;  // offset: 0xc8
    atomic_t child_count;  // offset: 0xcc
    uint:3 disable_depth;  // offset: 0xd0
    uint:1 idle_notification;  // offset: 0xd0
    uint:1 request_pending;  // offset: 0xd0
    uint:1 deferred_resume;  // offset: 0xd0
    uint:1 run_wake;  // offset: 0xd0
    uint:1 runtime_auto;  // offset: 0xd0
    bool:1 ignore_children;  // offset: 0xd1
    uint:1 no_callbacks;  // offset: 0xd1
    uint:1 irq_safe;  // offset: 0xd1
    uint:1 use_autosuspend;  // offset: 0xd1
    uint:1 timer_autosuspends;  // offset: 0xd1
    uint:1 memalloc_noio;  // offset: 0xd1
    undefined field_210;  // offset: 0xd2
    undefined field_211;  // offset: 0xd3
    rpm_request request;  // offset: 0xd4
    rpm_status runtime_status;  // offset: 0xd8
    int runtime_error;  // offset: 0xdc
    int autosuspend_delay;  // offset: 0xe0
    undefined field_228;  // offset: 0xe4
    undefined field_229;  // offset: 0xe5
    undefined field_230;  // offset: 0xe6
    undefined field_231;  // offset: 0xe7
    ulong last_busy;  // offset: 0xe8
    ulong active_jiffies;  // offset: 0xf0
    ulong suspended_jiffies;  // offset: 0xf8
    ulong accounting_timestamp;  // offset: 0x100
    pm_subsys_data * subsys_data;  // offset: 0x108
    _func_void_device_ptr_s32 * set_latency_tolerance;  // offset: 0x110
    dev_pm_qos * qos;  // offset: 0x118
}; // size: 0x120

struct dev_pm_ops {
    _func_int_device_ptr * prepare;  // offset: 0x0
    _func_void_device_ptr * complete;  // offset: 0x8
    _func_int_device_ptr * suspend;  // offset: 0x10
    _func_int_device_ptr * resume;  // offset: 0x18
    _func_int_device_ptr * freeze;  // offset: 0x20
    _func_int_device_ptr * thaw;  // offset: 0x28
    _func_int_device_ptr * poweroff;  // offset: 0x30
    _func_int_device_ptr * restore;  // offset: 0x38
    _func_int_device_ptr * suspend_late;  // offset: 0x40
    _func_int_device_ptr * resume_early;  // offset: 0x48
    _func_int_device_ptr * freeze_late;  // offset: 0x50
    _func_int_device_ptr * thaw_early;  // offset: 0x58
    _func_int_device_ptr * poweroff_late;  // offset: 0x60
    _func_int_device_ptr * restore_early;  // offset: 0x68
    _func_int_device_ptr * suspend_noirq;  // offset: 0x70
    _func_int_device_ptr * resume_noirq;  // offset: 0x78
    _func_int_device_ptr * freeze_noirq;  // offset: 0x80
    _func_int_device_ptr * thaw_noirq;  // offset: 0x88
    _func_int_device_ptr * poweroff_noirq;  // offset: 0x90
    _func_int_device_ptr * restore_noirq;  // offset: 0x98
    _func_int_device_ptr * runtime_suspend;  // offset: 0xa0
    _func_int_device_ptr * runtime_resume;  // offset: 0xa8
    _func_int_device_ptr * runtime_idle;  // offset: 0xb0
}; // size: 0xb8

struct dev_pm_qos {
    // Empty structure
}; // size: 0x1

struct device {
    device * parent;  // offset: 0x0
    device_private * p;  // offset: 0x8
    kobject kobj;  // offset: 0x10
    char * init_name;  // offset: 0x50
    device_type * type;  // offset: 0x58
    mutex mutex;  // offset: 0x60
    bus_type * bus;  // offset: 0x88
    device_driver * driver;  // offset: 0x90
    void * platform_data;  // offset: 0x98
    void * driver_data;  // offset: 0xa0
    dev_pm_info power;  // offset: 0xa8
    dev_pm_domain * pm_domain;  // offset: 0x1c8
    dev_pin_info * pins;  // offset: 0x1d0
    u64 * dma_mask;  // offset: 0x1d8
    u64 coherent_dma_mask;  // offset: 0x1e0
    ulong dma_pfn_offset;  // offset: 0x1e8
    device_dma_parameters * dma_parms;  // offset: 0x1f0
    list_head dma_pools;  // offset: 0x1f8
    dma_coherent_mem * dma_mem;  // offset: 0x208
    cma * cma_area;  // offset: 0x210
    dev_archdata archdata;  // offset: 0x218
    device_node * of_node;  // offset: 0x230
    fwnode_handle * fwnode;  // offset: 0x238
    dev_t devt;  // offset: 0x240
    u32 id;  // offset: 0x244
    spinlock_t devres_lock;  // offset: 0x248
    list_head devres_head;  // offset: 0x250
    klist_node knode_class;  // offset: 0x260
    class * class;  // offset: 0x280
    attribute_group * * groups;  // offset: 0x288
    _func_void_device_ptr * release;  // offset: 0x290
    iommu_group * iommu_group;  // offset: 0x298
    iommu_fwspec * iommu_fwspec;  // offset: 0x2a0
    bool:1 offline_disabled;  // offset: 0x2a8
    bool:1 offline;  // offset: 0x2a8
}; // size: 0x2b0

struct device_attribute {
    attribute attr;  // offset: 0x0
    _func_ssize_t_device_ptr_device_attribute_ptr_char_ptr * show;  // offset: 0x10
    _func_ssize_t_device_ptr_device_attribute_ptr_char_ptr_size_t * store;  // offset: 0x18
}; // size: 0x20

struct device_dma_parameters {
    uint max_segment_size;  // offset: 0x0
    ulong segment_boundary_mask;  // offset: 0x8
}; // size: 0x10

struct device_driver {
    char * name;  // offset: 0x0
    bus_type * bus;  // offset: 0x8
    module * owner;  // offset: 0x10
    char * mod_name;  // offset: 0x18
    bool suppress_bind_attrs;  // offset: 0x20
    probe_type probe_type;  // offset: 0x24
    of_device_id * of_match_table;  // offset: 0x28
    acpi_device_id * acpi_match_table;  // offset: 0x30
    _func_int_device_ptr * probe;  // offset: 0x38
    _func_int_device_ptr * remove;  // offset: 0x40
    _func_void_device_ptr * shutdown;  // offset: 0x48
    _func_int_device_ptr_pm_message_t * suspend;  // offset: 0x50
    _func_int_device_ptr * resume;  // offset: 0x58
    attribute_group * * groups;  // offset: 0x60
    dev_pm_ops * pm;  // offset: 0x68
    driver_private * p;  // offset: 0x70
}; // size: 0x78

struct device_node {
    // Empty structure
}; // size: 0x1

struct device_private {
    // Empty structure
}; // size: 0x1

struct device_type {
    char * name;  // offset: 0x0
    attribute_group * * groups;  // offset: 0x8
    _func_int_device_ptr_kobj_uevent_env_ptr * uevent;  // offset: 0x10
    _func_char_ptr_device_ptr_umode_t_ptr_kuid_t_ptr_kgid_t_ptr * devnode;  // offset: 0x18
    _func_void_device_ptr * release;  // offset: 0x20
    dev_pm_ops * pm;  // offset: 0x28
}; // size: 0x30

struct dir_context {
    filldir_t actor;  // offset: 0x0
    loff_t pos;  // offset: 0x8
}; // size: 0x10

struct dma_coherent_mem {
    // Empty structure
}; // size: 0x1

struct dma_map_ops {
    // Empty structure
}; // size: 0x1

struct dqstats {
    int stat[8];  // offset: 0x0
    percpu_counter counter[8];  // offset: 0x20
}; // size: 0x160

struct dquot {
    hlist_node dq_hash;  // offset: 0x0
    list_head dq_inuse;  // offset: 0x10
    list_head dq_free;  // offset: 0x20
    list_head dq_dirty;  // offset: 0x30
    mutex dq_lock;  // offset: 0x40
    atomic_t dq_count;  // offset: 0x68
    wait_queue_head_t dq_wait_unused;  // offset: 0x70
    super_block * dq_sb;  // offset: 0x88
    kqid dq_id;  // offset: 0x90
    loff_t dq_off;  // offset: 0x98
    ulong dq_flags;  // offset: 0xa0
    mem_dqblk dq_dqb;  // offset: 0xa8
}; // size: 0xf0

struct dquot_operations {
    _func_int_dquot_ptr * write_dquot;  // offset: 0x0
    _func_dquot_ptr_super_block_ptr_int * alloc_dquot;  // offset: 0x8
    _func_void_dquot_ptr * destroy_dquot;  // offset: 0x10
    _func_int_dquot_ptr * acquire_dquot;  // offset: 0x18
    _func_int_dquot_ptr * release_dquot;  // offset: 0x20
    _func_int_dquot_ptr * mark_dirty;  // offset: 0x28
    _func_int_super_block_ptr_int * write_info;  // offset: 0x30
    _func_qsize_t_ptr_inode_ptr * get_reserved_space;  // offset: 0x38
    _func_int_inode_ptr_kprojid_t_ptr * get_projid;  // offset: 0x40
    _func_int_super_block_ptr_kqid_ptr * get_next_id;  // offset: 0x48
}; // size: 0x50

struct driver_private {
    // Empty structure
}; // size: 0x1

struct elf64_sym {
    Elf64_Word st_name;  // offset: 0x0
    uchar st_info;  // offset: 0x4
    uchar st_other;  // offset: 0x5
    Elf64_Half st_shndx;  // offset: 0x6
    Elf64_Addr st_value;  // offset: 0x8
    Elf64_Xword st_size;  // offset: 0x10
}; // size: 0x18

struct exception_table_entry {
    int insn;  // offset: 0x0
    int fixup;  // offset: 0x4
}; // size: 0x8

struct export_operations {
    // Empty structure
}; // size: 0x1

struct fasync_struct {
    spinlock_t fa_lock;  // offset: 0x0
    int magic;  // offset: 0x4
    int fa_fd;  // offset: 0x8
    fasync_struct * fa_next;  // offset: 0x10
    file * fa_file;  // offset: 0x18
    callback_head fa_rcu;  // offset: 0x20
}; // size: 0x30

struct fault_env {
    vm_area_struct * vma;  // offset: 0x0
    ulong address;  // offset: 0x8
    uint flags;  // offset: 0x10
    pmd_t * pmd;  // offset: 0x18
    pte_t * pte;  // offset: 0x20
    spinlock_t * ptl;  // offset: 0x28
    pgtable_t prealloc_pte;  // offset: 0x30
}; // size: 0x38

struct fiemap_extent {
    __u64 fe_logical;  // offset: 0x0
    __u64 fe_physical;  // offset: 0x8
    __u64 fe_length;  // offset: 0x10
    __u64 fe_reserved64[2];  // offset: 0x18
    __u32 fe_flags;  // offset: 0x28
    __u32 fe_reserved[3];  // offset: 0x2c
}; // size: 0x38

struct fiemap_extent_info {
    uint fi_flags;  // offset: 0x0
    uint fi_extents_mapped;  // offset: 0x4
    uint fi_extents_max;  // offset: 0x8
    fiemap_extent * fi_extents_start;  // offset: 0x10
}; // size: 0x18

struct file {
    anon_union_16_2_834e7c5b_for_f_u f_u;  // offset: 0x0
    path f_path;  // offset: 0x10
    inode * f_inode;  // offset: 0x20
    file_operations * f_op;  // offset: 0x28
    spinlock_t f_lock;  // offset: 0x30
    atomic_long_t f_count;  // offset: 0x38
    uint f_flags;  // offset: 0x40
    fmode_t f_mode;  // offset: 0x44
    mutex f_pos_lock;  // offset: 0x48
    loff_t f_pos;  // offset: 0x70
    fown_struct f_owner;  // offset: 0x78
    cred * f_cred;  // offset: 0x98
    file_ra_state f_ra;  // offset: 0xa0
    u64 f_version;  // offset: 0xc0
    void * private_data;  // offset: 0xc8
    list_head f_ep_links;  // offset: 0xd0
    list_head f_tfile_llink;  // offset: 0xe0
    address_space * f_mapping;  // offset: 0xf0
}; // size: 0xf8

struct file_lock {
    file_lock * fl_next;  // offset: 0x0
    list_head fl_list;  // offset: 0x8
    hlist_node fl_link;  // offset: 0x18
    list_head fl_block;  // offset: 0x28
    fl_owner_t fl_owner;  // offset: 0x38
    uint fl_flags;  // offset: 0x40
    uchar fl_type;  // offset: 0x44
    uint fl_pid;  // offset: 0x48
    int fl_link_cpu;  // offset: 0x4c
    pid * fl_nspid;  // offset: 0x50
    wait_queue_head_t fl_wait;  // offset: 0x58
    file * fl_file;  // offset: 0x70
    loff_t fl_start;  // offset: 0x78
    loff_t fl_end;  // offset: 0x80
    fasync_struct * fl_fasync;  // offset: 0x88
    ulong fl_break_time;  // offset: 0x90
    ulong fl_downgrade_time;  // offset: 0x98
    file_lock_operations * fl_ops;  // offset: 0xa0
    lock_manager_operations * fl_lmops;  // offset: 0xa8
    anon_union_32_3_6ffd4daa_for_fl_u fl_u;  // offset: 0xb0
}; // size: 0xd0

struct file_lock_context {
    spinlock_t flc_lock;  // offset: 0x0
    list_head flc_flock;  // offset: 0x8
    list_head flc_posix;  // offset: 0x18
    list_head flc_lease;  // offset: 0x28
}; // size: 0x38

struct file_lock_operations {
    _func_void_file_lock_ptr_file_lock_ptr * fl_copy_lock;  // offset: 0x0
    _func_void_file_lock_ptr * fl_release_private;  // offset: 0x8
}; // size: 0x10

struct file_operations {
    module * owner;  // offset: 0x0
    _func_loff_t_file_ptr_loff_t_int * llseek;  // offset: 0x8
    _func_ssize_t_file_ptr_char_ptr_size_t_loff_t_ptr * read;  // offset: 0x10
    _func_ssize_t_file_ptr_char_ptr_size_t_loff_t_ptr * write;  // offset: 0x18
    _func_ssize_t_kiocb_ptr_iov_iter_ptr * read_iter;  // offset: 0x20
    _func_ssize_t_kiocb_ptr_iov_iter_ptr * write_iter;  // offset: 0x28
    _func_int_file_ptr_dir_context_ptr * iterate;  // offset: 0x30
    _func_int_file_ptr_dir_context_ptr * iterate_shared;  // offset: 0x38
    _func_uint_file_ptr_poll_table_struct_ptr * poll;  // offset: 0x40
    _func_long_file_ptr_uint_ulong * unlocked_ioctl;  // offset: 0x48
    _func_long_file_ptr_uint_ulong * compat_ioctl;  // offset: 0x50
    _func_int_file_ptr_vm_area_struct_ptr * mmap;  // offset: 0x58
    _func_int_inode_ptr_file_ptr * open;  // offset: 0x60
    _func_int_file_ptr_fl_owner_t * flush;  // offset: 0x68
    _func_int_inode_ptr_file_ptr * release;  // offset: 0x70
    _func_int_file_ptr_loff_t_loff_t_int * fsync;  // offset: 0x78
    _func_int_int_file_ptr_int * fasync;  // offset: 0x80
    _func_int_file_ptr_int_file_lock_ptr * lock;  // offset: 0x88
    _func_ssize_t_file_ptr_page_ptr_int_size_t_loff_t_ptr_int * sendpage;  // offset: 0x90
    _func_ulong_file_ptr_ulong_ulong_ulong_ulong * get_unmapped_area;  // offset: 0x98
    _func_int_int * check_flags;  // offset: 0xa0
    _func_int_file_ptr_int_file_lock_ptr * flock;  // offset: 0xa8
    _func_ssize_t_pipe_inode_info_ptr_file_ptr_loff_t_ptr_size_t_uint * splice_write;  // offset: 0xb0
    _func_ssize_t_file_ptr_loff_t_ptr_pipe_inode_info_ptr_size_t_uint * splice_read;  // offset: 0xb8
    _func_int_file_ptr_long_file_lock_ptr_ptr_void_ptr_ptr * setlease;  // offset: 0xc0
    _func_long_file_ptr_int_loff_t_loff_t * fallocate;  // offset: 0xc8
    _func_void_seq_file_ptr_file_ptr * show_fdinfo;  // offset: 0xd0
    _func_ssize_t_file_ptr_loff_t_file_ptr_loff_t_size_t_uint * copy_file_range;  // offset: 0xd8
    _func_int_file_ptr_loff_t_file_ptr_loff_t_u64 * clone_file_range;  // offset: 0xe0
    _func_ssize_t_file_ptr_u64_u64_file_ptr_u64 * dedupe_file_range;  // offset: 0xe8
}; // size: 0xf0

struct file_ra_state {
    ulong start;  // offset: 0x0
    uint size;  // offset: 0x8
    uint async_size;  // offset: 0xc
    uint ra_pages;  // offset: 0x10
    uint mmap_miss;  // offset: 0x14
    loff_t prev_pos;  // offset: 0x18
}; // size: 0x20

struct file_system_type {
    char * name;  // offset: 0x0
    int fs_flags;  // offset: 0x8
    _func_dentry_ptr_file_system_type_ptr_int_char_ptr_void_ptr * mount;  // offset: 0x10
    _func_void_super_block_ptr * kill_sb;  // offset: 0x18
    module * owner;  // offset: 0x20
    file_system_type * next;  // offset: 0x28
    hlist_head fs_supers;  // offset: 0x30
    lock_class_key i_mutex_dir_key;  // offset: 0x38
    lock_class_key i_mutex_key;  // offset: 0x38
    lock_class_key i_lock_key;  // offset: 0x38
    lock_class_key s_writers_key[0];  // offset: 0x38
    lock_class_key s_vfs_rename_key;  // offset: 0x38
    lock_class_key s_umount_key;  // offset: 0x38
    lock_class_key s_lock_key;  // offset: 0x38
}; // size: 0x38

struct files_stat_struct {
    ulong nr_files;  // offset: 0x0
    ulong nr_free_files;  // offset: 0x8
    ulong max_files;  // offset: 0x10
}; // size: 0x18

struct files_struct {
    // Empty structure
}; // size: 0x1

struct fown_struct {
    rwlock_t lock;  // offset: 0x0
    pid * pid;  // offset: 0x8
    pid_type pid_type;  // offset: 0x10
    kuid_t uid;  // offset: 0x14
    kuid_t euid;  // offset: 0x18
    int signum;  // offset: 0x1c
}; // size: 0x20

struct fpsimd_state {
    anon_union_528_2_afce2d22_for_fpsimd_state_0 field_0;  // offset: 0x0
    uint cpu;  // offset: 0x210
}; // size: 0x220

struct free_area {
    list_head free_list[6];  // offset: 0x0
    ulong nr_free;  // offset: 0x60
}; // size: 0x68

struct fs_struct {
    // Empty structure
}; // size: 0x1

struct fscrypt_operations {
    // Empty structure
}; // size: 0x1

struct futex_pi_state {
    // Empty structure
}; // size: 0x1

struct fwnode_handle {
    // Empty structure
}; // size: 0x1

struct gendisk {
    // Empty structure
}; // size: 0x1

struct group_info {
    atomic_t usage;  // offset: 0x0
    int ngroups;  // offset: 0x4
    kgid_t gid[0];  // offset: 0x8
}; // size: 0x8

struct hd_struct {
    // Empty structure
}; // size: 0x1

struct hlist_bl_head {
    hlist_bl_node * first;  // offset: 0x0
}; // size: 0x8

struct hlist_bl_node {
    hlist_bl_node * next;  // offset: 0x0
    hlist_bl_node * * pprev;  // offset: 0x8
}; // size: 0x10

struct hlist_head {
    hlist_node * first;  // offset: 0x0
}; // size: 0x8

struct hlist_node {
    hlist_node * next;  // offset: 0x0
    hlist_node * * pprev;  // offset: 0x8
}; // size: 0x10

struct hrtimer {
    timerqueue_node node;  // offset: 0x0
    ktime_t _softexpires;  // offset: 0x20
    _func_hrtimer_restart_hrtimer_ptr * function;  // offset: 0x28
    hrtimer_clock_base * base;  // offset: 0x30
    u8 state;  // offset: 0x38
    u8 is_rel;  // offset: 0x39
}; // size: 0x40

struct hrtimer_clock_base {
    hrtimer_cpu_base * cpu_base;  // offset: 0x0
    int index;  // offset: 0x8
    clockid_t clockid;  // offset: 0xc
    timerqueue_head active;  // offset: 0x10
    _func_ktime_t * get_time;  // offset: 0x20
    ktime_t offset;  // offset: 0x28
    undefined field_48;  // offset: 0x30
    undefined field_49;  // offset: 0x31
    undefined field_50;  // offset: 0x32
    undefined field_51;  // offset: 0x33
    undefined field_52;  // offset: 0x34
    undefined field_53;  // offset: 0x35
    undefined field_54;  // offset: 0x36
    undefined field_55;  // offset: 0x37
    undefined field_56;  // offset: 0x38
    undefined field_57;  // offset: 0x39
    undefined field_58;  // offset: 0x3a
    undefined field_59;  // offset: 0x3b
    undefined field_60;  // offset: 0x3c
    undefined field_61;  // offset: 0x3d
    undefined field_62;  // offset: 0x3e
    undefined field_63;  // offset: 0x3f
}; // size: 0x40

struct hrtimer_cpu_base {
    raw_spinlock_t lock;  // offset: 0x0
    seqcount_t seq;  // offset: 0x4
    hrtimer * running;  // offset: 0x8
    uint cpu;  // offset: 0x10
    uint active_bases;  // offset: 0x14
    uint clock_was_set_seq;  // offset: 0x18
    bool migration_enabled;  // offset: 0x1c
    bool nohz_active;  // offset: 0x1d
    uint:1 in_hrtirq;  // offset: 0x1e
    uint:1 hres_active;  // offset: 0x1e
    uint:1 hang_detected;  // offset: 0x1e
    undefined field_31;  // offset: 0x1f
    ktime_t expires_next;  // offset: 0x20
    hrtimer * next_timer;  // offset: 0x28
    uint nr_events;  // offset: 0x30
    uint nr_retries;  // offset: 0x34
    uint nr_hangs;  // offset: 0x38
    uint max_hang_time;  // offset: 0x3c
    hrtimer_clock_base clock_base[4];  // offset: 0x40
    undefined field_320;  // offset: 0x140
    undefined field_321;  // offset: 0x141
    undefined field_322;  // offset: 0x142
    undefined field_323;  // offset: 0x143
    undefined field_324;  // offset: 0x144
    undefined field_325;  // offset: 0x145
    undefined field_326;  // offset: 0x146
    undefined field_327;  // offset: 0x147
    undefined field_328;  // offset: 0x148
    undefined field_329;  // offset: 0x149
    undefined field_330;  // offset: 0x14a
    undefined field_331;  // offset: 0x14b
    undefined field_332;  // offset: 0x14c
    undefined field_333;  // offset: 0x14d
    undefined field_334;  // offset: 0x14e
    undefined field_335;  // offset: 0x14f
    undefined field_336;  // offset: 0x150
    undefined field_337;  // offset: 0x151
    undefined field_338;  // offset: 0x152
    undefined field_339;  // offset: 0x153
    undefined field_340;  // offset: 0x154
    undefined field_341;  // offset: 0x155
    undefined field_342;  // offset: 0x156
    undefined field_343;  // offset: 0x157
    undefined field_344;  // offset: 0x158
    undefined field_345;  // offset: 0x159
    undefined field_346;  // offset: 0x15a
    undefined field_347;  // offset: 0x15b
    undefined field_348;  // offset: 0x15c
    undefined field_349;  // offset: 0x15d
    undefined field_350;  // offset: 0x15e
    undefined field_351;  // offset: 0x15f
    undefined field_352;  // offset: 0x160
    undefined field_353;  // offset: 0x161
    undefined field_354;  // offset: 0x162
    undefined field_355;  // offset: 0x163
    undefined field_356;  // offset: 0x164
    undefined field_357;  // offset: 0x165
    undefined field_358;  // offset: 0x166
    undefined field_359;  // offset: 0x167
    undefined field_360;  // offset: 0x168
    undefined field_361;  // offset: 0x169
    undefined field_362;  // offset: 0x16a
    undefined field_363;  // offset: 0x16b
    undefined field_364;  // offset: 0x16c
    undefined field_365;  // offset: 0x16d
    undefined field_366;  // offset: 0x16e
    undefined field_367;  // offset: 0x16f
    undefined field_368;  // offset: 0x170
    undefined field_369;  // offset: 0x171
    undefined field_370;  // offset: 0x172
    undefined field_371;  // offset: 0x173
    undefined field_372;  // offset: 0x174
    undefined field_373;  // offset: 0x175
    undefined field_374;  // offset: 0x176
    undefined field_375;  // offset: 0x177
    undefined field_376;  // offset: 0x178
    undefined field_377;  // offset: 0x179
    undefined field_378;  // offset: 0x17a
    undefined field_379;  // offset: 0x17b
    undefined field_380;  // offset: 0x17c
    undefined field_381;  // offset: 0x17d
    undefined field_382;  // offset: 0x17e
    undefined field_383;  // offset: 0x17f
}; // size: 0x180

struct iattr {
    uint ia_valid;  // offset: 0x0
    umode_t ia_mode;  // offset: 0x4
    kuid_t ia_uid;  // offset: 0x8
    kgid_t ia_gid;  // offset: 0xc
    loff_t ia_size;  // offset: 0x10
    timespec ia_atime;  // offset: 0x18
    timespec ia_mtime;  // offset: 0x28
    timespec ia_ctime;  // offset: 0x38
    file * ia_file;  // offset: 0x48
}; // size: 0x50

struct ida {
    idr idr;  // offset: 0x0
    ida_bitmap * free_bitmap;  // offset: 0x28
}; // size: 0x30

struct ida_bitmap {
    long nr_busy;  // offset: 0x0
    ulong bitmap[15];  // offset: 0x8
}; // size: 0x80

struct idr {
    idr_layer * hint;  // offset: 0x0
    idr_layer * top;  // offset: 0x8
    int layers;  // offset: 0x10
    int cur;  // offset: 0x14
    spinlock_t lock;  // offset: 0x18
    int id_free_cnt;  // offset: 0x1c
    idr_layer * id_free;  // offset: 0x20
}; // size: 0x28

struct idr_layer {
    int prefix;  // offset: 0x0
    int layer;  // offset: 0x4
    idr_layer * ary[256];  // offset: 0x8
    int count;  // offset: 0x808
    anon_union_32_2_c44092ce_for_idr_layer_4 field_4;  // offset: 0x810
}; // size: 0x830

struct inode {
    umode_t i_mode;  // offset: 0x0
    ushort i_opflags;  // offset: 0x2
    kuid_t i_uid;  // offset: 0x4
    kgid_t i_gid;  // offset: 0x8
    uint i_flags;  // offset: 0xc
    posix_acl * i_acl;  // offset: 0x10
    posix_acl * i_default_acl;  // offset: 0x18
    inode_operations * i_op;  // offset: 0x20
    super_block * i_sb;  // offset: 0x28
    address_space * i_mapping;  // offset: 0x30
    ulong i_ino;  // offset: 0x38
    anon_union_4_2_26e7ee41_for_inode_11 field_11;  // offset: 0x40
    dev_t i_rdev;  // offset: 0x44
    loff_t i_size;  // offset: 0x48
    timespec i_atime;  // offset: 0x50
    timespec i_mtime;  // offset: 0x60
    timespec i_ctime;  // offset: 0x70
    spinlock_t i_lock;  // offset: 0x80
    ushort i_bytes;  // offset: 0x84
    uint i_blkbits;  // offset: 0x88
    blkcnt_t i_blocks;  // offset: 0x90
    ulong i_state;  // offset: 0x98
    rw_semaphore i_rwsem;  // offset: 0xa0
    ulong dirtied_when;  // offset: 0xc8
    ulong dirtied_time_when;  // offset: 0xd0
    hlist_node i_hash;  // offset: 0xd8
    list_head i_io_list;  // offset: 0xe8
    list_head i_lru;  // offset: 0xf8
    list_head i_sb_list;  // offset: 0x108
    list_head i_wb_list;  // offset: 0x118
    anon_union_16_2_76d55e2d_for_inode_30 field_30;  // offset: 0x128
    u64 i_version;  // offset: 0x138
    atomic_t i_count;  // offset: 0x140
    atomic_t i_dio_count;  // offset: 0x144
    atomic_t i_writecount;  // offset: 0x148
    file_operations * i_fop;  // offset: 0x150
    file_lock_context * i_flctx;  // offset: 0x158
    address_space i_data;  // offset: 0x160
    list_head i_devices;  // offset: 0x1f8
    anon_union_8_5_4efd96cc_for_inode_39 field_39;  // offset: 0x208
    __u32 i_generation;  // offset: 0x210
    __u32 i_fsnotify_mask;  // offset: 0x214
    hlist_head i_fsnotify_marks;  // offset: 0x218
    void * i_private;  // offset: 0x220
}; // size: 0x228

struct inode_operations {
    _func_dentry_ptr_inode_ptr_dentry_ptr_uint * lookup;  // offset: 0x0
    _func_char_ptr_dentry_ptr_inode_ptr_delayed_call_ptr * get_link;  // offset: 0x8
    _func_int_inode_ptr_int * permission;  // offset: 0x10
    _func_posix_acl_ptr_inode_ptr_int * get_acl;  // offset: 0x18
    _func_int_dentry_ptr_char_ptr_int * readlink;  // offset: 0x20
    _func_int_inode_ptr_dentry_ptr_umode_t_bool * create;  // offset: 0x28
    _func_int_dentry_ptr_inode_ptr_dentry_ptr * link;  // offset: 0x30
    _func_int_inode_ptr_dentry_ptr * unlink;  // offset: 0x38
    _func_int_inode_ptr_dentry_ptr_char_ptr * symlink;  // offset: 0x40
    _func_int_inode_ptr_dentry_ptr_umode_t * mkdir;  // offset: 0x48
    _func_int_inode_ptr_dentry_ptr * rmdir;  // offset: 0x50
    _func_int_inode_ptr_dentry_ptr_umode_t_dev_t * mknod;  // offset: 0x58
    _func_int_inode_ptr_dentry_ptr_inode_ptr_dentry_ptr_uint * rename;  // offset: 0x60
    _func_int_dentry_ptr_iattr_ptr * setattr;  // offset: 0x68
    _func_int_vfsmount_ptr_dentry_ptr_kstat_ptr * getattr;  // offset: 0x70
    _func_ssize_t_dentry_ptr_char_ptr_size_t * listxattr;  // offset: 0x78
    _func_int_inode_ptr_fiemap_extent_info_ptr_u64_u64 * fiemap;  // offset: 0x80
    _func_int_inode_ptr_timespec_ptr_int * update_time;  // offset: 0x88
    _func_int_inode_ptr_dentry_ptr_file_ptr_uint_umode_t_int_ptr * atomic_open;  // offset: 0x90
    _func_int_inode_ptr_dentry_ptr_umode_t * tmpfile;  // offset: 0x98
    _func_int_inode_ptr_posix_acl_ptr_int * set_acl;  // offset: 0xa0
    undefined field_168;  // offset: 0xa8
    undefined field_169;  // offset: 0xa9
    undefined field_170;  // offset: 0xaa
    undefined field_171;  // offset: 0xab
    undefined field_172;  // offset: 0xac
    undefined field_173;  // offset: 0xad
    undefined field_174;  // offset: 0xae
    undefined field_175;  // offset: 0xaf
    undefined field_176;  // offset: 0xb0
    undefined field_177;  // offset: 0xb1
    undefined field_178;  // offset: 0xb2
    undefined field_179;  // offset: 0xb3
    undefined field_180;  // offset: 0xb4
    undefined field_181;  // offset: 0xb5
    undefined field_182;  // offset: 0xb6
    undefined field_183;  // offset: 0xb7
    undefined field_184;  // offset: 0xb8
    undefined field_185;  // offset: 0xb9
    undefined field_186;  // offset: 0xba
    undefined field_187;  // offset: 0xbb
    undefined field_188;  // offset: 0xbc
    undefined field_189;  // offset: 0xbd
    undefined field_190;  // offset: 0xbe
    undefined field_191;  // offset: 0xbf
    undefined field_192;  // offset: 0xc0
    undefined field_193;  // offset: 0xc1
    undefined field_194;  // offset: 0xc2
    undefined field_195;  // offset: 0xc3
    undefined field_196;  // offset: 0xc4
    undefined field_197;  // offset: 0xc5
    undefined field_198;  // offset: 0xc6
    undefined field_199;  // offset: 0xc7
    undefined field_200;  // offset: 0xc8
    undefined field_201;  // offset: 0xc9
    undefined field_202;  // offset: 0xca
    undefined field_203;  // offset: 0xcb
    undefined field_204;  // offset: 0xcc
    undefined field_205;  // offset: 0xcd
    undefined field_206;  // offset: 0xce
    undefined field_207;  // offset: 0xcf
    undefined field_208;  // offset: 0xd0
    undefined field_209;  // offset: 0xd1
    undefined field_210;  // offset: 0xd2
    undefined field_211;  // offset: 0xd3
    undefined field_212;  // offset: 0xd4
    undefined field_213;  // offset: 0xd5
    undefined field_214;  // offset: 0xd6
    undefined field_215;  // offset: 0xd7
    undefined field_216;  // offset: 0xd8
    undefined field_217;  // offset: 0xd9
    undefined field_218;  // offset: 0xda
    undefined field_219;  // offset: 0xdb
    undefined field_220;  // offset: 0xdc
    undefined field_221;  // offset: 0xdd
    undefined field_222;  // offset: 0xde
    undefined field_223;  // offset: 0xdf
    undefined field_224;  // offset: 0xe0
    undefined field_225;  // offset: 0xe1
    undefined field_226;  // offset: 0xe2
    undefined field_227;  // offset: 0xe3
    undefined field_228;  // offset: 0xe4
    undefined field_229;  // offset: 0xe5
    undefined field_230;  // offset: 0xe6
    undefined field_231;  // offset: 0xe7
    undefined field_232;  // offset: 0xe8
    undefined field_233;  // offset: 0xe9
    undefined field_234;  // offset: 0xea
    undefined field_235;  // offset: 0xeb
    undefined field_236;  // offset: 0xec
    undefined field_237;  // offset: 0xed
    undefined field_238;  // offset: 0xee
    undefined field_239;  // offset: 0xef
    undefined field_240;  // offset: 0xf0
    undefined field_241;  // offset: 0xf1
    undefined field_242;  // offset: 0xf2
    undefined field_243;  // offset: 0xf3
    undefined field_244;  // offset: 0xf4
    undefined field_245;  // offset: 0xf5
    undefined field_246;  // offset: 0xf6
    undefined field_247;  // offset: 0xf7
    undefined field_248;  // offset: 0xf8
    undefined field_249;  // offset: 0xf9
    undefined field_250;  // offset: 0xfa
    undefined field_251;  // offset: 0xfb
    undefined field_252;  // offset: 0xfc
    undefined field_253;  // offset: 0xfd
    undefined field_254;  // offset: 0xfe
    undefined field_255;  // offset: 0xff
}; // size: 0x100

struct inodes_stat_t {
    long nr_inodes;  // offset: 0x0
    long nr_unused;  // offset: 0x8
    long dummy[5];  // offset: 0x10
}; // size: 0x38

struct io_context {
    // Empty structure
}; // size: 0x1

struct iommu_fwspec {
    // Empty structure
}; // size: 0x1

struct iommu_group {
    // Empty structure
}; // size: 0x1

struct iommu_ops {
    // Empty structure
}; // size: 0x1

struct iov_iter {
    // Empty structure
}; // size: 0x1

struct k_sigaction {
    sigaction sa;  // offset: 0x0
}; // size: 0x20

struct kernel_cap_struct {
    __u32 cap[2];  // offset: 0x0
}; // size: 0x8

struct kernel_param {
    char * name;  // offset: 0x0
    module * mod;  // offset: 0x8
    kernel_param_ops * ops;  // offset: 0x10
    u16 perm;  // offset: 0x18
    s8 level;  // offset: 0x1a
    u8 flags;  // offset: 0x1b
    anon_union_8_3_eb4d9846_for_kernel_param_6 field_6;  // offset: 0x20
}; // size: 0x28

struct kernel_param_ops {
    uint flags;  // offset: 0x0
    _func_int_char_ptr_kernel_param_ptr * set;  // offset: 0x8
    _func_int_char_ptr_kernel_param_ptr * get;  // offset: 0x10
    _func_void_void_ptr * free;  // offset: 0x18
}; // size: 0x20

struct kernel_symbol {
    ulong value;  // offset: 0x0
    char * name;  // offset: 0x8
}; // size: 0x10

struct kernfs_elem_attr {
    kernfs_ops * ops;  // offset: 0x0
    kernfs_open_node * open;  // offset: 0x8
    loff_t size;  // offset: 0x10
    kernfs_node * notify_next;  // offset: 0x18
}; // size: 0x20

struct kernfs_elem_dir {
    ulong subdirs;  // offset: 0x0
    rb_root children;  // offset: 0x8
    kernfs_root * root;  // offset: 0x10
}; // size: 0x18

struct kernfs_elem_symlink {
    kernfs_node * target_kn;  // offset: 0x0
}; // size: 0x8

struct kernfs_iattrs {
    // Empty structure
}; // size: 0x1

struct kernfs_node {
    atomic_t count;  // offset: 0x0
    atomic_t active;  // offset: 0x4
    kernfs_node * parent;  // offset: 0x8
    char * name;  // offset: 0x10
    rb_node rb;  // offset: 0x18
    void * ns;  // offset: 0x30
    uint hash;  // offset: 0x38
    anon_union_32_3_f2422723_for_kernfs_node_7 field_7;  // offset: 0x40
    void * priv;  // offset: 0x60
    ushort flags;  // offset: 0x68
    umode_t mode;  // offset: 0x6a
    uint ino;  // offset: 0x6c
    kernfs_iattrs * iattr;  // offset: 0x70
}; // size: 0x78

struct kernfs_open_file {
    kernfs_node * kn;  // offset: 0x0
    file * file;  // offset: 0x8
    void * priv;  // offset: 0x10
    mutex mutex;  // offset: 0x18
    mutex prealloc_mutex;  // offset: 0x40
    int event;  // offset: 0x68
    list_head list;  // offset: 0x70
    char * prealloc_buf;  // offset: 0x80
    size_t atomic_write_len;  // offset: 0x88
    bool mmapped;  // offset: 0x90
    vm_operations_struct * vm_ops;  // offset: 0x98
}; // size: 0xa0

struct kernfs_open_node {
    // Empty structure
}; // size: 0x1

struct kernfs_ops {
    _func_int_seq_file_ptr_void_ptr * seq_show;  // offset: 0x0
    _func_void_ptr_seq_file_ptr_loff_t_ptr * seq_start;  // offset: 0x8
    _func_void_ptr_seq_file_ptr_void_ptr_loff_t_ptr * seq_next;  // offset: 0x10
    _func_void_seq_file_ptr_void_ptr * seq_stop;  // offset: 0x18
    _func_ssize_t_kernfs_open_file_ptr_char_ptr_size_t_loff_t * read;  // offset: 0x20
    size_t atomic_write_len;  // offset: 0x28
    bool prealloc;  // offset: 0x30
    _func_ssize_t_kernfs_open_file_ptr_char_ptr_size_t_loff_t * write;  // offset: 0x38
    _func_int_kernfs_open_file_ptr_vm_area_struct_ptr * mmap;  // offset: 0x40
}; // size: 0x48

struct kernfs_root {
    kernfs_node * kn;  // offset: 0x0
    uint flags;  // offset: 0x8
    ida ino_ida;  // offset: 0x10
    kernfs_syscall_ops * syscall_ops;  // offset: 0x40
    list_head supers;  // offset: 0x48
    wait_queue_head_t deactivate_waitq;  // offset: 0x58
}; // size: 0x70

struct kernfs_syscall_ops {
    _func_int_kernfs_root_ptr_int_ptr_char_ptr * remount_fs;  // offset: 0x0
    _func_int_seq_file_ptr_kernfs_root_ptr * show_options;  // offset: 0x8
    _func_int_kernfs_node_ptr_char_ptr_umode_t * mkdir;  // offset: 0x10
    _func_int_kernfs_node_ptr * rmdir;  // offset: 0x18
    _func_int_kernfs_node_ptr_kernfs_node_ptr_char_ptr * rename;  // offset: 0x20
    _func_int_seq_file_ptr_kernfs_node_ptr_kernfs_root_ptr * show_path;  // offset: 0x28
}; // size: 0x30

struct key {
    atomic_t usage;  // offset: 0x0
    key_serial_t serial;  // offset: 0x4
    anon_union_24_2_0d98eaf6_for_key_2 field_2;  // offset: 0x8
    rw_semaphore sem;  // offset: 0x20
    key_user * user;  // offset: 0x48
    void * security;  // offset: 0x50
    anon_union_8_2_a8706ac2_for_key_6 field_6;  // offset: 0x58
    time_t last_used_at;  // offset: 0x60
    kuid_t uid;  // offset: 0x68
    kgid_t gid;  // offset: 0x6c
    key_perm_t perm;  // offset: 0x70
    ushort quotalen;  // offset: 0x74
    ushort datalen;  // offset: 0x76
    ulong flags;  // offset: 0x78
    anon_union_24_2_a31149a9_for_key_14 field_14;  // offset: 0x80
    anon_union_32_3_ecfb39e2_for_key_15 field_15;  // offset: 0x98
    _func_int_key_ptr_key_type_ptr_key_payload_ptr * restrict_link;  // offset: 0xb8
}; // size: 0xc0

struct key_type {
    // Empty structure
}; // size: 0x1

struct key_user {
    // Empty structure
}; // size: 0x1

struct keyring_index_key {
    key_type * type;  // offset: 0x0
    char * description;  // offset: 0x8
    size_t desc_len;  // offset: 0x10
}; // size: 0x18

struct kgid_t {
    gid_t val;  // offset: 0x0
}; // size: 0x4

struct kiocb {
    file * ki_filp;  // offset: 0x0
    loff_t ki_pos;  // offset: 0x8
    _func_void_kiocb_ptr_long_long * ki_complete;  // offset: 0x10
    void * private;  // offset: 0x18
    int ki_flags;  // offset: 0x20
}; // size: 0x28

struct kioctx_table {
    // Empty structure
}; // size: 0x1

struct klist_node {
    void * n_klist;  // offset: 0x0
    list_head n_node;  // offset: 0x8
    kref n_ref;  // offset: 0x18
}; // size: 0x20

struct kmem_cache {
    // Empty structure
}; // size: 0x1

struct kobj_attribute {
    attribute attr;  // offset: 0x0
    _func_ssize_t_kobject_ptr_kobj_attribute_ptr_char_ptr * show;  // offset: 0x10
    _func_ssize_t_kobject_ptr_kobj_attribute_ptr_char_ptr_size_t * store;  // offset: 0x18
}; // size: 0x20

struct kobj_ns_type_operations {
    kobj_ns_type type;  // offset: 0x0
    _func_bool * current_may_mount;  // offset: 0x8
    _func_void_ptr * grab_current_ns;  // offset: 0x10
    _func_void_ptr_sock_ptr * netlink_ns;  // offset: 0x18
    _func_void_ptr * initial_ns;  // offset: 0x20
    _func_void_void_ptr * drop_ns;  // offset: 0x28
}; // size: 0x30

struct kobj_type {
    _func_void_kobject_ptr * release;  // offset: 0x0
    sysfs_ops * sysfs_ops;  // offset: 0x8
    attribute * * default_attrs;  // offset: 0x10
    _func_kobj_ns_type_operations_ptr_kobject_ptr * child_ns_type;  // offset: 0x18
    _func_void_ptr_kobject_ptr * namespace;  // offset: 0x20
}; // size: 0x28

struct kobj_uevent_env {
    char * argv[3];  // offset: 0x0
    char * envp[32];  // offset: 0x18
    int envp_idx;  // offset: 0x118
    char buf[2048];  // offset: 0x11c
    int buflen;  // offset: 0x91c
}; // size: 0x920

struct kobject {
    char * name;  // offset: 0x0
    list_head entry;  // offset: 0x8
    kobject * parent;  // offset: 0x18
    kset * kset;  // offset: 0x20
    kobj_type * ktype;  // offset: 0x28
    kernfs_node * sd;  // offset: 0x30
    kref kref;  // offset: 0x38
    uint:1 state_initialized;  // offset: 0x3c
    uint:1 state_in_sysfs;  // offset: 0x3c
    uint:1 state_add_uevent_sent;  // offset: 0x3c
    uint:1 state_remove_uevent_sent;  // offset: 0x3c
    uint:1 uevent_suppress;  // offset: 0x3c
}; // size: 0x40

struct kparam_array {
    uint max;  // offset: 0x0
    uint elemsize;  // offset: 0x4
    uint * num;  // offset: 0x8
    kernel_param_ops * ops;  // offset: 0x10
    void * elem;  // offset: 0x18
}; // size: 0x20

struct kparam_string {
    uint maxlen;  // offset: 0x0
    char * string;  // offset: 0x8
}; // size: 0x10

struct kprojid_t {
    projid_t val;  // offset: 0x0
}; // size: 0x4

struct kqid {
    anon_union_4_3_d2ff16bc_for_kqid_0 field_0;  // offset: 0x0
    quota_type type;  // offset: 0x4
}; // size: 0x8

struct kref {
    atomic_t refcount;  // offset: 0x0
}; // size: 0x4

struct kset {
    list_head list;  // offset: 0x0
    spinlock_t list_lock;  // offset: 0x10
    undefined field_20;  // offset: 0x14
    undefined field_21;  // offset: 0x15
    undefined field_22;  // offset: 0x16
    undefined field_23;  // offset: 0x17
    kobject kobj;  // offset: 0x18
    kset_uevent_ops * uevent_ops;  // offset: 0x58
}; // size: 0x60

struct kset_uevent_ops {
    _func_int_kset_ptr_kobject_ptr * filter;  // offset: 0x0
    _func_char_ptr_kset_ptr_kobject_ptr * name;  // offset: 0x8
    _func_int_kset_ptr_kobject_ptr_kobj_uevent_env_ptr * uevent;  // offset: 0x10
}; // size: 0x18

struct kstat {
    u64 ino;  // offset: 0x0
    dev_t dev;  // offset: 0x8
    umode_t mode;  // offset: 0xc
    uint nlink;  // offset: 0x10
    kuid_t uid;  // offset: 0x14
    kgid_t gid;  // offset: 0x18
    dev_t rdev;  // offset: 0x1c
    loff_t size;  // offset: 0x20
    timespec atime;  // offset: 0x28
    timespec mtime;  // offset: 0x38
    timespec ctime;  // offset: 0x48
    ulong blksize;  // offset: 0x58
    ulonglong blocks;  // offset: 0x60
}; // size: 0x68

struct kstatfs {
    // Empty structure
}; // size: 0x1

struct kuid_t {
    uid_t val;  // offset: 0x0
}; // size: 0x4

struct latch_tree_node {
    rb_node node[2];  // offset: 0x0
}; // size: 0x30

struct linux_binfmt {
    // Empty structure
}; // size: 0x1

struct list_head {
    list_head * next;  // offset: 0x0
    list_head * prev;  // offset: 0x8
}; // size: 0x10

struct list_lru {
    list_lru_node * node;  // offset: 0x0
}; // size: 0x8

struct list_lru_node {
    spinlock_t lock;  // offset: 0x0
    undefined field_4;  // offset: 0x4
    undefined field_5;  // offset: 0x5
    undefined field_6;  // offset: 0x6
    undefined field_7;  // offset: 0x7
    list_lru_one lru;  // offset: 0x8
    undefined field_32;  // offset: 0x20
    undefined field_33;  // offset: 0x21
    undefined field_34;  // offset: 0x22
    undefined field_35;  // offset: 0x23
    undefined field_36;  // offset: 0x24
    undefined field_37;  // offset: 0x25
    undefined field_38;  // offset: 0x26
    undefined field_39;  // offset: 0x27
    undefined field_40;  // offset: 0x28
    undefined field_41;  // offset: 0x29
    undefined field_42;  // offset: 0x2a
    undefined field_43;  // offset: 0x2b
    undefined field_44;  // offset: 0x2c
    undefined field_45;  // offset: 0x2d
    undefined field_46;  // offset: 0x2e
    undefined field_47;  // offset: 0x2f
    undefined field_48;  // offset: 0x30
    undefined field_49;  // offset: 0x31
    undefined field_50;  // offset: 0x32
    undefined field_51;  // offset: 0x33
    undefined field_52;  // offset: 0x34
    undefined field_53;  // offset: 0x35
    undefined field_54;  // offset: 0x36
    undefined field_55;  // offset: 0x37
    undefined field_56;  // offset: 0x38
    undefined field_57;  // offset: 0x39
    undefined field_58;  // offset: 0x3a
    undefined field_59;  // offset: 0x3b
    undefined field_60;  // offset: 0x3c
    undefined field_61;  // offset: 0x3d
    undefined field_62;  // offset: 0x3e
    undefined field_63;  // offset: 0x3f
    undefined field_64;  // offset: 0x40
    undefined field_65;  // offset: 0x41
    undefined field_66;  // offset: 0x42
    undefined field_67;  // offset: 0x43
    undefined field_68;  // offset: 0x44
    undefined field_69;  // offset: 0x45
    undefined field_70;  // offset: 0x46
    undefined field_71;  // offset: 0x47
    undefined field_72;  // offset: 0x48
    undefined field_73;  // offset: 0x49
    undefined field_74;  // offset: 0x4a
    undefined field_75;  // offset: 0x4b
    undefined field_76;  // offset: 0x4c
    undefined field_77;  // offset: 0x4d
    undefined field_78;  // offset: 0x4e
    undefined field_79;  // offset: 0x4f
    undefined field_80;  // offset: 0x50
    undefined field_81;  // offset: 0x51
    undefined field_82;  // offset: 0x52
    undefined field_83;  // offset: 0x53
    undefined field_84;  // offset: 0x54
    undefined field_85;  // offset: 0x55
    undefined field_86;  // offset: 0x56
    undefined field_87;  // offset: 0x57
    undefined field_88;  // offset: 0x58
    undefined field_89;  // offset: 0x59
    undefined field_90;  // offset: 0x5a
    undefined field_91;  // offset: 0x5b
    undefined field_92;  // offset: 0x5c
    undefined field_93;  // offset: 0x5d
    undefined field_94;  // offset: 0x5e
    undefined field_95;  // offset: 0x5f
    undefined field_96;  // offset: 0x60
    undefined field_97;  // offset: 0x61
    undefined field_98;  // offset: 0x62
    undefined field_99;  // offset: 0x63
    undefined field_100;  // offset: 0x64
    undefined field_101;  // offset: 0x65
    undefined field_102;  // offset: 0x66
    undefined field_103;  // offset: 0x67
    undefined field_104;  // offset: 0x68
    undefined field_105;  // offset: 0x69
    undefined field_106;  // offset: 0x6a
    undefined field_107;  // offset: 0x6b
    undefined field_108;  // offset: 0x6c
    undefined field_109;  // offset: 0x6d
    undefined field_110;  // offset: 0x6e
    undefined field_111;  // offset: 0x6f
    undefined field_112;  // offset: 0x70
    undefined field_113;  // offset: 0x71
    undefined field_114;  // offset: 0x72
    undefined field_115;  // offset: 0x73
    undefined field_116;  // offset: 0x74
    undefined field_117;  // offset: 0x75
    undefined field_118;  // offset: 0x76
    undefined field_119;  // offset: 0x77
    undefined field_120;  // offset: 0x78
    undefined field_121;  // offset: 0x79
    undefined field_122;  // offset: 0x7a
    undefined field_123;  // offset: 0x7b
    undefined field_124;  // offset: 0x7c
    undefined field_125;  // offset: 0x7d
    undefined field_126;  // offset: 0x7e
    undefined field_127;  // offset: 0x7f
}; // size: 0x80

struct list_lru_one {
    list_head list;  // offset: 0x0
    long nr_items;  // offset: 0x10
}; // size: 0x18

struct llist_node {
    llist_node * next;  // offset: 0x0
}; // size: 0x8

struct load_weight {
    ulong weight;  // offset: 0x0
    u32 inv_weight;  // offset: 0x8
}; // size: 0x10

struct lock_class_key {
    // Empty structure
}; // size: 0x1

struct lock_manager_operations {
    _func_int_file_lock_ptr_file_lock_ptr * lm_compare_owner;  // offset: 0x0
    _func_ulong_file_lock_ptr * lm_owner_key;  // offset: 0x8
    _func_fl_owner_t_fl_owner_t * lm_get_owner;  // offset: 0x10
    _func_void_fl_owner_t * lm_put_owner;  // offset: 0x18
    _func_void_file_lock_ptr * lm_notify;  // offset: 0x20
    _func_int_file_lock_ptr_int * lm_grant;  // offset: 0x28
    _func_bool_file_lock_ptr * lm_break;  // offset: 0x30
    _func_int_file_lock_ptr_int_list_head_ptr * lm_change;  // offset: 0x38
    _func_void_file_lock_ptr_void_ptr_ptr * lm_setup;  // offset: 0x40
}; // size: 0x48

struct lockref {
    anon_union_8_2_a3c87c50_for_lockref_0 field_0;  // offset: 0x0
}; // size: 0x8

struct lruvec {
    list_head lists[5];  // offset: 0x0
    zone_reclaim_stat reclaim_stat;  // offset: 0x50
    atomic_long_t inactive_age;  // offset: 0x70
}; // size: 0x78

struct mem_cgroup {
    // Empty structure
}; // size: 0x1

struct mem_dqblk {
    qsize_t dqb_bhardlimit;  // offset: 0x0
    qsize_t dqb_bsoftlimit;  // offset: 0x8
    qsize_t dqb_curspace;  // offset: 0x10
    qsize_t dqb_rsvspace;  // offset: 0x18
    qsize_t dqb_ihardlimit;  // offset: 0x20
    qsize_t dqb_isoftlimit;  // offset: 0x28
    qsize_t dqb_curinodes;  // offset: 0x30
    time64_t dqb_btime;  // offset: 0x38
    time64_t dqb_itime;  // offset: 0x40
}; // size: 0x48

struct mem_dqinfo {
    quota_format_type * dqi_format;  // offset: 0x0
    int dqi_fmt_id;  // offset: 0x8
    list_head dqi_dirty_list;  // offset: 0x10
    ulong dqi_flags;  // offset: 0x20
    uint dqi_bgrace;  // offset: 0x28
    uint dqi_igrace;  // offset: 0x2c
    qsize_t dqi_max_spc_limit;  // offset: 0x30
    qsize_t dqi_max_ino_limit;  // offset: 0x38
    void * dqi_priv;  // offset: 0x40
}; // size: 0x48

struct mem_section {
    ulong section_mem_map;  // offset: 0x0
    ulong * pageblock_flags;  // offset: 0x8
}; // size: 0x10

struct miscdevice {
    int minor;  // offset: 0x0
    char * name;  // offset: 0x8
    file_operations * fops;  // offset: 0x10
    list_head list;  // offset: 0x18
    device * parent;  // offset: 0x28
    device * this_device;  // offset: 0x30
    attribute_group * * groups;  // offset: 0x38
    char * nodename;  // offset: 0x40
    umode_t mode;  // offset: 0x48
}; // size: 0x50

struct mm_context_t {
    atomic64_t id;  // offset: 0x0
    void * vdso;  // offset: 0x8
}; // size: 0x10

struct mm_rss_stat {
    atomic_long_t count[4];  // offset: 0x0
}; // size: 0x20

struct mm_struct {
    vm_area_struct * mmap;  // offset: 0x0
    rb_root mm_rb;  // offset: 0x8
    u32 vmacache_seqnum;  // offset: 0x10
    _func_ulong_file_ptr_ulong_ulong_ulong_ulong * get_unmapped_area;  // offset: 0x18
    ulong mmap_base;  // offset: 0x20
    ulong mmap_legacy_base;  // offset: 0x28
    ulong task_size;  // offset: 0x30
    ulong highest_vm_end;  // offset: 0x38
    pgd_t * pgd;  // offset: 0x40
    atomic_t mm_users;  // offset: 0x48
    atomic_t mm_count;  // offset: 0x4c
    atomic_long_t nr_ptes;  // offset: 0x50
    atomic_long_t nr_pmds;  // offset: 0x58
    int map_count;  // offset: 0x60
    spinlock_t page_table_lock;  // offset: 0x64
    rw_semaphore mmap_sem;  // offset: 0x68
    list_head mmlist;  // offset: 0x90
    ulong hiwater_rss;  // offset: 0xa0
    ulong hiwater_vm;  // offset: 0xa8
    ulong total_vm;  // offset: 0xb0
    ulong locked_vm;  // offset: 0xb8
    ulong pinned_vm;  // offset: 0xc0
    ulong data_vm;  // offset: 0xc8
    ulong exec_vm;  // offset: 0xd0
    ulong stack_vm;  // offset: 0xd8
    ulong def_flags;  // offset: 0xe0
    ulong start_code;  // offset: 0xe8
    ulong end_code;  // offset: 0xf0
    ulong start_data;  // offset: 0xf8
    ulong end_data;  // offset: 0x100
    ulong start_brk;  // offset: 0x108
    ulong brk;  // offset: 0x110
    ulong start_stack;  // offset: 0x118
    ulong arg_start;  // offset: 0x120
    ulong arg_end;  // offset: 0x128
    ulong env_start;  // offset: 0x130
    ulong env_end;  // offset: 0x138
    ulong saved_auxv[44];  // offset: 0x140
    mm_rss_stat rss_stat;  // offset: 0x2a0
    linux_binfmt * binfmt;  // offset: 0x2c0
    cpumask_var_t cpu_vm_mask_var;  // offset: 0x2c8
    mm_context_t context;  // offset: 0x2d0
    ulong flags;  // offset: 0x2e0
    core_state * core_state;  // offset: 0x2e8
    spinlock_t ioctx_lock;  // offset: 0x2f0
    kioctx_table * ioctx_table;  // offset: 0x2f8
    file * exe_file;  // offset: 0x300
    pgtable_t pmd_huge_pte;  // offset: 0x308
    bool tlb_flush_pending;  // offset: 0x310
    uprobes_state uprobes_state;  // offset: 0x311
    atomic_long_t hugetlb_usage;  // offset: 0x318
    work_struct async_put_work;  // offset: 0x320
}; // size: 0x340

struct mod_arch_specific {
    // Empty structure
}; // size: 0x1

struct mod_kallsyms {
    Elf64_Sym * symtab;  // offset: 0x0
    uint num_symtab;  // offset: 0x8
    char * strtab;  // offset: 0x10
}; // size: 0x18

struct mod_tree_node {
    module * mod;  // offset: 0x0
    latch_tree_node node;  // offset: 0x8
}; // size: 0x38

struct module {
    module_state state;  // offset: 0x0
    undefined field_4;  // offset: 0x4
    undefined field_5;  // offset: 0x5
    undefined field_6;  // offset: 0x6
    undefined field_7;  // offset: 0x7
    list_head list;  // offset: 0x8
    char name[56];  // offset: 0x18
    module_kobject mkobj;  // offset: 0x50
    module_attribute * modinfo_attrs;  // offset: 0xb0
    char * version;  // offset: 0xb8
    char * srcversion;  // offset: 0xc0
    kobject * holders_dir;  // offset: 0xc8
    kernel_symbol * syms;  // offset: 0xd0
    ulong * crcs;  // offset: 0xd8
    uint num_syms;  // offset: 0xe0
    undefined field_228;  // offset: 0xe4
    undefined field_229;  // offset: 0xe5
    undefined field_230;  // offset: 0xe6
    undefined field_231;  // offset: 0xe7
    mutex param_lock;  // offset: 0xe8
    kernel_param * kp;  // offset: 0x110
    uint num_kp;  // offset: 0x118
    uint num_gpl_syms;  // offset: 0x11c
    kernel_symbol * gpl_syms;  // offset: 0x120
    ulong * gpl_crcs;  // offset: 0x128
    bool async_probe_requested;  // offset: 0x130
    undefined field_305;  // offset: 0x131
    undefined field_306;  // offset: 0x132
    undefined field_307;  // offset: 0x133
    undefined field_308;  // offset: 0x134
    undefined field_309;  // offset: 0x135
    undefined field_310;  // offset: 0x136
    undefined field_311;  // offset: 0x137
    kernel_symbol * gpl_future_syms;  // offset: 0x138
    ulong * gpl_future_crcs;  // offset: 0x140
    uint num_gpl_future_syms;  // offset: 0x148
    uint num_exentries;  // offset: 0x14c
    exception_table_entry * extable;  // offset: 0x150
    _func_int * init;  // offset: 0x158
    undefined field_352;  // offset: 0x160
    undefined field_353;  // offset: 0x161
    undefined field_354;  // offset: 0x162
    undefined field_355;  // offset: 0x163
    undefined field_356;  // offset: 0x164
    undefined field_357;  // offset: 0x165
    undefined field_358;  // offset: 0x166
    undefined field_359;  // offset: 0x167
    undefined field_360;  // offset: 0x168
    undefined field_361;  // offset: 0x169
    undefined field_362;  // offset: 0x16a
    undefined field_363;  // offset: 0x16b
    undefined field_364;  // offset: 0x16c
    undefined field_365;  // offset: 0x16d
    undefined field_366;  // offset: 0x16e
    undefined field_367;  // offset: 0x16f
    undefined field_368;  // offset: 0x170
    undefined field_369;  // offset: 0x171
    undefined field_370;  // offset: 0x172
    undefined field_371;  // offset: 0x173
    undefined field_372;  // offset: 0x174
    undefined field_373;  // offset: 0x175
    undefined field_374;  // offset: 0x176
    undefined field_375;  // offset: 0x177
    undefined field_376;  // offset: 0x178
    undefined field_377;  // offset: 0x179
    undefined field_378;  // offset: 0x17a
    undefined field_379;  // offset: 0x17b
    undefined field_380;  // offset: 0x17c
    undefined field_381;  // offset: 0x17d
    undefined field_382;  // offset: 0x17e
    undefined field_383;  // offset: 0x17f
    module_layout core_layout;  // offset: 0x180
    module_layout init_layout;  // offset: 0x1d0
    mod_arch_specific arch;  // offset: 0x220
    uint taints;  // offset: 0x220
    uint num_bugs;  // offset: 0x224
    list_head bug_list;  // offset: 0x228
    bug_entry * bug_table;  // offset: 0x238
    mod_kallsyms * kallsyms;  // offset: 0x240
    mod_kallsyms core_kallsyms;  // offset: 0x248
    module_sect_attrs * sect_attrs;  // offset: 0x260
    module_notes_attrs * notes_attrs;  // offset: 0x268
    char * args;  // offset: 0x270
    void * percpu;  // offset: 0x278
    uint percpu_size;  // offset: 0x280
    undefined field_644;  // offset: 0x284
    undefined field_645;  // offset: 0x285
    undefined field_646;  // offset: 0x286
    undefined field_647;  // offset: 0x287
    list_head source_list;  // offset: 0x288
    list_head target_list;  // offset: 0x298
    __restorefn_t * exit;  // offset: 0x2a8
    atomic_t refcnt;  // offset: 0x2b0
    undefined field_692;  // offset: 0x2b4
    undefined field_693;  // offset: 0x2b5
    undefined field_694;  // offset: 0x2b6
    undefined field_695;  // offset: 0x2b7
    undefined field_696;  // offset: 0x2b8
    undefined field_697;  // offset: 0x2b9
    undefined field_698;  // offset: 0x2ba
    undefined field_699;  // offset: 0x2bb
    undefined field_700;  // offset: 0x2bc
    undefined field_701;  // offset: 0x2bd
    undefined field_702;  // offset: 0x2be
    undefined field_703;  // offset: 0x2bf
    undefined field_704;  // offset: 0x2c0
    undefined field_705;  // offset: 0x2c1
    undefined field_706;  // offset: 0x2c2
    undefined field_707;  // offset: 0x2c3
    undefined field_708;  // offset: 0x2c4
    undefined field_709;  // offset: 0x2c5
    undefined field_710;  // offset: 0x2c6
    undefined field_711;  // offset: 0x2c7
    undefined field_712;  // offset: 0x2c8
    undefined field_713;  // offset: 0x2c9
    undefined field_714;  // offset: 0x2ca
    undefined field_715;  // offset: 0x2cb
    undefined field_716;  // offset: 0x2cc
    undefined field_717;  // offset: 0x2cd
    undefined field_718;  // offset: 0x2ce
    undefined field_719;  // offset: 0x2cf
    undefined field_720;  // offset: 0x2d0
    undefined field_721;  // offset: 0x2d1
    undefined field_722;  // offset: 0x2d2
    undefined field_723;  // offset: 0x2d3
    undefined field_724;  // offset: 0x2d4
    undefined field_725;  // offset: 0x2d5
    undefined field_726;  // offset: 0x2d6
    undefined field_727;  // offset: 0x2d7
    undefined field_728;  // offset: 0x2d8
    undefined field_729;  // offset: 0x2d9
    undefined field_730;  // offset: 0x2da
    undefined field_731;  // offset: 0x2db
    undefined field_732;  // offset: 0x2dc
    undefined field_733;  // offset: 0x2dd
    undefined field_734;  // offset: 0x2de
    undefined field_735;  // offset: 0x2df
    undefined field_736;  // offset: 0x2e0
    undefined field_737;  // offset: 0x2e1
    undefined field_738;  // offset: 0x2e2
    undefined field_739;  // offset: 0x2e3
    undefined field_740;  // offset: 0x2e4
    undefined field_741;  // offset: 0x2e5
    undefined field_742;  // offset: 0x2e6
    undefined field_743;  // offset: 0x2e7
    undefined field_744;  // offset: 0x2e8
    undefined field_745;  // offset: 0x2e9
    undefined field_746;  // offset: 0x2ea
    undefined field_747;  // offset: 0x2eb
    undefined field_748;  // offset: 0x2ec
    undefined field_749;  // offset: 0x2ed
    undefined field_750;  // offset: 0x2ee
    undefined field_751;  // offset: 0x2ef
    undefined field_752;  // offset: 0x2f0
    undefined field_753;  // offset: 0x2f1
    undefined field_754;  // offset: 0x2f2
    undefined field_755;  // offset: 0x2f3
    undefined field_756;  // offset: 0x2f4
    undefined field_757;  // offset: 0x2f5
    undefined field_758;  // offset: 0x2f6
    undefined field_759;  // offset: 0x2f7
    undefined field_760;  // offset: 0x2f8
    undefined field_761;  // offset: 0x2f9
    undefined field_762;  // offset: 0x2fa
    undefined field_763;  // offset: 0x2fb
    undefined field_764;  // offset: 0x2fc
    undefined field_765;  // offset: 0x2fd
    undefined field_766;  // offset: 0x2fe
    undefined field_767;  // offset: 0x2ff
}; // size: 0x300

struct module_attribute {
    attribute attr;  // offset: 0x0
    _func_ssize_t_module_attribute_ptr_module_kobject_ptr_char_ptr * show;  // offset: 0x10
    _func_ssize_t_module_attribute_ptr_module_kobject_ptr_char_ptr_size_t * store;  // offset: 0x18
    _func_void_module_ptr_char_ptr * setup;  // offset: 0x20
    _func_int_module_ptr * test;  // offset: 0x28
    _func_void_module_ptr * free;  // offset: 0x30
}; // size: 0x38

struct module_kobject {
    kobject kobj;  // offset: 0x0
    module * mod;  // offset: 0x40
    kobject * drivers_dir;  // offset: 0x48
    module_param_attrs * mp;  // offset: 0x50
    completion * kobj_completion;  // offset: 0x58
}; // size: 0x60

struct module_layout {
    void * base;  // offset: 0x0
    uint size;  // offset: 0x8
    uint text_size;  // offset: 0xc
    uint ro_size;  // offset: 0x10
    uint ro_after_init_size;  // offset: 0x14
    mod_tree_node mtn;  // offset: 0x18
}; // size: 0x50

struct module_notes_attrs {
    // Empty structure
}; // size: 0x1

struct module_param_attrs {
    // Empty structure
}; // size: 0x1

struct module_sect_attrs {
    // Empty structure
}; // size: 0x1

struct mtd_info {
    // Empty structure
}; // size: 0x1

struct mutex {
    atomic_t count;  // offset: 0x0
    spinlock_t wait_lock;  // offset: 0x4
    list_head wait_list;  // offset: 0x8
    task_struct * owner;  // offset: 0x18
    optimistic_spin_queue osq;  // offset: 0x20
}; // size: 0x28

struct nameidata {
    // Empty structure
}; // size: 0x1

struct nfs4_lock_info {
    nfs4_lock_state * owner;  // offset: 0x0
}; // size: 0x8

struct nfs4_lock_state {
    // Empty structure
}; // size: 0x1

struct nfs_lock_info {
    u32 state;  // offset: 0x0
    nlm_lockowner * owner;  // offset: 0x8
    list_head list;  // offset: 0x10
}; // size: 0x20

struct nlm_lockowner {
    // Empty structure
}; // size: 0x1

struct nodemask_t {
    ulong bits[1];  // offset: 0x0
}; // size: 0x8

struct notifier_block {
    notifier_fn_t notifier_call;  // offset: 0x0
    notifier_block * next;  // offset: 0x8
    int priority;  // offset: 0x10
}; // size: 0x18

struct nsproxy {
    // Empty structure
}; // size: 0x1

struct of_device_id {
    // Empty structure
}; // size: 0x1

struct optimistic_spin_queue {
    atomic_t tail;  // offset: 0x0
}; // size: 0x4

struct pacct_struct {
    int ac_flag;  // offset: 0x0
    long ac_exitcode;  // offset: 0x8
    ulong ac_mem;  // offset: 0x10
    cputime_t ac_utime;  // offset: 0x18
    cputime_t ac_stime;  // offset: 0x20
    ulong ac_minflt;  // offset: 0x28
    ulong ac_majflt;  // offset: 0x30
}; // size: 0x38

struct page {
    ulong flags;  // offset: 0x0
    anon_union_8_3_e8ad8e82_for_page_1 field_1;  // offset: 0x8
    anon_union_8_2_a48a124b_for_page_2 field_2;  // offset: 0x10
    anon_union_8_2_8f55150c_for_page_3 field_3;  // offset: 0x18
    anon_union_16_5_86b83ece_for_page_4 field_4;  // offset: 0x20
    anon_union_8_3_6c3dd376_for_page_5 field_5;  // offset: 0x30
}; // size: 0x38

struct page_ext_operations {
    size_t offset;  // offset: 0x0
    size_t size;  // offset: 0x8
    _func_bool * need;  // offset: 0x10
    __restorefn_t * init;  // offset: 0x18
}; // size: 0x20

struct page_frag {
    page * page;  // offset: 0x0
    __u32 offset;  // offset: 0x8
    __u32 size;  // offset: 0xc
}; // size: 0x10

struct path {
    vfsmount * mnt;  // offset: 0x0
    dentry * dentry;  // offset: 0x8
}; // size: 0x10

struct per_cpu_nodestat {
    s8 stat_threshold;  // offset: 0x0
    s8 vm_node_stat_diff[26];  // offset: 0x1
}; // size: 0x1b

struct per_cpu_pages {
    int count;  // offset: 0x0
    int high;  // offset: 0x4
    int batch;  // offset: 0x8
    list_head lists[3];  // offset: 0x10
}; // size: 0x40

struct per_cpu_pageset {
    per_cpu_pages pcp;  // offset: 0x0
    s8 stat_threshold;  // offset: 0x40
    s8 vm_stat_diff[14];  // offset: 0x41
}; // size: 0x50

struct percpu_counter {
    raw_spinlock_t lock;  // offset: 0x0
    s64 count;  // offset: 0x8
    list_head list;  // offset: 0x10
    s32 * counters;  // offset: 0x20
}; // size: 0x28

struct percpu_ref {
    atomic_long_t count;  // offset: 0x0
    ulong percpu_count_ptr;  // offset: 0x8
    percpu_ref_func_t * release;  // offset: 0x10
    percpu_ref_func_t * confirm_switch;  // offset: 0x18
    bool:1 force_atomic;  // offset: 0x20
    callback_head rcu;  // offset: 0x28
}; // size: 0x38

struct percpu_rw_semaphore {
    rcu_sync rss;  // offset: 0x0
    uint * read_count;  // offset: 0x40
    rw_semaphore rw_sem;  // offset: 0x48
    wait_queue_head_t writer;  // offset: 0x70
    int readers_block;  // offset: 0x88
}; // size: 0x90

struct perf_event {
    // Empty structure
}; // size: 0x1

struct perf_event_context {
    // Empty structure
}; // size: 0x1

struct pgd_t {
    pgdval_t pgd;  // offset: 0x0
}; // size: 0x8

struct pglist_data {
    zone node_zones[3];  // offset: 0x0
    zonelist node_zonelists[1];  // offset: 0x1380
    int nr_zones;  // offset: 0x13c0
    undefined field_5060;  // offset: 0x13c4
    undefined field_5061;  // offset: 0x13c5
    undefined field_5062;  // offset: 0x13c6
    undefined field_5063;  // offset: 0x13c7
    ulong node_start_pfn;  // offset: 0x13c8
    ulong node_present_pages;  // offset: 0x13d0
    ulong node_spanned_pages;  // offset: 0x13d8
    int node_id;  // offset: 0x13e0
    undefined field_5092;  // offset: 0x13e4
    undefined field_5093;  // offset: 0x13e5
    undefined field_5094;  // offset: 0x13e6
    undefined field_5095;  // offset: 0x13e7
    wait_queue_head_t kswapd_wait;  // offset: 0x13e8
    wait_queue_head_t pfmemalloc_wait;  // offset: 0x1400
    task_struct * kswapd;  // offset: 0x1418
    int kswapd_order;  // offset: 0x1420
    zone_type kswapd_classzone_idx;  // offset: 0x1424
    int kcompactd_max_order;  // offset: 0x1428
    zone_type kcompactd_classzone_idx;  // offset: 0x142c
    wait_queue_head_t kcompactd_wait;  // offset: 0x1430
    task_struct * kcompactd;  // offset: 0x1448
    ulong totalreserve_pages;  // offset: 0x1450
    undefined field_5208;  // offset: 0x1458
    undefined field_5209;  // offset: 0x1459
    undefined field_5210;  // offset: 0x145a
    undefined field_5211;  // offset: 0x145b
    undefined field_5212;  // offset: 0x145c
    undefined field_5213;  // offset: 0x145d
    undefined field_5214;  // offset: 0x145e
    undefined field_5215;  // offset: 0x145f
    undefined field_5216;  // offset: 0x1460
    undefined field_5217;  // offset: 0x1461
    undefined field_5218;  // offset: 0x1462
    undefined field_5219;  // offset: 0x1463
    undefined field_5220;  // offset: 0x1464
    undefined field_5221;  // offset: 0x1465
    undefined field_5222;  // offset: 0x1466
    undefined field_5223;  // offset: 0x1467
    undefined field_5224;  // offset: 0x1468
    undefined field_5225;  // offset: 0x1469
    undefined field_5226;  // offset: 0x146a
    undefined field_5227;  // offset: 0x146b
    undefined field_5228;  // offset: 0x146c
    undefined field_5229;  // offset: 0x146d
    undefined field_5230;  // offset: 0x146e
    undefined field_5231;  // offset: 0x146f
    undefined field_5232;  // offset: 0x1470
    undefined field_5233;  // offset: 0x1471
    undefined field_5234;  // offset: 0x1472
    undefined field_5235;  // offset: 0x1473
    undefined field_5236;  // offset: 0x1474
    undefined field_5237;  // offset: 0x1475
    undefined field_5238;  // offset: 0x1476
    undefined field_5239;  // offset: 0x1477
    undefined field_5240;  // offset: 0x1478
    undefined field_5241;  // offset: 0x1479
    undefined field_5242;  // offset: 0x147a
    undefined field_5243;  // offset: 0x147b
    undefined field_5244;  // offset: 0x147c
    undefined field_5245;  // offset: 0x147d
    undefined field_5246;  // offset: 0x147e
    undefined field_5247;  // offset: 0x147f
    zone_padding _pad1_;  // offset: 0x1480
    spinlock_t lru_lock;  // offset: 0x1480
    spinlock_t split_queue_lock;  // offset: 0x1484
    list_head split_queue;  // offset: 0x1488
    ulong split_queue_len;  // offset: 0x1498
    lruvec lruvec;  // offset: 0x14a0
    uint inactive_ratio;  // offset: 0x1518
    undefined field_5404;  // offset: 0x151c
    undefined field_5405;  // offset: 0x151d
    undefined field_5406;  // offset: 0x151e
    undefined field_5407;  // offset: 0x151f
    ulong flags;  // offset: 0x1520
    undefined field_5416;  // offset: 0x1528
    undefined field_5417;  // offset: 0x1529
    undefined field_5418;  // offset: 0x152a
    undefined field_5419;  // offset: 0x152b
    undefined field_5420;  // offset: 0x152c
    undefined field_5421;  // offset: 0x152d
    undefined field_5422;  // offset: 0x152e
    undefined field_5423;  // offset: 0x152f
    undefined field_5424;  // offset: 0x1530
    undefined field_5425;  // offset: 0x1531
    undefined field_5426;  // offset: 0x1532
    undefined field_5427;  // offset: 0x1533
    undefined field_5428;  // offset: 0x1534
    undefined field_5429;  // offset: 0x1535
    undefined field_5430;  // offset: 0x1536
    undefined field_5431;  // offset: 0x1537
    undefined field_5432;  // offset: 0x1538
    undefined field_5433;  // offset: 0x1539
    undefined field_5434;  // offset: 0x153a
    undefined field_5435;  // offset: 0x153b
    undefined field_5436;  // offset: 0x153c
    undefined field_5437;  // offset: 0x153d
    undefined field_5438;  // offset: 0x153e
    undefined field_5439;  // offset: 0x153f
    undefined field_5440;  // offset: 0x1540
    undefined field_5441;  // offset: 0x1541
    undefined field_5442;  // offset: 0x1542
    undefined field_5443;  // offset: 0x1543
    undefined field_5444;  // offset: 0x1544
    undefined field_5445;  // offset: 0x1545
    undefined field_5446;  // offset: 0x1546
    undefined field_5447;  // offset: 0x1547
    undefined field_5448;  // offset: 0x1548
    undefined field_5449;  // offset: 0x1549
    undefined field_5450;  // offset: 0x154a
    undefined field_5451;  // offset: 0x154b
    undefined field_5452;  // offset: 0x154c
    undefined field_5453;  // offset: 0x154d
    undefined field_5454;  // offset: 0x154e
    undefined field_5455;  // offset: 0x154f
    undefined field_5456;  // offset: 0x1550
    undefined field_5457;  // offset: 0x1551
    undefined field_5458;  // offset: 0x1552
    undefined field_5459;  // offset: 0x1553
    undefined field_5460;  // offset: 0x1554
    undefined field_5461;  // offset: 0x1555
    undefined field_5462;  // offset: 0x1556
    undefined field_5463;  // offset: 0x1557
    undefined field_5464;  // offset: 0x1558
    undefined field_5465;  // offset: 0x1559
    undefined field_5466;  // offset: 0x155a
    undefined field_5467;  // offset: 0x155b
    undefined field_5468;  // offset: 0x155c
    undefined field_5469;  // offset: 0x155d
    undefined field_5470;  // offset: 0x155e
    undefined field_5471;  // offset: 0x155f
    undefined field_5472;  // offset: 0x1560
    undefined field_5473;  // offset: 0x1561
    undefined field_5474;  // offset: 0x1562
    undefined field_5475;  // offset: 0x1563
    undefined field_5476;  // offset: 0x1564
    undefined field_5477;  // offset: 0x1565
    undefined field_5478;  // offset: 0x1566
    undefined field_5479;  // offset: 0x1567
    undefined field_5480;  // offset: 0x1568
    undefined field_5481;  // offset: 0x1569
    undefined field_5482;  // offset: 0x156a
    undefined field_5483;  // offset: 0x156b
    undefined field_5484;  // offset: 0x156c
    undefined field_5485;  // offset: 0x156d
    undefined field_5486;  // offset: 0x156e
    undefined field_5487;  // offset: 0x156f
    undefined field_5488;  // offset: 0x1570
    undefined field_5489;  // offset: 0x1571
    undefined field_5490;  // offset: 0x1572
    undefined field_5491;  // offset: 0x1573
    undefined field_5492;  // offset: 0x1574
    undefined field_5493;  // offset: 0x1575
    undefined field_5494;  // offset: 0x1576
    undefined field_5495;  // offset: 0x1577
    undefined field_5496;  // offset: 0x1578
    undefined field_5497;  // offset: 0x1579
    undefined field_5498;  // offset: 0x157a
    undefined field_5499;  // offset: 0x157b
    undefined field_5500;  // offset: 0x157c
    undefined field_5501;  // offset: 0x157d
    undefined field_5502;  // offset: 0x157e
    undefined field_5503;  // offset: 0x157f
    zone_padding _pad2_;  // offset: 0x1580
    per_cpu_nodestat * per_cpu_nodestats;  // offset: 0x1580
    atomic_long_t vm_stat[26];  // offset: 0x1588
    undefined field_5720;  // offset: 0x1658
    undefined field_5721;  // offset: 0x1659
    undefined field_5722;  // offset: 0x165a
    undefined field_5723;  // offset: 0x165b
    undefined field_5724;  // offset: 0x165c
    undefined field_5725;  // offset: 0x165d
    undefined field_5726;  // offset: 0x165e
    undefined field_5727;  // offset: 0x165f
    undefined field_5728;  // offset: 0x1660
    undefined field_5729;  // offset: 0x1661
    undefined field_5730;  // offset: 0x1662
    undefined field_5731;  // offset: 0x1663
    undefined field_5732;  // offset: 0x1664
    undefined field_5733;  // offset: 0x1665
    undefined field_5734;  // offset: 0x1666
    undefined field_5735;  // offset: 0x1667
    undefined field_5736;  // offset: 0x1668
    undefined field_5737;  // offset: 0x1669
    undefined field_5738;  // offset: 0x166a
    undefined field_5739;  // offset: 0x166b
    undefined field_5740;  // offset: 0x166c
    undefined field_5741;  // offset: 0x166d
    undefined field_5742;  // offset: 0x166e
    undefined field_5743;  // offset: 0x166f
    undefined field_5744;  // offset: 0x1670
    undefined field_5745;  // offset: 0x1671
    undefined field_5746;  // offset: 0x1672
    undefined field_5747;  // offset: 0x1673
    undefined field_5748;  // offset: 0x1674
    undefined field_5749;  // offset: 0x1675
    undefined field_5750;  // offset: 0x1676
    undefined field_5751;  // offset: 0x1677
    undefined field_5752;  // offset: 0x1678
    undefined field_5753;  // offset: 0x1679
    undefined field_5754;  // offset: 0x167a
    undefined field_5755;  // offset: 0x167b
    undefined field_5756;  // offset: 0x167c
    undefined field_5757;  // offset: 0x167d
    undefined field_5758;  // offset: 0x167e
    undefined field_5759;  // offset: 0x167f
}; // size: 0x1680

struct pgprot_t {
    pteval_t pgprot;  // offset: 0x0
}; // size: 0x8

struct pid {
    atomic_t count;  // offset: 0x0
    uint level;  // offset: 0x4
    hlist_head tasks[3];  // offset: 0x8
    callback_head rcu;  // offset: 0x20
    upid numbers[1];  // offset: 0x30
}; // size: 0x50

struct pid_link {
    hlist_node node;  // offset: 0x0
    pid * pid;  // offset: 0x10
}; // size: 0x18

struct pid_namespace {
    // Empty structure
}; // size: 0x1

struct pinctrl {
    // Empty structure
}; // size: 0x1

struct pinctrl_state {
    // Empty structure
}; // size: 0x1

struct pipe_inode_info {
    // Empty structure
}; // size: 0x1

struct plist_node {
    int prio;  // offset: 0x0
    list_head prio_list;  // offset: 0x8
    list_head node_list;  // offset: 0x18
}; // size: 0x28

struct pm_domain_data {
    // Empty structure
}; // size: 0x1

struct pm_message {
    int event;  // offset: 0x0
}; // size: 0x4

struct pm_subsys_data {
    spinlock_t lock;  // offset: 0x0
    uint refcount;  // offset: 0x4
    list_head clock_list;  // offset: 0x8
    pm_domain_data * domain_data;  // offset: 0x18
}; // size: 0x20

struct pmd_t {
    pmdval_t pmd;  // offset: 0x0
}; // size: 0x8

struct poll_table_struct {
    // Empty structure
}; // size: 0x1

struct pollfd {
    // Empty structure
}; // size: 0x1

struct posix_acl {
    // Empty structure
}; // size: 0x1

struct prev_cputime {
    cputime_t utime;  // offset: 0x0
    cputime_t stime;  // offset: 0x8
    raw_spinlock_t lock;  // offset: 0x10
}; // size: 0x18

struct pte_t {
    pteval_t pte;  // offset: 0x0
}; // size: 0x8

struct pvclock_vcpu_time_info {
    u32 version;  // offset: 0x0
    u32 pad0;  // offset: 0x4
    u64 tsc_timestamp;  // offset: 0x8
    u64 system_time;  // offset: 0x10
    u32 tsc_to_system_mul;  // offset: 0x18
    s8 tsc_shift;  // offset: 0x1c
    u8 flags;  // offset: 0x1d
    u8 pad[2];  // offset: 0x1e
}; // size: 0x20

struct pvclock_wall_clock {
    u32 version;  // offset: 0x0
    u32 sec;  // offset: 0x4
    u32 nsec;  // offset: 0x8
    u32 sec_hi;  // offset: 0xc
}; // size: 0x10

struct qc_dqblk {
    int d_fieldmask;  // offset: 0x0
    u64 d_spc_hardlimit;  // offset: 0x8
    u64 d_spc_softlimit;  // offset: 0x10
    u64 d_ino_hardlimit;  // offset: 0x18
    u64 d_ino_softlimit;  // offset: 0x20
    u64 d_space;  // offset: 0x28
    u64 d_ino_count;  // offset: 0x30
    s64 d_ino_timer;  // offset: 0x38
    s64 d_spc_timer;  // offset: 0x40
    int d_ino_warns;  // offset: 0x48
    int d_spc_warns;  // offset: 0x4c
    u64 d_rt_spc_hardlimit;  // offset: 0x50
    u64 d_rt_spc_softlimit;  // offset: 0x58
    u64 d_rt_space;  // offset: 0x60
    s64 d_rt_spc_timer;  // offset: 0x68
    int d_rt_spc_warns;  // offset: 0x70
}; // size: 0x78

struct qc_info {
    int i_fieldmask;  // offset: 0x0
    uint i_flags;  // offset: 0x4
    uint i_spc_timelimit;  // offset: 0x8
    uint i_ino_timelimit;  // offset: 0xc
    uint i_rt_spc_timelimit;  // offset: 0x10
    uint i_spc_warnlimit;  // offset: 0x14
    uint i_ino_warnlimit;  // offset: 0x18
    uint i_rt_spc_warnlimit;  // offset: 0x1c
}; // size: 0x20

struct qc_state {
    uint s_incoredqs;  // offset: 0x0
    qc_type_state s_state[3];  // offset: 0x8
}; // size: 0xb0

struct qc_type_state {
    uint flags;  // offset: 0x0
    uint spc_timelimit;  // offset: 0x4
    uint ino_timelimit;  // offset: 0x8
    uint rt_spc_timelimit;  // offset: 0xc
    uint spc_warnlimit;  // offset: 0x10
    uint ino_warnlimit;  // offset: 0x14
    uint rt_spc_warnlimit;  // offset: 0x18
    ulonglong ino;  // offset: 0x20
    blkcnt_t blocks;  // offset: 0x28
    blkcnt_t nextents;  // offset: 0x30
}; // size: 0x38

struct qstr {
    anon_union_8_2_ae5c065a_for_qstr_0 field_0;  // offset: 0x0
    uchar * name;  // offset: 0x8
}; // size: 0x10

struct quota_format_ops {
    _func_int_super_block_ptr_int * check_quota_file;  // offset: 0x0
    _func_int_super_block_ptr_int * read_file_info;  // offset: 0x8
    _func_int_super_block_ptr_int * write_file_info;  // offset: 0x10
    _func_int_super_block_ptr_int * free_file_info;  // offset: 0x18
    _func_int_dquot_ptr * read_dqblk;  // offset: 0x20
    _func_int_dquot_ptr * commit_dqblk;  // offset: 0x28
    _func_int_dquot_ptr * release_dqblk;  // offset: 0x30
    _func_int_super_block_ptr_kqid_ptr * get_next_id;  // offset: 0x38
}; // size: 0x40

struct quota_format_type {
    int qf_fmt_id;  // offset: 0x0
    quota_format_ops * qf_ops;  // offset: 0x8
    module * qf_owner;  // offset: 0x10
    quota_format_type * qf_next;  // offset: 0x18
}; // size: 0x20

struct quota_info {
    uint flags;  // offset: 0x0
    undefined field_4;  // offset: 0x4
    undefined field_5;  // offset: 0x5
    undefined field_6;  // offset: 0x6
    undefined field_7;  // offset: 0x7
    mutex dqio_mutex;  // offset: 0x8
    mutex dqonoff_mutex;  // offset: 0x30
    inode * files[3];  // offset: 0x58
    mem_dqinfo info[3];  // offset: 0x70
    quota_format_ops * ops[3];  // offset: 0x148
}; // size: 0x160

struct quotactl_ops {
    _func_int_super_block_ptr_int_int_path_ptr * quota_on;  // offset: 0x0
    _func_int_super_block_ptr_int * quota_off;  // offset: 0x8
    _func_int_super_block_ptr_uint * quota_enable;  // offset: 0x10
    _func_int_super_block_ptr_uint * quota_disable;  // offset: 0x18
    _func_int_super_block_ptr_int * quota_sync;  // offset: 0x20
    _func_int_super_block_ptr_int_qc_info_ptr * set_info;  // offset: 0x28
    _func_int_super_block_ptr_kqid_qc_dqblk_ptr * get_dqblk;  // offset: 0x30
    _func_int_super_block_ptr_kqid_ptr_qc_dqblk_ptr * get_nextdqblk;  // offset: 0x38
    _func_int_super_block_ptr_kqid_qc_dqblk_ptr * set_dqblk;  // offset: 0x40
    _func_int_super_block_ptr_qc_state_ptr * get_state;  // offset: 0x48
    _func_int_super_block_ptr_uint * rm_xquota;  // offset: 0x50
}; // size: 0x58

struct radix_tree_node {
    uchar shift;  // offset: 0x0
    uchar offset;  // offset: 0x1
    uint count;  // offset: 0x4
    anon_union_16_2_0496ad32_for_radix_tree_node_3 field_3;  // offset: 0x8
    list_head private_list;  // offset: 0x18
    void * slots[64];  // offset: 0x28
    ulong[1] tags[3];  // offset: 0x228
}; // size: 0x240

struct radix_tree_root {
    gfp_t gfp_mask;  // offset: 0x0
    radix_tree_node * rnode;  // offset: 0x8
}; // size: 0x10

struct ratelimit_state {
    raw_spinlock_t lock;  // offset: 0x0
    int interval;  // offset: 0x4
    int burst;  // offset: 0x8
    int printed;  // offset: 0xc
    int missed;  // offset: 0x10
    ulong begin;  // offset: 0x18
    ulong flags;  // offset: 0x20
}; // size: 0x28

struct raw_spinlock {
    arch_spinlock_t raw_lock;  // offset: 0x0
}; // size: 0x4

struct rb_node {
    ulong __rb_parent_color;  // offset: 0x0
    rb_node * rb_right;  // offset: 0x8
    rb_node * rb_left;  // offset: 0x10
}; // size: 0x18

struct rb_root {
    rb_node * rb_node;  // offset: 0x0
}; // size: 0x8

struct rcu_sync {
    int gp_state;  // offset: 0x0
    int gp_count;  // offset: 0x4
    wait_queue_head_t gp_wait;  // offset: 0x8
    int cb_state;  // offset: 0x20
    callback_head cb_head;  // offset: 0x28
    rcu_sync_type gp_type;  // offset: 0x38
}; // size: 0x40

struct reclaim_state {
    // Empty structure
}; // size: 0x1

struct request_queue {
    // Empty structure
}; // size: 0x1

struct resource {
    resource_size_t start;  // offset: 0x0
    resource_size_t end;  // offset: 0x8
    char * name;  // offset: 0x10
    ulong flags;  // offset: 0x18
    ulong desc;  // offset: 0x20
    resource * parent;  // offset: 0x28
    resource * sibling;  // offset: 0x30
    resource * child;  // offset: 0x38
}; // size: 0x40

struct restart_block {
    _func_long_restart_block_ptr * fn;  // offset: 0x0
    anon_union_40_3_0ec87412_for_restart_block_1 field_1;  // offset: 0x8
}; // size: 0x30

struct rlimit {
    __kernel_ulong_t rlim_cur;  // offset: 0x0
    __kernel_ulong_t rlim_max;  // offset: 0x8
}; // size: 0x10

struct robust_list_head {
    // Empty structure
}; // size: 0x1

struct rt_mutex_waiter {
    // Empty structure
}; // size: 0x1

struct rw_semaphore {
    atomic_long_t count;  // offset: 0x0
    list_head wait_list;  // offset: 0x8
    raw_spinlock_t wait_lock;  // offset: 0x18
    optimistic_spin_queue osq;  // offset: 0x1c
    task_struct * owner;  // offset: 0x20
}; // size: 0x28

struct rwlock_t {
    arch_rwlock_t raw_lock;  // offset: 0x0
}; // size: 0x4

struct sb_writers {
    int frozen;  // offset: 0x0
    wait_queue_head_t wait_unfrozen;  // offset: 0x8
    percpu_rw_semaphore rw_sem[3];  // offset: 0x20
}; // size: 0x1d0

struct sched_avg {
    u64 last_update_time;  // offset: 0x0
    u64 load_sum;  // offset: 0x8
    u32 util_sum;  // offset: 0x10
    u32 period_contrib;  // offset: 0x14
    ulong load_avg;  // offset: 0x18
    ulong util_avg;  // offset: 0x20
}; // size: 0x28

struct sched_class {
    // Empty structure
}; // size: 0x1

struct sched_dl_entity {
    rb_node rb_node;  // offset: 0x0
    u64 dl_runtime;  // offset: 0x18
    u64 dl_deadline;  // offset: 0x20
    u64 dl_period;  // offset: 0x28
    u64 dl_bw;  // offset: 0x30
    s64 runtime;  // offset: 0x38
    u64 deadline;  // offset: 0x40
    uint flags;  // offset: 0x48
    int dl_throttled;  // offset: 0x4c
    int dl_boosted;  // offset: 0x50
    int dl_yielded;  // offset: 0x54
    hrtimer dl_timer;  // offset: 0x58
}; // size: 0x98

struct sched_entity {
    load_weight load;  // offset: 0x0
    rb_node run_node;  // offset: 0x10
    list_head group_node;  // offset: 0x28
    uint on_rq;  // offset: 0x38
    undefined field_60;  // offset: 0x3c
    undefined field_61;  // offset: 0x3d
    undefined field_62;  // offset: 0x3e
    undefined field_63;  // offset: 0x3f
    u64 exec_start;  // offset: 0x40
    u64 sum_exec_runtime;  // offset: 0x48
    u64 vruntime;  // offset: 0x50
    u64 prev_sum_exec_runtime;  // offset: 0x58
    u64 nr_migrations;  // offset: 0x60
    undefined field_104;  // offset: 0x68
    undefined field_105;  // offset: 0x69
    undefined field_106;  // offset: 0x6a
    undefined field_107;  // offset: 0x6b
    undefined field_108;  // offset: 0x6c
    undefined field_109;  // offset: 0x6d
    undefined field_110;  // offset: 0x6e
    undefined field_111;  // offset: 0x6f
    undefined field_112;  // offset: 0x70
    undefined field_113;  // offset: 0x71
    undefined field_114;  // offset: 0x72
    undefined field_115;  // offset: 0x73
    undefined field_116;  // offset: 0x74
    undefined field_117;  // offset: 0x75
    undefined field_118;  // offset: 0x76
    undefined field_119;  // offset: 0x77
    undefined field_120;  // offset: 0x78
    undefined field_121;  // offset: 0x79
    undefined field_122;  // offset: 0x7a
    undefined field_123;  // offset: 0x7b
    undefined field_124;  // offset: 0x7c
    undefined field_125;  // offset: 0x7d
    undefined field_126;  // offset: 0x7e
    undefined field_127;  // offset: 0x7f
    sched_avg avg;  // offset: 0x80
    undefined field_168;  // offset: 0xa8
    undefined field_169;  // offset: 0xa9
    undefined field_170;  // offset: 0xaa
    undefined field_171;  // offset: 0xab
    undefined field_172;  // offset: 0xac
    undefined field_173;  // offset: 0xad
    undefined field_174;  // offset: 0xae
    undefined field_175;  // offset: 0xaf
    undefined field_176;  // offset: 0xb0
    undefined field_177;  // offset: 0xb1
    undefined field_178;  // offset: 0xb2
    undefined field_179;  // offset: 0xb3
    undefined field_180;  // offset: 0xb4
    undefined field_181;  // offset: 0xb5
    undefined field_182;  // offset: 0xb6
    undefined field_183;  // offset: 0xb7
    undefined field_184;  // offset: 0xb8
    undefined field_185;  // offset: 0xb9
    undefined field_186;  // offset: 0xba
    undefined field_187;  // offset: 0xbb
    undefined field_188;  // offset: 0xbc
    undefined field_189;  // offset: 0xbd
    undefined field_190;  // offset: 0xbe
    undefined field_191;  // offset: 0xbf
    undefined field_192;  // offset: 0xc0
    undefined field_193;  // offset: 0xc1
    undefined field_194;  // offset: 0xc2
    undefined field_195;  // offset: 0xc3
    undefined field_196;  // offset: 0xc4
    undefined field_197;  // offset: 0xc5
    undefined field_198;  // offset: 0xc6
    undefined field_199;  // offset: 0xc7
    undefined field_200;  // offset: 0xc8
    undefined field_201;  // offset: 0xc9
    undefined field_202;  // offset: 0xca
    undefined field_203;  // offset: 0xcb
    undefined field_204;  // offset: 0xcc
    undefined field_205;  // offset: 0xcd
    undefined field_206;  // offset: 0xce
    undefined field_207;  // offset: 0xcf
    undefined field_208;  // offset: 0xd0
    undefined field_209;  // offset: 0xd1
    undefined field_210;  // offset: 0xd2
    undefined field_211;  // offset: 0xd3
    undefined field_212;  // offset: 0xd4
    undefined field_213;  // offset: 0xd5
    undefined field_214;  // offset: 0xd6
    undefined field_215;  // offset: 0xd7
    undefined field_216;  // offset: 0xd8
    undefined field_217;  // offset: 0xd9
    undefined field_218;  // offset: 0xda
    undefined field_219;  // offset: 0xdb
    undefined field_220;  // offset: 0xdc
    undefined field_221;  // offset: 0xdd
    undefined field_222;  // offset: 0xde
    undefined field_223;  // offset: 0xdf
    undefined field_224;  // offset: 0xe0
    undefined field_225;  // offset: 0xe1
    undefined field_226;  // offset: 0xe2
    undefined field_227;  // offset: 0xe3
    undefined field_228;  // offset: 0xe4
    undefined field_229;  // offset: 0xe5
    undefined field_230;  // offset: 0xe6
    undefined field_231;  // offset: 0xe7
    undefined field_232;  // offset: 0xe8
    undefined field_233;  // offset: 0xe9
    undefined field_234;  // offset: 0xea
    undefined field_235;  // offset: 0xeb
    undefined field_236;  // offset: 0xec
    undefined field_237;  // offset: 0xed
    undefined field_238;  // offset: 0xee
    undefined field_239;  // offset: 0xef
    undefined field_240;  // offset: 0xf0
    undefined field_241;  // offset: 0xf1
    undefined field_242;  // offset: 0xf2
    undefined field_243;  // offset: 0xf3
    undefined field_244;  // offset: 0xf4
    undefined field_245;  // offset: 0xf5
    undefined field_246;  // offset: 0xf6
    undefined field_247;  // offset: 0xf7
    undefined field_248;  // offset: 0xf8
    undefined field_249;  // offset: 0xf9
    undefined field_250;  // offset: 0xfa
    undefined field_251;  // offset: 0xfb
    undefined field_252;  // offset: 0xfc
    undefined field_253;  // offset: 0xfd
    undefined field_254;  // offset: 0xfe
    undefined field_255;  // offset: 0xff
}; // size: 0x100

struct sched_info {
    ulong pcount;  // offset: 0x0
    ulonglong run_delay;  // offset: 0x8
    ulonglong last_arrival;  // offset: 0x10
    ulonglong last_queued;  // offset: 0x18
}; // size: 0x20

struct sched_rt_entity {
    list_head run_list;  // offset: 0x0
    ulong timeout;  // offset: 0x10
    ulong watchdog_stamp;  // offset: 0x18
    uint time_slice;  // offset: 0x20
    ushort on_rq;  // offset: 0x24
    ushort on_list;  // offset: 0x26
    sched_rt_entity * back;  // offset: 0x28
}; // size: 0x30

struct seccomp {
    // Empty structure
}; // size: 0x1

struct secondary_data {
    void * stack;  // offset: 0x0
    long status;  // offset: 0x8
}; // size: 0x10

struct sem_undo_list {
    // Empty structure
}; // size: 0x1

struct seq_file {
    char * buf;  // offset: 0x0
    size_t size;  // offset: 0x8
    size_t from;  // offset: 0x10
    size_t count;  // offset: 0x18
    size_t pad_until;  // offset: 0x20
    loff_t index;  // offset: 0x28
    loff_t read_pos;  // offset: 0x30
    u64 version;  // offset: 0x38
    mutex lock;  // offset: 0x40
    seq_operations * op;  // offset: 0x68
    int poll_event;  // offset: 0x70
    file * file;  // offset: 0x78
    void * private;  // offset: 0x80
}; // size: 0x88

struct seq_operations {
    _func_void_ptr_seq_file_ptr_loff_t_ptr * start;  // offset: 0x0
    _func_void_seq_file_ptr_void_ptr * stop;  // offset: 0x8
    _func_void_ptr_seq_file_ptr_void_ptr_loff_t_ptr * next;  // offset: 0x10
    _func_int_seq_file_ptr_void_ptr * show;  // offset: 0x18
}; // size: 0x20

struct seqcount {
    uint sequence;  // offset: 0x0
}; // size: 0x4

struct seqlock_t {
    seqcount seqcount;  // offset: 0x0
    spinlock_t lock;  // offset: 0x4
}; // size: 0x8

struct shared_info {
    vcpu_info vcpu_info[1];  // offset: 0x0
    xen_ulong_t evtchn_pending[64];  // offset: 0x30
    xen_ulong_t evtchn_mask[64];  // offset: 0x230
    pvclock_wall_clock wc;  // offset: 0x430
    arch_shared_info arch;  // offset: 0x440
}; // size: 0x440

struct shrink_control {
    gfp_t gfp_mask;  // offset: 0x0
    ulong nr_to_scan;  // offset: 0x8
    int nid;  // offset: 0x10
    mem_cgroup * memcg;  // offset: 0x18
}; // size: 0x20

struct shrinker {
    _func_ulong_shrinker_ptr_shrink_control_ptr * count_objects;  // offset: 0x0
    _func_ulong_shrinker_ptr_shrink_control_ptr * scan_objects;  // offset: 0x8
    int seeks;  // offset: 0x10
    long batch;  // offset: 0x18
    ulong flags;  // offset: 0x20
    list_head list;  // offset: 0x28
    atomic_long_t * nr_deferred;  // offset: 0x38
}; // size: 0x40

struct sigaction {
    __sighandler_t sa_handler;  // offset: 0x0
    ulong sa_flags;  // offset: 0x8
    __sigrestore_t sa_restorer;  // offset: 0x10
    sigset_t sa_mask;  // offset: 0x18
}; // size: 0x20

struct sighand_struct {
    atomic_t count;  // offset: 0x0
    k_sigaction action[64];  // offset: 0x8
    spinlock_t siglock;  // offset: 0x808
    wait_queue_head_t signalfd_wqh;  // offset: 0x810
}; // size: 0x828

struct siginfo {
    int si_signo;  // offset: 0x0
    int si_errno;  // offset: 0x4
    int si_code;  // offset: 0x8
    anon_union_112_8_26c2b70a_for__sifields _sifields;  // offset: 0x10
}; // size: 0x80

struct signal_struct {
    atomic_t sigcnt;  // offset: 0x0
    atomic_t live;  // offset: 0x4
    int nr_threads;  // offset: 0x8
    list_head thread_head;  // offset: 0x10
    wait_queue_head_t wait_chldexit;  // offset: 0x20
    task_struct * curr_target;  // offset: 0x38
    sigpending shared_pending;  // offset: 0x40
    int group_exit_code;  // offset: 0x58
    int notify_count;  // offset: 0x5c
    task_struct * group_exit_task;  // offset: 0x60
    int group_stop_count;  // offset: 0x68
    uint flags;  // offset: 0x6c
    uint:1 is_child_subreaper;  // offset: 0x70
    uint:1 has_child_subreaper;  // offset: 0x70
    int posix_timer_id;  // offset: 0x74
    list_head posix_timers;  // offset: 0x78
    hrtimer real_timer;  // offset: 0x88
    pid * leader_pid;  // offset: 0xc8
    ktime_t it_real_incr;  // offset: 0xd0
    cpu_itimer it[2];  // offset: 0xd8
    thread_group_cputimer cputimer;  // offset: 0x108
    task_cputime cputime_expires;  // offset: 0x128
    list_head cpu_timers[3];  // offset: 0x140
    pid * tty_old_pgrp;  // offset: 0x170
    int leader;  // offset: 0x178
    tty_struct * tty;  // offset: 0x180
    seqlock_t stats_lock;  // offset: 0x188
    cputime_t utime;  // offset: 0x190
    cputime_t stime;  // offset: 0x198
    cputime_t cutime;  // offset: 0x1a0
    cputime_t cstime;  // offset: 0x1a8
    cputime_t gtime;  // offset: 0x1b0
    cputime_t cgtime;  // offset: 0x1b8
    prev_cputime prev_cputime;  // offset: 0x1c0
    ulong nvcsw;  // offset: 0x1d8
    ulong nivcsw;  // offset: 0x1e0
    ulong cnvcsw;  // offset: 0x1e8
    ulong cnivcsw;  // offset: 0x1f0
    ulong min_flt;  // offset: 0x1f8
    ulong maj_flt;  // offset: 0x200
    ulong cmin_flt;  // offset: 0x208
    ulong cmaj_flt;  // offset: 0x210
    ulong inblock;  // offset: 0x218
    ulong oublock;  // offset: 0x220
    ulong cinblock;  // offset: 0x228
    ulong coublock;  // offset: 0x230
    ulong maxrss;  // offset: 0x238
    ulong cmaxrss;  // offset: 0x240
    task_io_accounting ioac;  // offset: 0x248
    ulonglong sum_sched_runtime;  // offset: 0x280
    rlimit rlim[16];  // offset: 0x288
    pacct_struct pacct;  // offset: 0x388
    taskstats * stats;  // offset: 0x3c0
    uint audit_tty;  // offset: 0x3c8
    tty_audit_buf * tty_audit_buf;  // offset: 0x3d0
    bool oom_flag_origin;  // offset: 0x3d8
    short oom_score_adj;  // offset: 0x3da
    short oom_score_adj_min;  // offset: 0x3dc
    mm_struct * oom_mm;  // offset: 0x3e0
    mutex cred_guard_mutex;  // offset: 0x3e8
}; // size: 0x410

struct sigpending {
    list_head list;  // offset: 0x0
    sigset_t signal;  // offset: 0x10
}; // size: 0x18

struct sigset_t {
    ulong sig[1];  // offset: 0x0
}; // size: 0x8

struct sock {
    // Empty structure
}; // size: 0x1

struct spinlock {
    anon_union_4_1_a8932bbd_for_spinlock_0 field_0;  // offset: 0x0
}; // size: 0x4

struct start_info {
    char magic[32];  // offset: 0x0
    ulong nr_pages;  // offset: 0x20
    ulong shared_info;  // offset: 0x28
    uint32_t flags;  // offset: 0x30
    xen_pfn_t store_mfn;  // offset: 0x38
    uint32_t store_evtchn;  // offset: 0x40
    anon_union_16_2_315a0586_for_console console;  // offset: 0x48
    ulong pt_base;  // offset: 0x58
    ulong nr_pt_frames;  // offset: 0x60
    ulong mfn_list;  // offset: 0x68
    ulong mod_start;  // offset: 0x70
    ulong mod_len;  // offset: 0x78
    int8_t cmd_line[1024];  // offset: 0x80
    ulong first_p2m_pfn;  // offset: 0x480
    ulong nr_p2m_frames;  // offset: 0x488
}; // size: 0x490

struct static_key {
    atomic_t enabled;  // offset: 0x0
}; // size: 0x4

struct static_key_false {
    static_key key;  // offset: 0x0
}; // size: 0x4

struct subsys_private {
    // Empty structure
}; // size: 0x1

struct super_block {
    list_head s_list;  // offset: 0x0
    dev_t s_dev;  // offset: 0x10
    uchar s_blocksize_bits;  // offset: 0x14
    undefined field_21;  // offset: 0x15
    undefined field_22;  // offset: 0x16
    undefined field_23;  // offset: 0x17
    ulong s_blocksize;  // offset: 0x18
    loff_t s_maxbytes;  // offset: 0x20
    file_system_type * s_type;  // offset: 0x28
    super_operations * s_op;  // offset: 0x30
    dquot_operations * dq_op;  // offset: 0x38
    quotactl_ops * s_qcop;  // offset: 0x40
    export_operations * s_export_op;  // offset: 0x48
    ulong s_flags;  // offset: 0x50
    ulong s_iflags;  // offset: 0x58
    ulong s_magic;  // offset: 0x60
    dentry * s_root;  // offset: 0x68
    rw_semaphore s_umount;  // offset: 0x70
    int s_count;  // offset: 0x98
    atomic_t s_active;  // offset: 0x9c
    xattr_handler * * s_xattr;  // offset: 0xa0
    fscrypt_operations * s_cop;  // offset: 0xa8
    hlist_bl_head s_anon;  // offset: 0xb0
    list_head s_mounts;  // offset: 0xb8
    block_device * s_bdev;  // offset: 0xc8
    backing_dev_info * s_bdi;  // offset: 0xd0
    mtd_info * s_mtd;  // offset: 0xd8
    hlist_node s_instances;  // offset: 0xe0
    uint s_quota_types;  // offset: 0xf0
    undefined field_244;  // offset: 0xf4
    undefined field_245;  // offset: 0xf5
    undefined field_246;  // offset: 0xf6
    undefined field_247;  // offset: 0xf7
    quota_info s_dquot;  // offset: 0xf8
    sb_writers s_writers;  // offset: 0x258
    char s_id[32];  // offset: 0x428
    u8 s_uuid[16];  // offset: 0x448
    void * s_fs_info;  // offset: 0x458
    uint s_max_links;  // offset: 0x460
    fmode_t s_mode;  // offset: 0x464
    u32 s_time_gran;  // offset: 0x468
    undefined field_1132;  // offset: 0x46c
    undefined field_1133;  // offset: 0x46d
    undefined field_1134;  // offset: 0x46e
    undefined field_1135;  // offset: 0x46f
    mutex s_vfs_rename_mutex;  // offset: 0x470
    char * s_subtype;  // offset: 0x498
    char * s_options;  // offset: 0x4a0
    dentry_operations * s_d_op;  // offset: 0x4a8
    int cleancache_poolid;  // offset: 0x4b0
    undefined field_1204;  // offset: 0x4b4
    undefined field_1205;  // offset: 0x4b5
    undefined field_1206;  // offset: 0x4b6
    undefined field_1207;  // offset: 0x4b7
    shrinker s_shrink;  // offset: 0x4b8
    atomic_long_t s_remove_count;  // offset: 0x4f8
    int s_readonly_remount;  // offset: 0x500
    undefined field_1284;  // offset: 0x504
    undefined field_1285;  // offset: 0x505
    undefined field_1286;  // offset: 0x506
    undefined field_1287;  // offset: 0x507
    workqueue_struct * s_dio_done_wq;  // offset: 0x508
    hlist_head s_pins;  // offset: 0x510
    user_namespace * s_user_ns;  // offset: 0x518
    undefined field_1312;  // offset: 0x520
    undefined field_1313;  // offset: 0x521
    undefined field_1314;  // offset: 0x522
    undefined field_1315;  // offset: 0x523
    undefined field_1316;  // offset: 0x524
    undefined field_1317;  // offset: 0x525
    undefined field_1318;  // offset: 0x526
    undefined field_1319;  // offset: 0x527
    undefined field_1320;  // offset: 0x528
    undefined field_1321;  // offset: 0x529
    undefined field_1322;  // offset: 0x52a
    undefined field_1323;  // offset: 0x52b
    undefined field_1324;  // offset: 0x52c
    undefined field_1325;  // offset: 0x52d
    undefined field_1326;  // offset: 0x52e
    undefined field_1327;  // offset: 0x52f
    undefined field_1328;  // offset: 0x530
    undefined field_1329;  // offset: 0x531
    undefined field_1330;  // offset: 0x532
    undefined field_1331;  // offset: 0x533
    undefined field_1332;  // offset: 0x534
    undefined field_1333;  // offset: 0x535
    undefined field_1334;  // offset: 0x536
    undefined field_1335;  // offset: 0x537
    undefined field_1336;  // offset: 0x538
    undefined field_1337;  // offset: 0x539
    undefined field_1338;  // offset: 0x53a
    undefined field_1339;  // offset: 0x53b
    undefined field_1340;  // offset: 0x53c
    undefined field_1341;  // offset: 0x53d
    undefined field_1342;  // offset: 0x53e
    undefined field_1343;  // offset: 0x53f
    undefined field_1344;  // offset: 0x540
    undefined field_1345;  // offset: 0x541
    undefined field_1346;  // offset: 0x542
    undefined field_1347;  // offset: 0x543
    undefined field_1348;  // offset: 0x544
    undefined field_1349;  // offset: 0x545
    undefined field_1350;  // offset: 0x546
    undefined field_1351;  // offset: 0x547
    undefined field_1352;  // offset: 0x548
    undefined field_1353;  // offset: 0x549
    undefined field_1354;  // offset: 0x54a
    undefined field_1355;  // offset: 0x54b
    undefined field_1356;  // offset: 0x54c
    undefined field_1357;  // offset: 0x54d
    undefined field_1358;  // offset: 0x54e
    undefined field_1359;  // offset: 0x54f
    undefined field_1360;  // offset: 0x550
    undefined field_1361;  // offset: 0x551
    undefined field_1362;  // offset: 0x552
    undefined field_1363;  // offset: 0x553
    undefined field_1364;  // offset: 0x554
    undefined field_1365;  // offset: 0x555
    undefined field_1366;  // offset: 0x556
    undefined field_1367;  // offset: 0x557
    undefined field_1368;  // offset: 0x558
    undefined field_1369;  // offset: 0x559
    undefined field_1370;  // offset: 0x55a
    undefined field_1371;  // offset: 0x55b
    undefined field_1372;  // offset: 0x55c
    undefined field_1373;  // offset: 0x55d
    undefined field_1374;  // offset: 0x55e
    undefined field_1375;  // offset: 0x55f
    undefined field_1376;  // offset: 0x560
    undefined field_1377;  // offset: 0x561
    undefined field_1378;  // offset: 0x562
    undefined field_1379;  // offset: 0x563
    undefined field_1380;  // offset: 0x564
    undefined field_1381;  // offset: 0x565
    undefined field_1382;  // offset: 0x566
    undefined field_1383;  // offset: 0x567
    undefined field_1384;  // offset: 0x568
    undefined field_1385;  // offset: 0x569
    undefined field_1386;  // offset: 0x56a
    undefined field_1387;  // offset: 0x56b
    undefined field_1388;  // offset: 0x56c
    undefined field_1389;  // offset: 0x56d
    undefined field_1390;  // offset: 0x56e
    undefined field_1391;  // offset: 0x56f
    undefined field_1392;  // offset: 0x570
    undefined field_1393;  // offset: 0x571
    undefined field_1394;  // offset: 0x572
    undefined field_1395;  // offset: 0x573
    undefined field_1396;  // offset: 0x574
    undefined field_1397;  // offset: 0x575
    undefined field_1398;  // offset: 0x576
    undefined field_1399;  // offset: 0x577
    undefined field_1400;  // offset: 0x578
    undefined field_1401;  // offset: 0x579
    undefined field_1402;  // offset: 0x57a
    undefined field_1403;  // offset: 0x57b
    undefined field_1404;  // offset: 0x57c
    undefined field_1405;  // offset: 0x57d
    undefined field_1406;  // offset: 0x57e
    undefined field_1407;  // offset: 0x57f
    list_lru s_dentry_lru;  // offset: 0x580
    undefined field_1416;  // offset: 0x588
    undefined field_1417;  // offset: 0x589
    undefined field_1418;  // offset: 0x58a
    undefined field_1419;  // offset: 0x58b
    undefined field_1420;  // offset: 0x58c
    undefined field_1421;  // offset: 0x58d
    undefined field_1422;  // offset: 0x58e
    undefined field_1423;  // offset: 0x58f
    undefined field_1424;  // offset: 0x590
    undefined field_1425;  // offset: 0x591
    undefined field_1426;  // offset: 0x592
    undefined field_1427;  // offset: 0x593
    undefined field_1428;  // offset: 0x594
    undefined field_1429;  // offset: 0x595
    undefined field_1430;  // offset: 0x596
    undefined field_1431;  // offset: 0x597
    undefined field_1432;  // offset: 0x598
    undefined field_1433;  // offset: 0x599
    undefined field_1434;  // offset: 0x59a
    undefined field_1435;  // offset: 0x59b
    undefined field_1436;  // offset: 0x59c
    undefined field_1437;  // offset: 0x59d
    undefined field_1438;  // offset: 0x59e
    undefined field_1439;  // offset: 0x59f
    undefined field_1440;  // offset: 0x5a0
    undefined field_1441;  // offset: 0x5a1
    undefined field_1442;  // offset: 0x5a2
    undefined field_1443;  // offset: 0x5a3
    undefined field_1444;  // offset: 0x5a4
    undefined field_1445;  // offset: 0x5a5
    undefined field_1446;  // offset: 0x5a6
    undefined field_1447;  // offset: 0x5a7
    undefined field_1448;  // offset: 0x5a8
    undefined field_1449;  // offset: 0x5a9
    undefined field_1450;  // offset: 0x5aa
    undefined field_1451;  // offset: 0x5ab
    undefined field_1452;  // offset: 0x5ac
    undefined field_1453;  // offset: 0x5ad
    undefined field_1454;  // offset: 0x5ae
    undefined field_1455;  // offset: 0x5af
    undefined field_1456;  // offset: 0x5b0
    undefined field_1457;  // offset: 0x5b1
    undefined field_1458;  // offset: 0x5b2
    undefined field_1459;  // offset: 0x5b3
    undefined field_1460;  // offset: 0x5b4
    undefined field_1461;  // offset: 0x5b5
    undefined field_1462;  // offset: 0x5b6
    undefined field_1463;  // offset: 0x5b7
    undefined field_1464;  // offset: 0x5b8
    undefined field_1465;  // offset: 0x5b9
    undefined field_1466;  // offset: 0x5ba
    undefined field_1467;  // offset: 0x5bb
    undefined field_1468;  // offset: 0x5bc
    undefined field_1469;  // offset: 0x5bd
    undefined field_1470;  // offset: 0x5be
    undefined field_1471;  // offset: 0x5bf
    undefined field_1472;  // offset: 0x5c0
    undefined field_1473;  // offset: 0x5c1
    undefined field_1474;  // offset: 0x5c2
    undefined field_1475;  // offset: 0x5c3
    undefined field_1476;  // offset: 0x5c4
    undefined field_1477;  // offset: 0x5c5
    undefined field_1478;  // offset: 0x5c6
    undefined field_1479;  // offset: 0x5c7
    undefined field_1480;  // offset: 0x5c8
    undefined field_1481;  // offset: 0x5c9
    undefined field_1482;  // offset: 0x5ca
    undefined field_1483;  // offset: 0x5cb
    undefined field_1484;  // offset: 0x5cc
    undefined field_1485;  // offset: 0x5cd
    undefined field_1486;  // offset: 0x5ce
    undefined field_1487;  // offset: 0x5cf
    undefined field_1488;  // offset: 0x5d0
    undefined field_1489;  // offset: 0x5d1
    undefined field_1490;  // offset: 0x5d2
    undefined field_1491;  // offset: 0x5d3
    undefined field_1492;  // offset: 0x5d4
    undefined field_1493;  // offset: 0x5d5
    undefined field_1494;  // offset: 0x5d6
    undefined field_1495;  // offset: 0x5d7
    undefined field_1496;  // offset: 0x5d8
    undefined field_1497;  // offset: 0x5d9
    undefined field_1498;  // offset: 0x5da
    undefined field_1499;  // offset: 0x5db
    undefined field_1500;  // offset: 0x5dc
    undefined field_1501;  // offset: 0x5dd
    undefined field_1502;  // offset: 0x5de
    undefined field_1503;  // offset: 0x5df
    undefined field_1504;  // offset: 0x5e0
    undefined field_1505;  // offset: 0x5e1
    undefined field_1506;  // offset: 0x5e2
    undefined field_1507;  // offset: 0x5e3
    undefined field_1508;  // offset: 0x5e4
    undefined field_1509;  // offset: 0x5e5
    undefined field_1510;  // offset: 0x5e6
    undefined field_1511;  // offset: 0x5e7
    undefined field_1512;  // offset: 0x5e8
    undefined field_1513;  // offset: 0x5e9
    undefined field_1514;  // offset: 0x5ea
    undefined field_1515;  // offset: 0x5eb
    undefined field_1516;  // offset: 0x5ec
    undefined field_1517;  // offset: 0x5ed
    undefined field_1518;  // offset: 0x5ee
    undefined field_1519;  // offset: 0x5ef
    undefined field_1520;  // offset: 0x5f0
    undefined field_1521;  // offset: 0x5f1
    undefined field_1522;  // offset: 0x5f2
    undefined field_1523;  // offset: 0x5f3
    undefined field_1524;  // offset: 0x5f4
    undefined field_1525;  // offset: 0x5f5
    undefined field_1526;  // offset: 0x5f6
    undefined field_1527;  // offset: 0x5f7
    undefined field_1528;  // offset: 0x5f8
    undefined field_1529;  // offset: 0x5f9
    undefined field_1530;  // offset: 0x5fa
    undefined field_1531;  // offset: 0x5fb
    undefined field_1532;  // offset: 0x5fc
    undefined field_1533;  // offset: 0x5fd
    undefined field_1534;  // offset: 0x5fe
    undefined field_1535;  // offset: 0x5ff
    list_lru s_inode_lru;  // offset: 0x600
    callback_head rcu;  // offset: 0x608
    work_struct destroy_work;  // offset: 0x618
    mutex s_sync_lock;  // offset: 0x638
    int s_stack_depth;  // offset: 0x660
    undefined field_1636;  // offset: 0x664
    undefined field_1637;  // offset: 0x665
    undefined field_1638;  // offset: 0x666
    undefined field_1639;  // offset: 0x667
    undefined field_1640;  // offset: 0x668
    undefined field_1641;  // offset: 0x669
    undefined field_1642;  // offset: 0x66a
    undefined field_1643;  // offset: 0x66b
    undefined field_1644;  // offset: 0x66c
    undefined field_1645;  // offset: 0x66d
    undefined field_1646;  // offset: 0x66e
    undefined field_1647;  // offset: 0x66f
    undefined field_1648;  // offset: 0x670
    undefined field_1649;  // offset: 0x671
    undefined field_1650;  // offset: 0x672
    undefined field_1651;  // offset: 0x673
    undefined field_1652;  // offset: 0x674
    undefined field_1653;  // offset: 0x675
    undefined field_1654;  // offset: 0x676
    undefined field_1655;  // offset: 0x677
    undefined field_1656;  // offset: 0x678
    undefined field_1657;  // offset: 0x679
    undefined field_1658;  // offset: 0x67a
    undefined field_1659;  // offset: 0x67b
    undefined field_1660;  // offset: 0x67c
    undefined field_1661;  // offset: 0x67d
    undefined field_1662;  // offset: 0x67e
    undefined field_1663;  // offset: 0x67f
    spinlock_t s_inode_list_lock;  // offset: 0x680
    undefined field_1668;  // offset: 0x684
    undefined field_1669;  // offset: 0x685
    undefined field_1670;  // offset: 0x686
    undefined field_1671;  // offset: 0x687
    list_head s_inodes;  // offset: 0x688
    spinlock_t s_inode_wblist_lock;  // offset: 0x698
    undefined field_1692;  // offset: 0x69c
    undefined field_1693;  // offset: 0x69d
    undefined field_1694;  // offset: 0x69e
    undefined field_1695;  // offset: 0x69f
    list_head s_inodes_wb;  // offset: 0x6a0
    undefined field_1712;  // offset: 0x6b0
    undefined field_1713;  // offset: 0x6b1
    undefined field_1714;  // offset: 0x6b2
    undefined field_1715;  // offset: 0x6b3
    undefined field_1716;  // offset: 0x6b4
    undefined field_1717;  // offset: 0x6b5
    undefined field_1718;  // offset: 0x6b6
    undefined field_1719;  // offset: 0x6b7
    undefined field_1720;  // offset: 0x6b8
    undefined field_1721;  // offset: 0x6b9
    undefined field_1722;  // offset: 0x6ba
    undefined field_1723;  // offset: 0x6bb
    undefined field_1724;  // offset: 0x6bc
    undefined field_1725;  // offset: 0x6bd
    undefined field_1726;  // offset: 0x6be
    undefined field_1727;  // offset: 0x6bf
    undefined field_1728;  // offset: 0x6c0
    undefined field_1729;  // offset: 0x6c1
    undefined field_1730;  // offset: 0x6c2
    undefined field_1731;  // offset: 0x6c3
    undefined field_1732;  // offset: 0x6c4
    undefined field_1733;  // offset: 0x6c5
    undefined field_1734;  // offset: 0x6c6
    undefined field_1735;  // offset: 0x6c7
    undefined field_1736;  // offset: 0x6c8
    undefined field_1737;  // offset: 0x6c9
    undefined field_1738;  // offset: 0x6ca
    undefined field_1739;  // offset: 0x6cb
    undefined field_1740;  // offset: 0x6cc
    undefined field_1741;  // offset: 0x6cd
    undefined field_1742;  // offset: 0x6ce
    undefined field_1743;  // offset: 0x6cf
    undefined field_1744;  // offset: 0x6d0
    undefined field_1745;  // offset: 0x6d1
    undefined field_1746;  // offset: 0x6d2
    undefined field_1747;  // offset: 0x6d3
    undefined field_1748;  // offset: 0x6d4
    undefined field_1749;  // offset: 0x6d5
    undefined field_1750;  // offset: 0x6d6
    undefined field_1751;  // offset: 0x6d7
    undefined field_1752;  // offset: 0x6d8
    undefined field_1753;  // offset: 0x6d9
    undefined field_1754;  // offset: 0x6da
    undefined field_1755;  // offset: 0x6db
    undefined field_1756;  // offset: 0x6dc
    undefined field_1757;  // offset: 0x6dd
    undefined field_1758;  // offset: 0x6de
    undefined field_1759;  // offset: 0x6df
    undefined field_1760;  // offset: 0x6e0
    undefined field_1761;  // offset: 0x6e1
    undefined field_1762;  // offset: 0x6e2
    undefined field_1763;  // offset: 0x6e3
    undefined field_1764;  // offset: 0x6e4
    undefined field_1765;  // offset: 0x6e5
    undefined field_1766;  // offset: 0x6e6
    undefined field_1767;  // offset: 0x6e7
    undefined field_1768;  // offset: 0x6e8
    undefined field_1769;  // offset: 0x6e9
    undefined field_1770;  // offset: 0x6ea
    undefined field_1771;  // offset: 0x6eb
    undefined field_1772;  // offset: 0x6ec
    undefined field_1773;  // offset: 0x6ed
    undefined field_1774;  // offset: 0x6ee
    undefined field_1775;  // offset: 0x6ef
    undefined field_1776;  // offset: 0x6f0
    undefined field_1777;  // offset: 0x6f1
    undefined field_1778;  // offset: 0x6f2
    undefined field_1779;  // offset: 0x6f3
    undefined field_1780;  // offset: 0x6f4
    undefined field_1781;  // offset: 0x6f5
    undefined field_1782;  // offset: 0x6f6
    undefined field_1783;  // offset: 0x6f7
    undefined field_1784;  // offset: 0x6f8
    undefined field_1785;  // offset: 0x6f9
    undefined field_1786;  // offset: 0x6fa
    undefined field_1787;  // offset: 0x6fb
    undefined field_1788;  // offset: 0x6fc
    undefined field_1789;  // offset: 0x6fd
    undefined field_1790;  // offset: 0x6fe
    undefined field_1791;  // offset: 0x6ff
}; // size: 0x700

struct super_operations {
    _func_inode_ptr_super_block_ptr * alloc_inode;  // offset: 0x0
    _func_void_inode_ptr * destroy_inode;  // offset: 0x8
    _func_void_inode_ptr_int * dirty_inode;  // offset: 0x10
    _func_int_inode_ptr_writeback_control_ptr * write_inode;  // offset: 0x18
    _func_int_inode_ptr * drop_inode;  // offset: 0x20
    _func_void_inode_ptr * evict_inode;  // offset: 0x28
    _func_void_super_block_ptr * put_super;  // offset: 0x30
    _func_int_super_block_ptr_int * sync_fs;  // offset: 0x38
    _func_int_super_block_ptr * freeze_super;  // offset: 0x40
    _func_int_super_block_ptr * freeze_fs;  // offset: 0x48
    _func_int_super_block_ptr * thaw_super;  // offset: 0x50
    _func_int_super_block_ptr * unfreeze_fs;  // offset: 0x58
    _func_int_dentry_ptr_kstatfs_ptr * statfs;  // offset: 0x60
    _func_int_super_block_ptr_int_ptr_char_ptr * remount_fs;  // offset: 0x68
    _func_void_super_block_ptr * umount_begin;  // offset: 0x70
    _func_int_seq_file_ptr_dentry_ptr * show_options;  // offset: 0x78
    _func_int_seq_file_ptr_dentry_ptr * show_devname;  // offset: 0x80
    _func_int_seq_file_ptr_dentry_ptr * show_path;  // offset: 0x88
    _func_int_seq_file_ptr_dentry_ptr * show_stats;  // offset: 0x90
    _func_ssize_t_super_block_ptr_int_char_ptr_size_t_loff_t * quota_read;  // offset: 0x98
    _func_ssize_t_super_block_ptr_int_char_ptr_size_t_loff_t * quota_write;  // offset: 0xa0
    _func_dquot_ptr_ptr_inode_ptr * get_dquots;  // offset: 0xa8
    _func_int_super_block_ptr_page_ptr_gfp_t * bdev_try_to_free_page;  // offset: 0xb0
    _func_long_super_block_ptr_shrink_control_ptr * nr_cached_objects;  // offset: 0xb8
    _func_long_super_block_ptr_shrink_control_ptr * free_cached_objects;  // offset: 0xc0
}; // size: 0xc8

struct swap_info_struct {
    // Empty structure
}; // size: 0x1

struct sysfs_ops {
    _func_ssize_t_kobject_ptr_attribute_ptr_char_ptr * show;  // offset: 0x0
    _func_ssize_t_kobject_ptr_attribute_ptr_char_ptr_size_t * store;  // offset: 0x8
}; // size: 0x10

struct sysv_sem {
    sem_undo_list * undo_list;  // offset: 0x0
}; // size: 0x8

struct sysv_shm {
    list_head shm_clist;  // offset: 0x0
}; // size: 0x10

struct task_cputime {
    cputime_t utime;  // offset: 0x0
    cputime_t stime;  // offset: 0x8
    ulonglong sum_exec_runtime;  // offset: 0x10
}; // size: 0x18

struct task_cputime_atomic {
    atomic64_t utime;  // offset: 0x0
    atomic64_t stime;  // offset: 0x8
    atomic64_t sum_exec_runtime;  // offset: 0x10
}; // size: 0x18

struct task_delay_info {
    spinlock_t lock;  // offset: 0x0
    uint flags;  // offset: 0x4
    u64 blkio_start;  // offset: 0x8
    u64 blkio_delay;  // offset: 0x10
    u64 swapin_delay;  // offset: 0x18
    u32 blkio_count;  // offset: 0x20
    u32 swapin_count;  // offset: 0x24
    u64 freepages_start;  // offset: 0x28
    u64 freepages_delay;  // offset: 0x30
    u32 freepages_count;  // offset: 0x38
}; // size: 0x40

struct task_io_accounting {
    u64 rchar;  // offset: 0x0
    u64 wchar;  // offset: 0x8
    u64 syscr;  // offset: 0x10
    u64 syscw;  // offset: 0x18
    u64 read_bytes;  // offset: 0x20
    u64 write_bytes;  // offset: 0x28
    u64 cancelled_write_bytes;  // offset: 0x30
}; // size: 0x38

struct task_rss_stat {
    int events;  // offset: 0x0
    int count[4];  // offset: 0x4
}; // size: 0x14

struct task_struct {
    long state;  // offset: 0x0
    void * stack;  // offset: 0x8
    atomic_t usage;  // offset: 0x10
    uint flags;  // offset: 0x14
    uint ptrace;  // offset: 0x18
    undefined field_28;  // offset: 0x1c
    undefined field_29;  // offset: 0x1d
    undefined field_30;  // offset: 0x1e
    undefined field_31;  // offset: 0x1f
    llist_node wake_entry;  // offset: 0x20
    int on_cpu;  // offset: 0x28
    uint wakee_flips;  // offset: 0x2c
    ulong wakee_flip_decay_ts;  // offset: 0x30
    task_struct * last_wakee;  // offset: 0x38
    int wake_cpu;  // offset: 0x40
    int on_rq;  // offset: 0x44
    int prio;  // offset: 0x48
    int static_prio;  // offset: 0x4c
    int normal_prio;  // offset: 0x50
    uint rt_priority;  // offset: 0x54
    sched_class * sched_class;  // offset: 0x58
    undefined field_96;  // offset: 0x60
    undefined field_97;  // offset: 0x61
    undefined field_98;  // offset: 0x62
    undefined field_99;  // offset: 0x63
    undefined field_100;  // offset: 0x64
    undefined field_101;  // offset: 0x65
    undefined field_102;  // offset: 0x66
    undefined field_103;  // offset: 0x67
    undefined field_104;  // offset: 0x68
    undefined field_105;  // offset: 0x69
    undefined field_106;  // offset: 0x6a
    undefined field_107;  // offset: 0x6b
    undefined field_108;  // offset: 0x6c
    undefined field_109;  // offset: 0x6d
    undefined field_110;  // offset: 0x6e
    undefined field_111;  // offset: 0x6f
    undefined field_112;  // offset: 0x70
    undefined field_113;  // offset: 0x71
    undefined field_114;  // offset: 0x72
    undefined field_115;  // offset: 0x73
    undefined field_116;  // offset: 0x74
    undefined field_117;  // offset: 0x75
    undefined field_118;  // offset: 0x76
    undefined field_119;  // offset: 0x77
    undefined field_120;  // offset: 0x78
    undefined field_121;  // offset: 0x79
    undefined field_122;  // offset: 0x7a
    undefined field_123;  // offset: 0x7b
    undefined field_124;  // offset: 0x7c
    undefined field_125;  // offset: 0x7d
    undefined field_126;  // offset: 0x7e
    undefined field_127;  // offset: 0x7f
    sched_entity se;  // offset: 0x80
    sched_rt_entity rt;  // offset: 0x180
    sched_dl_entity dl;  // offset: 0x1b0
    uint policy;  // offset: 0x248
    int nr_cpus_allowed;  // offset: 0x24c
    cpumask_t cpus_allowed;  // offset: 0x250
    sched_info sched_info;  // offset: 0x258
    list_head tasks;  // offset: 0x278
    plist_node pushable_tasks;  // offset: 0x288
    rb_node pushable_dl_tasks;  // offset: 0x2b0
    mm_struct * mm;  // offset: 0x2c8
    mm_struct * active_mm;  // offset: 0x2d0
    u32 vmacache_seqnum;  // offset: 0x2d8
    undefined field_732;  // offset: 0x2dc
    undefined field_733;  // offset: 0x2dd
    undefined field_734;  // offset: 0x2de
    undefined field_735;  // offset: 0x2df
    vm_area_struct * vmacache[4];  // offset: 0x2e0
    task_rss_stat rss_stat;  // offset: 0x300
    int exit_state;  // offset: 0x314
    int exit_code;  // offset: 0x318
    int exit_signal;  // offset: 0x31c
    int pdeath_signal;  // offset: 0x320
    undefined field_804;  // offset: 0x324
    undefined field_805;  // offset: 0x325
    undefined field_806;  // offset: 0x326
    undefined field_807;  // offset: 0x327
    ulong jobctl;  // offset: 0x328
    uint personality;  // offset: 0x330
    uint:1 sched_reset_on_fork;  // offset: 0x334
    uint:1 sched_contributes_to_load;  // offset: 0x334
    uint:1 sched_migrated;  // offset: 0x334
    uint:1 sched_remote_wakeup;  // offset: 0x334
    undefined field_821;  // offset: 0x335
    undefined field_822;  // offset: 0x336
    undefined field_823;  // offset: 0x337
    uint:1 in_execve;  // offset: 0x338
    uint:1 in_iowait;  // offset: 0x338
    undefined field_825;  // offset: 0x339
    undefined field_826;  // offset: 0x33a
    undefined field_827;  // offset: 0x33b
    undefined field_828;  // offset: 0x33c
    undefined field_829;  // offset: 0x33d
    undefined field_830;  // offset: 0x33e
    undefined field_831;  // offset: 0x33f
    ulong atomic_flags;  // offset: 0x340
    restart_block restart_block;  // offset: 0x348
    pid_t pid;  // offset: 0x378
    pid_t tgid;  // offset: 0x37c
    task_struct * real_parent;  // offset: 0x380
    task_struct * parent;  // offset: 0x388
    list_head children;  // offset: 0x390
    list_head sibling;  // offset: 0x3a0
    task_struct * group_leader;  // offset: 0x3b0
    list_head ptraced;  // offset: 0x3b8
    list_head ptrace_entry;  // offset: 0x3c8
    pid_link pids[3];  // offset: 0x3d8
    list_head thread_group;  // offset: 0x420
    list_head thread_node;  // offset: 0x430
    completion * vfork_done;  // offset: 0x440
    int * set_child_tid;  // offset: 0x448
    int * clear_child_tid;  // offset: 0x450
    cputime_t utime;  // offset: 0x458
    cputime_t stime;  // offset: 0x460
    cputime_t utimescaled;  // offset: 0x468
    cputime_t stimescaled;  // offset: 0x470
    cputime_t gtime;  // offset: 0x478
    prev_cputime prev_cputime;  // offset: 0x480
    ulong nvcsw;  // offset: 0x498
    ulong nivcsw;  // offset: 0x4a0
    u64 start_time;  // offset: 0x4a8
    u64 real_start_time;  // offset: 0x4b0
    ulong min_flt;  // offset: 0x4b8
    ulong maj_flt;  // offset: 0x4c0
    task_cputime cputime_expires;  // offset: 0x4c8
    list_head cpu_timers[3];  // offset: 0x4e0
    cred * real_cred;  // offset: 0x510
    cred * cred;  // offset: 0x518
    char comm[16];  // offset: 0x520
    nameidata * nameidata;  // offset: 0x530
    sysv_sem sysvsem;  // offset: 0x538
    sysv_shm sysvshm;  // offset: 0x540
    fs_struct * fs;  // offset: 0x550
    files_struct * files;  // offset: 0x558
    nsproxy * nsproxy;  // offset: 0x560
    signal_struct * signal;  // offset: 0x568
    sighand_struct * sighand;  // offset: 0x570
    sigset_t blocked;  // offset: 0x578
    sigset_t real_blocked;  // offset: 0x580
    sigset_t saved_sigmask;  // offset: 0x588
    sigpending pending;  // offset: 0x590
    ulong sas_ss_sp;  // offset: 0x5a8
    size_t sas_ss_size;  // offset: 0x5b0
    uint sas_ss_flags;  // offset: 0x5b8
    undefined field_1468;  // offset: 0x5bc
    undefined field_1469;  // offset: 0x5bd
    undefined field_1470;  // offset: 0x5be
    undefined field_1471;  // offset: 0x5bf
    callback_head * task_works;  // offset: 0x5c0
    audit_context * audit_context;  // offset: 0x5c8
    kuid_t loginuid;  // offset: 0x5d0
    uint sessionid;  // offset: 0x5d4
    seccomp seccomp;  // offset: 0x5d8
    u32 parent_exec_id;  // offset: 0x5d8
    u32 self_exec_id;  // offset: 0x5dc
    spinlock_t alloc_lock;  // offset: 0x5e0
    raw_spinlock_t pi_lock;  // offset: 0x5e4
    wake_q_node wake_q;  // offset: 0x5e8
    rb_root pi_waiters;  // offset: 0x5f0
    rb_node * pi_waiters_leftmost;  // offset: 0x5f8
    rt_mutex_waiter * pi_blocked_on;  // offset: 0x600
    void * journal_info;  // offset: 0x608
    bio_list * bio_list;  // offset: 0x610
    blk_plug * plug;  // offset: 0x618
    reclaim_state * reclaim_state;  // offset: 0x620
    backing_dev_info * backing_dev_info;  // offset: 0x628
    io_context * io_context;  // offset: 0x630
    ulong ptrace_message;  // offset: 0x638
    siginfo_t * last_siginfo;  // offset: 0x640
    task_io_accounting ioac;  // offset: 0x648
    u64 acct_rss_mem1;  // offset: 0x680
    u64 acct_vm_mem1;  // offset: 0x688
    cputime_t acct_timexpd;  // offset: 0x690
    css_set * cgroups;  // offset: 0x698
    list_head cg_list;  // offset: 0x6a0
    robust_list_head * robust_list;  // offset: 0x6b0
    compat_robust_list_head * compat_robust_list;  // offset: 0x6b8
    list_head pi_state_list;  // offset: 0x6c0
    futex_pi_state * pi_state_cache;  // offset: 0x6d0
    perf_event_context * perf_event_ctxp[2];  // offset: 0x6d8
    mutex perf_event_mutex;  // offset: 0x6e8
    list_head perf_event_list;  // offset: 0x710
    callback_head rcu;  // offset: 0x720
    pipe_inode_info * splice_pipe;  // offset: 0x730
    page_frag task_frag;  // offset: 0x738
    task_delay_info * delays;  // offset: 0x748
    int nr_dirtied;  // offset: 0x750
    int nr_dirtied_pause;  // offset: 0x754
    ulong dirty_paused_when;  // offset: 0x758
    u64 timer_slack_ns;  // offset: 0x760
    u64 default_timer_slack_ns;  // offset: 0x768
    int pagefault_disabled;  // offset: 0x770
    undefined field_1908;  // offset: 0x774
    undefined field_1909;  // offset: 0x775
    undefined field_1910;  // offset: 0x776
    undefined field_1911;  // offset: 0x777
    task_struct * oom_reaper_list;  // offset: 0x778
    thread_struct thread;  // offset: 0x780
    undefined field_2880;  // offset: 0xb40
    undefined field_2881;  // offset: 0xb41
    undefined field_2882;  // offset: 0xb42
    undefined field_2883;  // offset: 0xb43
    undefined field_2884;  // offset: 0xb44
    undefined field_2885;  // offset: 0xb45
    undefined field_2886;  // offset: 0xb46
    undefined field_2887;  // offset: 0xb47
    undefined field_2888;  // offset: 0xb48
    undefined field_2889;  // offset: 0xb49
    undefined field_2890;  // offset: 0xb4a
    undefined field_2891;  // offset: 0xb4b
    undefined field_2892;  // offset: 0xb4c
    undefined field_2893;  // offset: 0xb4d
    undefined field_2894;  // offset: 0xb4e
    undefined field_2895;  // offset: 0xb4f
    undefined field_2896;  // offset: 0xb50
    undefined field_2897;  // offset: 0xb51
    undefined field_2898;  // offset: 0xb52
    undefined field_2899;  // offset: 0xb53
    undefined field_2900;  // offset: 0xb54
    undefined field_2901;  // offset: 0xb55
    undefined field_2902;  // offset: 0xb56
    undefined field_2903;  // offset: 0xb57
    undefined field_2904;  // offset: 0xb58
    undefined field_2905;  // offset: 0xb59
    undefined field_2906;  // offset: 0xb5a
    undefined field_2907;  // offset: 0xb5b
    undefined field_2908;  // offset: 0xb5c
    undefined field_2909;  // offset: 0xb5d
    undefined field_2910;  // offset: 0xb5e
    undefined field_2911;  // offset: 0xb5f
    undefined field_2912;  // offset: 0xb60
    undefined field_2913;  // offset: 0xb61
    undefined field_2914;  // offset: 0xb62
    undefined field_2915;  // offset: 0xb63
    undefined field_2916;  // offset: 0xb64
    undefined field_2917;  // offset: 0xb65
    undefined field_2918;  // offset: 0xb66
    undefined field_2919;  // offset: 0xb67
    undefined field_2920;  // offset: 0xb68
    undefined field_2921;  // offset: 0xb69
    undefined field_2922;  // offset: 0xb6a
    undefined field_2923;  // offset: 0xb6b
    undefined field_2924;  // offset: 0xb6c
    undefined field_2925;  // offset: 0xb6d
    undefined field_2926;  // offset: 0xb6e
    undefined field_2927;  // offset: 0xb6f
    undefined field_2928;  // offset: 0xb70
    undefined field_2929;  // offset: 0xb71
    undefined field_2930;  // offset: 0xb72
    undefined field_2931;  // offset: 0xb73
    undefined field_2932;  // offset: 0xb74
    undefined field_2933;  // offset: 0xb75
    undefined field_2934;  // offset: 0xb76
    undefined field_2935;  // offset: 0xb77
    undefined field_2936;  // offset: 0xb78
    undefined field_2937;  // offset: 0xb79
    undefined field_2938;  // offset: 0xb7a
    undefined field_2939;  // offset: 0xb7b
    undefined field_2940;  // offset: 0xb7c
    undefined field_2941;  // offset: 0xb7d
    undefined field_2942;  // offset: 0xb7e
    undefined field_2943;  // offset: 0xb7f
}; // size: 0xb80

struct taskstats {
    // Empty structure
}; // size: 0x1

struct thread_group_cputimer {
    task_cputime_atomic cputime_atomic;  // offset: 0x0
    bool running;  // offset: 0x18
    bool checking_timer;  // offset: 0x19
}; // size: 0x20

struct thread_info {
    ulong flags;  // offset: 0x0
    mm_segment_t addr_limit;  // offset: 0x8
    task_struct * task;  // offset: 0x10
    int preempt_count;  // offset: 0x18
    int cpu;  // offset: 0x1c
}; // size: 0x20

struct thread_struct {
    cpu_context cpu_context;  // offset: 0x0
    ulong tp_value;  // offset: 0x68
    ulong tp2_value;  // offset: 0x70
    fpsimd_state fpsimd_state;  // offset: 0x80
    ulong fault_address;  // offset: 0x2a0
    ulong fault_code;  // offset: 0x2a8
    debug_info debug;  // offset: 0x2b0
}; // size: 0x3c0

struct tick_device {
    // Empty structure
}; // size: 0x1

struct timer_list {
    hlist_node entry;  // offset: 0x0
    ulong expires;  // offset: 0x10
    _func_void_ulong * function;  // offset: 0x18
    ulong data;  // offset: 0x20
    u32 flags;  // offset: 0x28
}; // size: 0x30

struct timerqueue_head {
    rb_root head;  // offset: 0x0
    timerqueue_node * next;  // offset: 0x8
}; // size: 0x10

struct timerqueue_node {
    rb_node node;  // offset: 0x0
    ktime_t expires;  // offset: 0x18
}; // size: 0x20

struct timespec {
    __kernel_time_t tv_sec;  // offset: 0x0
    long tv_nsec;  // offset: 0x8
}; // size: 0x10

struct timezone {
    int tz_minuteswest;  // offset: 0x0
    int tz_dsttime;  // offset: 0x4
}; // size: 0x8

struct tracepoint {
    char * name;  // offset: 0x0
    static_key key;  // offset: 0x8
    __restorefn_t * regfunc;  // offset: 0x10
    __restorefn_t * unregfunc;  // offset: 0x18
    tracepoint_func * funcs;  // offset: 0x20
}; // size: 0x28

struct tracepoint_func {
    void * func;  // offset: 0x0
    void * data;  // offset: 0x8
    int prio;  // offset: 0x10
}; // size: 0x18

struct tty_audit_buf {
    // Empty structure
}; // size: 0x1

struct tty_struct {
    // Empty structure
}; // size: 0x1

struct upid {
    int nr;  // offset: 0x0
    pid_namespace * ns;  // offset: 0x8
    hlist_node pid_chain;  // offset: 0x10
}; // size: 0x20

struct uprobes_state {
    // Empty structure
}; // size: 0x1

struct user_fpsimd_state {
    __int128 unsigned vregs[32];  // offset: 0x0
    __u32 fpsr;  // offset: 0x200
    __u32 fpcr;  // offset: 0x204
}; // size: 0x210

struct user_namespace {
    // Empty structure
}; // size: 0x1

struct user_struct {
    atomic_t __count;  // offset: 0x0
    atomic_t processes;  // offset: 0x4
    atomic_t sigpending;  // offset: 0x8
    atomic_t inotify_watches;  // offset: 0xc
    atomic_t inotify_devs;  // offset: 0x10
    atomic_long_t epoll_watches;  // offset: 0x18
    ulong mq_bytes;  // offset: 0x20
    ulong locked_shm;  // offset: 0x28
    ulong unix_inflight;  // offset: 0x30
    atomic_long_t pipe_bufs;  // offset: 0x38
    key * uid_keyring;  // offset: 0x40
    key * session_keyring;  // offset: 0x48
    hlist_node uidhash_node;  // offset: 0x50
    kuid_t uid;  // offset: 0x60
    atomic_long_t locked_vm;  // offset: 0x68
}; // size: 0x70

struct vcpu_info {
    uint8_t evtchn_upcall_pending;  // offset: 0x0
    uint8_t evtchn_upcall_mask;  // offset: 0x1
    xen_ulong_t evtchn_pending_sel;  // offset: 0x8
    arch_vcpu_info arch;  // offset: 0x10
    pvclock_vcpu_time_info time;  // offset: 0x10
}; // size: 0x30

struct vfsmount {
    // Empty structure
}; // size: 0x1

struct vm_area_struct {
    ulong vm_start;  // offset: 0x0
    ulong vm_end;  // offset: 0x8
    vm_area_struct * vm_next;  // offset: 0x10
    vm_area_struct * vm_prev;  // offset: 0x18
    rb_node vm_rb;  // offset: 0x20
    ulong rb_subtree_gap;  // offset: 0x38
    mm_struct * vm_mm;  // offset: 0x40
    pgprot_t vm_page_prot;  // offset: 0x48
    ulong vm_flags;  // offset: 0x50
    anon_struct_32_2_b72ec8c0_for_shared shared;  // offset: 0x58
    list_head anon_vma_chain;  // offset: 0x78
    anon_vma * anon_vma;  // offset: 0x88
    vm_operations_struct * vm_ops;  // offset: 0x90
    ulong vm_pgoff;  // offset: 0x98
    file * vm_file;  // offset: 0xa0
    void * vm_private_data;  // offset: 0xa8
    vm_userfaultfd_ctx vm_userfaultfd_ctx;  // offset: 0xb0
}; // size: 0xb0

struct vm_event_state {
    ulong event[64];  // offset: 0x0
}; // size: 0x200

struct vm_fault {
    uint flags;  // offset: 0x0
    gfp_t gfp_mask;  // offset: 0x4
    ulong pgoff;  // offset: 0x8
    void * virtual_address;  // offset: 0x10
    page * cow_page;  // offset: 0x18
    page * page;  // offset: 0x20
    void * entry;  // offset: 0x28
}; // size: 0x30

struct vm_operations_struct {
    _func_void_vm_area_struct_ptr * open;  // offset: 0x0
    _func_void_vm_area_struct_ptr * close;  // offset: 0x8
    _func_int_vm_area_struct_ptr * mremap;  // offset: 0x10
    _func_int_vm_area_struct_ptr_vm_fault_ptr * fault;  // offset: 0x18
    _func_int_vm_area_struct_ptr_ulong_pmd_t_ptr_uint * pmd_fault;  // offset: 0x20
    _func_void_fault_env_ptr_ulong_ulong * map_pages;  // offset: 0x28
    _func_int_vm_area_struct_ptr_vm_fault_ptr * page_mkwrite;  // offset: 0x30
    _func_int_vm_area_struct_ptr_vm_fault_ptr * pfn_mkwrite;  // offset: 0x38
    _func_int_vm_area_struct_ptr_ulong_void_ptr_int_int * access;  // offset: 0x40
    _func_char_ptr_vm_area_struct_ptr * name;  // offset: 0x48
    _func_page_ptr_vm_area_struct_ptr_ulong * find_special_page;  // offset: 0x50
}; // size: 0x58

struct vm_userfaultfd_ctx {
    // Empty structure
}; // size: 0x1

struct wake_irq {
    // Empty structure
}; // size: 0x1

struct wake_q_node {
    wake_q_node * next;  // offset: 0x0
}; // size: 0x8

struct wakeup_source {
    char * name;  // offset: 0x0
    list_head entry;  // offset: 0x8
    spinlock_t lock;  // offset: 0x18
    wake_irq * wakeirq;  // offset: 0x20
    timer_list timer;  // offset: 0x28
    ulong timer_expires;  // offset: 0x58
    ktime_t total_time;  // offset: 0x60
    ktime_t max_time;  // offset: 0x68
    ktime_t last_time;  // offset: 0x70
    ktime_t start_prevent_time;  // offset: 0x78
    ktime_t prevent_sleep_time;  // offset: 0x80
    ulong event_count;  // offset: 0x88
    ulong active_count;  // offset: 0x90
    ulong relax_count;  // offset: 0x98
    ulong expire_count;  // offset: 0xa0
    ulong wakeup_count;  // offset: 0xa8
    bool:1 active;  // offset: 0xb0
    bool:1 autosleep_enabled;  // offset: 0xb0
}; // size: 0xb8

struct work_struct {
    atomic_long_t data;  // offset: 0x0
    list_head entry;  // offset: 0x8
    work_func_t func;  // offset: 0x18
}; // size: 0x20

struct workqueue_struct {
    // Empty structure
}; // size: 0x1

struct writeback_control {
    // Empty structure
}; // size: 0x1

struct xattr_handler {
    // Empty structure
}; // size: 0x1

struct zone {
    ulong watermark[3];  // offset: 0x0
    ulong nr_reserved_highatomic;  // offset: 0x18
    long lowmem_reserve[3];  // offset: 0x20
    pglist_data * zone_pgdat;  // offset: 0x38
    per_cpu_pageset * pageset;  // offset: 0x40
    ulong zone_start_pfn;  // offset: 0x48
    ulong managed_pages;  // offset: 0x50
    ulong spanned_pages;  // offset: 0x58
    ulong present_pages;  // offset: 0x60
    char * name;  // offset: 0x68
    ulong nr_isolate_pageblock;  // offset: 0x70
    int initialized;  // offset: 0x78
    undefined field_124;  // offset: 0x7c
    undefined field_125;  // offset: 0x7d
    undefined field_126;  // offset: 0x7e
    undefined field_127;  // offset: 0x7f
    zone_padding _pad1_;  // offset: 0x80
    free_area free_area[11];  // offset: 0x80
    ulong flags;  // offset: 0x4f8
    spinlock_t lock;  // offset: 0x500
    undefined field_1284;  // offset: 0x504
    undefined field_1285;  // offset: 0x505
    undefined field_1286;  // offset: 0x506
    undefined field_1287;  // offset: 0x507
    undefined field_1288;  // offset: 0x508
    undefined field_1289;  // offset: 0x509
    undefined field_1290;  // offset: 0x50a
    undefined field_1291;  // offset: 0x50b
    undefined field_1292;  // offset: 0x50c
    undefined field_1293;  // offset: 0x50d
    undefined field_1294;  // offset: 0x50e
    undefined field_1295;  // offset: 0x50f
    undefined field_1296;  // offset: 0x510
    undefined field_1297;  // offset: 0x511
    undefined field_1298;  // offset: 0x512
    undefined field_1299;  // offset: 0x513
    undefined field_1300;  // offset: 0x514
    undefined field_1301;  // offset: 0x515
    undefined field_1302;  // offset: 0x516
    undefined field_1303;  // offset: 0x517
    undefined field_1304;  // offset: 0x518
    undefined field_1305;  // offset: 0x519
    undefined field_1306;  // offset: 0x51a
    undefined field_1307;  // offset: 0x51b
    undefined field_1308;  // offset: 0x51c
    undefined field_1309;  // offset: 0x51d
    undefined field_1310;  // offset: 0x51e
    undefined field_1311;  // offset: 0x51f
    undefined field_1312;  // offset: 0x520
    undefined field_1313;  // offset: 0x521
    undefined field_1314;  // offset: 0x522
    undefined field_1315;  // offset: 0x523
    undefined field_1316;  // offset: 0x524
    undefined field_1317;  // offset: 0x525
    undefined field_1318;  // offset: 0x526
    undefined field_1319;  // offset: 0x527
    undefined field_1320;  // offset: 0x528
    undefined field_1321;  // offset: 0x529
    undefined field_1322;  // offset: 0x52a
    undefined field_1323;  // offset: 0x52b
    undefined field_1324;  // offset: 0x52c
    undefined field_1325;  // offset: 0x52d
    undefined field_1326;  // offset: 0x52e
    undefined field_1327;  // offset: 0x52f
    undefined field_1328;  // offset: 0x530
    undefined field_1329;  // offset: 0x531
    undefined field_1330;  // offset: 0x532
    undefined field_1331;  // offset: 0x533
    undefined field_1332;  // offset: 0x534
    undefined field_1333;  // offset: 0x535
    undefined field_1334;  // offset: 0x536
    undefined field_1335;  // offset: 0x537
    undefined field_1336;  // offset: 0x538
    undefined field_1337;  // offset: 0x539
    undefined field_1338;  // offset: 0x53a
    undefined field_1339;  // offset: 0x53b
    undefined field_1340;  // offset: 0x53c
    undefined field_1341;  // offset: 0x53d
    undefined field_1342;  // offset: 0x53e
    undefined field_1343;  // offset: 0x53f
    undefined field_1344;  // offset: 0x540
    undefined field_1345;  // offset: 0x541
    undefined field_1346;  // offset: 0x542
    undefined field_1347;  // offset: 0x543
    undefined field_1348;  // offset: 0x544
    undefined field_1349;  // offset: 0x545
    undefined field_1350;  // offset: 0x546
    undefined field_1351;  // offset: 0x547
    undefined field_1352;  // offset: 0x548
    undefined field_1353;  // offset: 0x549
    undefined field_1354;  // offset: 0x54a
    undefined field_1355;  // offset: 0x54b
    undefined field_1356;  // offset: 0x54c
    undefined field_1357;  // offset: 0x54d
    undefined field_1358;  // offset: 0x54e
    undefined field_1359;  // offset: 0x54f
    undefined field_1360;  // offset: 0x550
    undefined field_1361;  // offset: 0x551
    undefined field_1362;  // offset: 0x552
    undefined field_1363;  // offset: 0x553
    undefined field_1364;  // offset: 0x554
    undefined field_1365;  // offset: 0x555
    undefined field_1366;  // offset: 0x556
    undefined field_1367;  // offset: 0x557
    undefined field_1368;  // offset: 0x558
    undefined field_1369;  // offset: 0x559
    undefined field_1370;  // offset: 0x55a
    undefined field_1371;  // offset: 0x55b
    undefined field_1372;  // offset: 0x55c
    undefined field_1373;  // offset: 0x55d
    undefined field_1374;  // offset: 0x55e
    undefined field_1375;  // offset: 0x55f
    undefined field_1376;  // offset: 0x560
    undefined field_1377;  // offset: 0x561
    undefined field_1378;  // offset: 0x562
    undefined field_1379;  // offset: 0x563
    undefined field_1380;  // offset: 0x564
    undefined field_1381;  // offset: 0x565
    undefined field_1382;  // offset: 0x566
    undefined field_1383;  // offset: 0x567
    undefined field_1384;  // offset: 0x568
    undefined field_1385;  // offset: 0x569
    undefined field_1386;  // offset: 0x56a
    undefined field_1387;  // offset: 0x56b
    undefined field_1388;  // offset: 0x56c
    undefined field_1389;  // offset: 0x56d
    undefined field_1390;  // offset: 0x56e
    undefined field_1391;  // offset: 0x56f
    undefined field_1392;  // offset: 0x570
    undefined field_1393;  // offset: 0x571
    undefined field_1394;  // offset: 0x572
    undefined field_1395;  // offset: 0x573
    undefined field_1396;  // offset: 0x574
    undefined field_1397;  // offset: 0x575
    undefined field_1398;  // offset: 0x576
    undefined field_1399;  // offset: 0x577
    undefined field_1400;  // offset: 0x578
    undefined field_1401;  // offset: 0x579
    undefined field_1402;  // offset: 0x57a
    undefined field_1403;  // offset: 0x57b
    undefined field_1404;  // offset: 0x57c
    undefined field_1405;  // offset: 0x57d
    undefined field_1406;  // offset: 0x57e
    undefined field_1407;  // offset: 0x57f
    zone_padding _pad2_;  // offset: 0x580
    ulong percpu_drift_mark;  // offset: 0x580
    ulong compact_cached_free_pfn;  // offset: 0x588
    ulong compact_cached_migrate_pfn[2];  // offset: 0x590
    uint compact_considered;  // offset: 0x5a0
    uint compact_defer_shift;  // offset: 0x5a4
    int compact_order_failed;  // offset: 0x5a8
    bool compact_blockskip_flush;  // offset: 0x5ac
    bool contiguous;  // offset: 0x5ad
    undefined field_1454;  // offset: 0x5ae
    undefined field_1455;  // offset: 0x5af
    undefined field_1456;  // offset: 0x5b0
    undefined field_1457;  // offset: 0x5b1
    undefined field_1458;  // offset: 0x5b2
    undefined field_1459;  // offset: 0x5b3
    undefined field_1460;  // offset: 0x5b4
    undefined field_1461;  // offset: 0x5b5
    undefined field_1462;  // offset: 0x5b6
    undefined field_1463;  // offset: 0x5b7
    undefined field_1464;  // offset: 0x5b8
    undefined field_1465;  // offset: 0x5b9
    undefined field_1466;  // offset: 0x5ba
    undefined field_1467;  // offset: 0x5bb
    undefined field_1468;  // offset: 0x5bc
    undefined field_1469;  // offset: 0x5bd
    undefined field_1470;  // offset: 0x5be
    undefined field_1471;  // offset: 0x5bf
    undefined field_1472;  // offset: 0x5c0
    undefined field_1473;  // offset: 0x5c1
    undefined field_1474;  // offset: 0x5c2
    undefined field_1475;  // offset: 0x5c3
    undefined field_1476;  // offset: 0x5c4
    undefined field_1477;  // offset: 0x5c5
    undefined field_1478;  // offset: 0x5c6
    undefined field_1479;  // offset: 0x5c7
    undefined field_1480;  // offset: 0x5c8
    undefined field_1481;  // offset: 0x5c9
    undefined field_1482;  // offset: 0x5ca
    undefined field_1483;  // offset: 0x5cb
    undefined field_1484;  // offset: 0x5cc
    undefined field_1485;  // offset: 0x5cd
    undefined field_1486;  // offset: 0x5ce
    undefined field_1487;  // offset: 0x5cf
    undefined field_1488;  // offset: 0x5d0
    undefined field_1489;  // offset: 0x5d1
    undefined field_1490;  // offset: 0x5d2
    undefined field_1491;  // offset: 0x5d3
    undefined field_1492;  // offset: 0x5d4
    undefined field_1493;  // offset: 0x5d5
    undefined field_1494;  // offset: 0x5d6
    undefined field_1495;  // offset: 0x5d7
    undefined field_1496;  // offset: 0x5d8
    undefined field_1497;  // offset: 0x5d9
    undefined field_1498;  // offset: 0x5da
    undefined field_1499;  // offset: 0x5db
    undefined field_1500;  // offset: 0x5dc
    undefined field_1501;  // offset: 0x5dd
    undefined field_1502;  // offset: 0x5de
    undefined field_1503;  // offset: 0x5df
    undefined field_1504;  // offset: 0x5e0
    undefined field_1505;  // offset: 0x5e1
    undefined field_1506;  // offset: 0x5e2
    undefined field_1507;  // offset: 0x5e3
    undefined field_1508;  // offset: 0x5e4
    undefined field_1509;  // offset: 0x5e5
    undefined field_1510;  // offset: 0x5e6
    undefined field_1511;  // offset: 0x5e7
    undefined field_1512;  // offset: 0x5e8
    undefined field_1513;  // offset: 0x5e9
    undefined field_1514;  // offset: 0x5ea
    undefined field_1515;  // offset: 0x5eb
    undefined field_1516;  // offset: 0x5ec
    undefined field_1517;  // offset: 0x5ed
    undefined field_1518;  // offset: 0x5ee
    undefined field_1519;  // offset: 0x5ef
    undefined field_1520;  // offset: 0x5f0
    undefined field_1521;  // offset: 0x5f1
    undefined field_1522;  // offset: 0x5f2
    undefined field_1523;  // offset: 0x5f3
    undefined field_1524;  // offset: 0x5f4
    undefined field_1525;  // offset: 0x5f5
    undefined field_1526;  // offset: 0x5f6
    undefined field_1527;  // offset: 0x5f7
    undefined field_1528;  // offset: 0x5f8
    undefined field_1529;  // offset: 0x5f9
    undefined field_1530;  // offset: 0x5fa
    undefined field_1531;  // offset: 0x5fb
    undefined field_1532;  // offset: 0x5fc
    undefined field_1533;  // offset: 0x5fd
    undefined field_1534;  // offset: 0x5fe
    undefined field_1535;  // offset: 0x5ff
    zone_padding _pad3_;  // offset: 0x600
    atomic_long_t vm_stat[14];  // offset: 0x600
    undefined field_1648;  // offset: 0x670
    undefined field_1649;  // offset: 0x671
    undefined field_1650;  // offset: 0x672
    undefined field_1651;  // offset: 0x673
    undefined field_1652;  // offset: 0x674
    undefined field_1653;  // offset: 0x675
    undefined field_1654;  // offset: 0x676
    undefined field_1655;  // offset: 0x677
    undefined field_1656;  // offset: 0x678
    undefined field_1657;  // offset: 0x679
    undefined field_1658;  // offset: 0x67a
    undefined field_1659;  // offset: 0x67b
    undefined field_1660;  // offset: 0x67c
    undefined field_1661;  // offset: 0x67d
    undefined field_1662;  // offset: 0x67e
    undefined field_1663;  // offset: 0x67f
}; // size: 0x680

struct zone_padding {
    char x[0];  // offset: 0x0
}; // size: 0x1

struct zone_reclaim_stat {
    ulong recent_rotated[2];  // offset: 0x0
    ulong recent_scanned[2];  // offset: 0x10
}; // size: 0x20

struct zonelist {
    zoneref _zonerefs[4];  // offset: 0x0
}; // size: 0x40

struct zoneref {
    zone * zone;  // offset: 0x0
    int zone_idx;  // offset: 0x8
}; // size: 0x10

/* ==================== Unions ==================== */

union anon_union_112_8_26c2b70a_for__sifields {
    int[28] _pad;
    anon_struct_8_2_37e52e62_for__kill _kill;
    anon_struct_24_5_a9d2e8e0_for__timer _timer;
    anon_struct_16_3_55e3d276_for__rt _rt;
    anon_struct_32_5_ac353c0e_for__sigchld _sigchld;
    anon_struct_32_3_83228368_for__sigfault _sigfault;
    anon_struct_16_2_036100f2_for__sigpoll _sigpoll;
    anon_struct_16_3_349d2ff7_for__sigsys _sigsys;
}; // size: 0x70

union anon_union_16_2_0496ad32_for_radix_tree_node_3 {
    anon_struct_16_2_bf2d6ad5_for_anon_union_16_2_0496ad32_for_radix_tree_node_3_0 field_0;
    callback_head callback_head;
}; // size: 0x10

union anon_union_16_2_200698a6_for_anon_struct_32_3_83228368_for__sigfault_2 {
    anon_struct_16_2_6c587c7a_for__addr_bnd _addr_bnd;
    __u32 _pkey;
}; // size: 0x10

union anon_union_16_2_315a0586_for_console {
    anon_struct_16_2_1ccaa948_for_domU domU;
    anon_struct_8_2_1193de1b_for_dom0 dom0;
}; // size: 0x10

union anon_union_16_2_76d55e2d_for_inode_30 {
    hlist_head i_dentry;
    callback_head i_rcu;
}; // size: 0x10

union anon_union_16_2_834e7c5b_for_f_u {
    llist_node fu_llist;
    callback_head fu_rcuhead;
}; // size: 0x10

union anon_union_16_2_a270f79b_for_dentry_12 {
    list_head d_lru;
    wait_queue_head_t * d_wait;
}; // size: 0x10

union anon_union_16_3_1ff3538c_for_d_u {
    hlist_node d_alias;
    hlist_bl_node d_in_lookup_hash;
    callback_head d_rcu;
}; // size: 0x10

union anon_union_16_5_86b83ece_for_page_4 {
    list_head lru;
    dev_pagemap * pgmap;
    anon_struct_16_3_a99975b4_for_anon_union_16_5_86b83ece_for_page_4_2 field_2;
    callback_head callback_head;
    anon_struct_16_3_1ec73fca_for_anon_union_16_5_86b83ece_for_page_4_4 field_4;
}; // size: 0x10

union anon_union_24_2_0d98eaf6_for_key_2 {
    list_head graveyard_link;
    rb_node serial_node;
}; // size: 0x18

union anon_union_24_2_a31149a9_for_key_14 {
    keyring_index_key index_key;
    anon_struct_16_2_c793ed0d_for_anon_union_24_2_a31149a9_for_key_14_1 field_1;
}; // size: 0x18

union anon_union_32_2_c44092ce_for_idr_layer_4 {
    ulong[4] bitmap;
    callback_head callback_head;
}; // size: 0x20

union anon_union_32_3_6ffd4daa_for_fl_u {
    nfs_lock_info nfs_fl;
    nfs4_lock_info nfs4_fl;
    anon_struct_24_2_b8c32279_for_afs afs;
}; // size: 0x20

union anon_union_32_3_ecfb39e2_for_key_15 {
    key_payload payload;
    anon_struct_32_2_435e3c06_for_anon_union_32_3_ecfb39e2_for_key_15_1 field_1;
    int reject_error;
}; // size: 0x20

union anon_union_32_3_f2422723_for_kernfs_node_7 {
    kernfs_elem_dir dir;
    kernfs_elem_symlink symlink;
    kernfs_elem_attr attr;
}; // size: 0x20

union anon_union_40_3_0ec87412_for_restart_block_1 {
    anon_struct_40_6_daaf18c6_for_futex futex;
    anon_struct_32_4_3561e44d_for_nanosleep nanosleep;
    anon_struct_32_5_1063e6a4_for_poll poll;
}; // size: 0x28

union anon_union_4_1_a8932bbd_for_spinlock_0 {
    raw_spinlock rlock;
}; // size: 0x4

union anon_union_4_2_26e7ee41_for_inode_11 {
    uint i_nlink;
    uint __i_nlink;
}; // size: 0x4

union anon_union_4_3_d2ff16bc_for_kqid_0 {
    kuid_t uid;
    kgid_t gid;
    kprojid_t projid;
}; // size: 0x4

union anon_union_4_4_c461a3d3_for_anon_struct_8_2_00f704d7_for_anon_union_8_2_8f55150c_for_page_3_1_0 {
    atomic_t _mapcount;
    uint active;
    anon_struct_4_3_197f4b50_for_anon_union_4_4_c461a3d3_for_anon_struct_8_2_00f704d7_for_anon_union_8_2_8f55150c_for_page_3_1_0_2 field_2;
    int units;
}; // size: 0x4

union anon_union_528_2_afce2d22_for_fpsimd_state_0 {
    user_fpsimd_state user_fpsimd;
    anon_struct_528_3_de587f01_for_anon_union_528_2_afce2d22_for_fpsimd_state_0_1 field_1;
}; // size: 0x210

union anon_union_8_2_8f55150c_for_page_3 {
    uint counters;
    anon_struct_8_2_00f704d7_for_anon_union_8_2_8f55150c_for_page_3_1 field_1;
}; // size: 0x8

union anon_union_8_2_a3c87c50_for_lockref_0 {
    __u64 lock_count;
    anon_struct_8_2_239a000b_for_anon_union_8_2_a3c87c50_for_lockref_0_1 field_1;
}; // size: 0x8

union anon_union_8_2_a48a124b_for_page_2 {
    ulong index;
    void * freelist;
}; // size: 0x8

union anon_union_8_2_a8706ac2_for_key_6 {
    time_t expiry;
    time_t revoked_at;
}; // size: 0x8

union anon_union_8_2_ae5c065a_for_qstr_0 {
    anon_struct_8_2_62570ece_for_anon_union_8_2_ae5c065a_for_qstr_0_0 field_0;
    u64 hash_len;
}; // size: 0x8

union anon_union_8_2_f9000a74_for_d_un {
    Elf64_Xword d_val;
    Elf64_Addr d_ptr;
}; // size: 0x8

union anon_union_8_3_6c3dd376_for_page_5 {
    ulong private;
    spinlock_t ptl;
    kmem_cache * slab_cache;
}; // size: 0x8

union anon_union_8_3_e8ad8e82_for_page_1 {
    address_space * mapping;
    void * s_mem;
    atomic_t compound_mapcount;
}; // size: 0x8

union anon_union_8_3_eb4d9846_for_kernel_param_6 {
    void * arg;
    kparam_string * str;
    kparam_array * arr;
}; // size: 0x8

union anon_union_8_5_4efd96cc_for_inode_39 {
    pipe_inode_info * i_pipe;
    block_device * i_bdev;
    cdev * i_cdev;
    char * i_link;
    uint i_dir_seq;
}; // size: 0x8

union key_payload {
    void * rcu_data0;
    void *[4] data;
}; // size: 0x20

union ktime {
    s64 tv64;
}; // size: 0x8

union sigval {
    int sival_int;
    void * sival_ptr;
}; // size: 0x8

union thread_union {
    thread_info thread_info;
    ulong[2048] stack;
}; // size: 0x4000

/* ==================== Type Definitions ==================== */

typedef __u64 Elf64_Addr;
typedef __u16 Elf64_Half;
typedef __s64 Elf64_Sxword;
typedef elf64_sym Elf64_Sym;
typedef __u32 Elf64_Word;
typedef __u64 Elf64_Xword;
typedef uint16 __int128 unsigned;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_clockid_t;
typedef __u32 __kernel_dev_t;
typedef dword __kernel_gid32_t;
typedef long __kernel_loff_t;
typedef long __kernel_long_t;
typedef int __kernel_pid_t;
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_time_t;
typedef int __kernel_timer_t;
typedef dword __kernel_uid32_t;
typedef ulong __kernel_ulong_t;
typedef sdword __s32;
typedef sqword __s64;
typedef char __s8;
typedef __signalfn_t * __sighandler_t;
typedef __restorefn_t * __sigrestore_t;
typedef word __u16;
typedef dword __u32;
typedef qword __u64;
typedef uchar __u8;
typedef atomic64_t atomic_long_t;
typedef ulong blkcnt_t;
typedef __kernel_clockid_t clockid_t;
typedef s32 compat_time_t;
typedef cpumask cpumask_t;
typedef cpumask[1] cpumask_var_t;
typedef ulong cputime_t;
typedef __kernel_dev_t dev_t;
typedef _func_int_dir_context_ptr_char_ptr_int_loff_t_u64_uint * filldir_t;
typedef void * fl_owner_t;
typedef uint fmode_t;
typedef uint gfp_t;
typedef __kernel_gid32_t gid_t;
typedef _func_int * initcall_t;
typedef __s32 int32_t;
typedef __s8 int8_t;
typedef uint isolate_mode_t;
typedef kernel_cap_struct kernel_cap_t;
typedef uint32_t key_perm_t;
typedef int32_t key_serial_t;
typedef ktime ktime_t;
typedef __kernel_loff_t loff_t;
typedef ulong mm_segment_t;
typedef _func_int_notifier_block_ptr_ulong_void_ptr * notifier_fn_t;
typedef u64 pgdval_t;
typedef page * pgtable_t;
typedef u64 phys_addr_t;
typedef __kernel_pid_t pid_t;
typedef pm_message pm_message_t;
typedef u64 pmdval_t;
typedef __kernel_uid32_t projid_t;
typedef u64 pteval_t;
typedef long qsize_t;
typedef raw_spinlock raw_spinlock_t;
typedef phys_addr_t resource_size_t;
typedef sdword s32;
typedef sqword s64;
typedef char s8;
typedef ulong sector_t;
typedef seqcount seqcount_t;
typedef siginfo siginfo_t;
typedef sigval sigval_t;
typedef __kernel_size_t size_t;
typedef spinlock spinlock_t;
typedef __kernel_ssize_t ssize_t;
typedef __s64 time64_t;
typedef __kernel_time_t time_t;
typedef word u16;
typedef dword u32;
typedef qword u64;
typedef uchar u8;
typedef __kernel_uid32_t uid_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef __u8 uint8_t;
typedef ushort umode_t;
typedef __wait_queue_head wait_queue_head_t;
typedef _func_void_work_struct_ptr * work_func_t;
typedef uint64_t xen_pfn_t;
typedef uint64_t xen_ulong_t;

/* ==================== Function Prototypes ==================== */

void __restorefn_t(void);
void __signalfn_t(int param0);
bool _func_bool(void);
bool _func_bool_file_lock_ptr(file_lock * param0);
bool _func_bool_page_ptr_isolate_mode_t(page * param0, isolate_mode_t param1);
cgroup_subsys_state * _func_cgroup_subsys_state_ptr_cgroup_subsys_state_ptr(cgroup_subsys_state * param0);
char * _func_char_ptr_dentry_ptr_char_ptr_int(dentry * param0, char * param1, int param2);
char * _func_char_ptr_dentry_ptr_inode_ptr_delayed_call_ptr(dentry * param0, inode * param1, delayed_call * param2);
char * _func_char_ptr_device_ptr_umode_t_ptr(device * param0, umode_t * param1);
char * _func_char_ptr_device_ptr_umode_t_ptr_kuid_t_ptr_kgid_t_ptr(device * param0, umode_t * param1, kuid_t * param2, kgid_t * param3);
char * _func_char_ptr_kset_ptr_kobject_ptr(kset * param0, kobject * param1);
char * _func_char_ptr_vm_area_struct_ptr(vm_area_struct * param0);
dentry * _func_dentry_ptr_dentry_ptr_inode_ptr_uint(dentry * param0, inode * param1, uint param2);
dentry * _func_dentry_ptr_file_system_type_ptr_int_char_ptr_void_ptr(file_system_type * param0, int param1, char * param2, void * param3);
dentry * _func_dentry_ptr_inode_ptr_dentry_ptr_uint(inode * param0, dentry * param1, uint param2);
dquot * * _func_dquot_ptr_ptr_inode_ptr(inode * param0);
dquot * _func_dquot_ptr_super_block_ptr_int(super_block * param0, int param1);
fl_owner_t _func_fl_owner_t_fl_owner_t(fl_owner_t param0);
hrtimer_restart _func_hrtimer_restart_hrtimer_ptr(hrtimer * param0);
inode * _func_inode_ptr_super_block_ptr(super_block * param0);
int _func_int(void);
int _func_int_address_space_ptr_page_ptr(address_space * param0, page * param1);
int _func_int_address_space_ptr_page_ptr_page_ptr_migrate_mode(address_space * param0, page * param1, page * param2, migrate_mode param3);
int _func_int_address_space_ptr_writeback_control_ptr(address_space * param0, writeback_control * param1);
int _func_int_cgroup_subsys_state_ptr(cgroup_subsys_state * param0);
int _func_int_cgroup_subsys_state_ptr_cftype_ptr_s64(cgroup_subsys_state * param0, cftype * param1, s64 param2);
int _func_int_cgroup_subsys_state_ptr_cftype_ptr_u64(cgroup_subsys_state * param0, cftype * param1, u64 param2);
int _func_int_cgroup_taskset_ptr(cgroup_taskset * param0);
int _func_int_char_ptr_kernel_param_ptr(char * param0, kernel_param * param1);
int _func_int_dentry_ptr(dentry * param0);
int _func_int_dentry_ptr_bool(dentry * param0, bool param1);
int _func_int_dentry_ptr_char_ptr_int(dentry * param0, char * param1, int param2);
int _func_int_dentry_ptr_iattr_ptr(dentry * param0, iattr * param1);
int _func_int_dentry_ptr_inode_ptr_dentry_ptr(dentry * param0, inode * param1, dentry * param2);
int _func_int_dentry_ptr_kstatfs_ptr(dentry * param0, kstatfs * param1);
int _func_int_dentry_ptr_qstr_ptr(dentry * param0, qstr * param1);
int _func_int_dentry_ptr_uint(dentry * param0, uint param1);
int _func_int_dentry_ptr_uint_char_ptr_qstr_ptr(dentry * param0, uint param1, char * param2, qstr * param3);
int _func_int_device_ptr(device * param0);
int _func_int_device_ptr_device_driver_ptr(device * param0, device_driver * param1);
int _func_int_device_ptr_kobj_uevent_env_ptr(device * param0, kobj_uevent_env * param1);
int _func_int_device_ptr_pm_message_t(device * param0, pm_message_t param1);
int _func_int_dir_context_ptr_char_ptr_int_loff_t_u64_uint(dir_context * param0, char * param1, int param2, loff_t param3, u64 param4, uint param5);
int _func_int_dquot_ptr(dquot * param0);
int _func_int_file_lock_ptr_file_lock_ptr(file_lock * param0, file_lock * param1);
int _func_int_file_lock_ptr_int(file_lock * param0, int param1);
int _func_int_file_lock_ptr_int_list_head_ptr(file_lock * param0, int param1, list_head * param2);
int _func_int_file_ptr_address_space_ptr_list_head_ptr_uint(file * param0, address_space * param1, list_head * param2, uint param3);
int _func_int_file_ptr_address_space_ptr_loff_t_uint_uint_page_ptr_ptr_void_ptr_ptr(file * param0, address_space * param1, loff_t param2, uint param3, uint param4, page * * param5, void * * param6);
int _func_int_file_ptr_address_space_ptr_loff_t_uint_uint_page_ptr_void_ptr(file * param0, address_space * param1, loff_t param2, uint param3, uint param4, page * param5, void * param6);
int _func_int_file_ptr_dir_context_ptr(file * param0, dir_context * param1);
int _func_int_file_ptr_fl_owner_t(file * param0, fl_owner_t param1);
int _func_int_file_ptr_int_file_lock_ptr(file * param0, int param1, file_lock * param2);
int _func_int_file_ptr_kobject_ptr_bin_attribute_ptr_vm_area_struct_ptr(file * param0, kobject * param1, bin_attribute * param2, vm_area_struct * param3);
int _func_int_file_ptr_loff_t_file_ptr_loff_t_u64(file * param0, loff_t param1, file * param2, loff_t param3, u64 param4);
int _func_int_file_ptr_loff_t_loff_t_int(file * param0, loff_t param1, loff_t param2, int param3);
int _func_int_file_ptr_long_file_lock_ptr_ptr_void_ptr_ptr(file * param0, long param1, file_lock * * param2, void * * param3);
int _func_int_file_ptr_page_ptr(file * param0, page * param1);
int _func_int_file_ptr_vm_area_struct_ptr(file * param0, vm_area_struct * param1);
int _func_int_inode_ptr(inode * param0);
int _func_int_inode_ptr_dentry_ptr(inode * param0, dentry * param1);
int _func_int_inode_ptr_dentry_ptr_char_ptr(inode * param0, dentry * param1, char * param2);
int _func_int_inode_ptr_dentry_ptr_file_ptr_uint_umode_t_int_ptr(inode * param0, dentry * param1, file * param2, uint param3, umode_t param4, int * param5);
int _func_int_inode_ptr_dentry_ptr_inode_ptr_dentry_ptr_uint(inode * param0, dentry * param1, inode * param2, dentry * param3, uint param4);
int _func_int_inode_ptr_dentry_ptr_umode_t(inode * param0, dentry * param1, umode_t param2);
int _func_int_inode_ptr_dentry_ptr_umode_t_bool(inode * param0, dentry * param1, umode_t param2, bool param3);
int _func_int_inode_ptr_dentry_ptr_umode_t_dev_t(inode * param0, dentry * param1, umode_t param2, dev_t param3);
int _func_int_inode_ptr_fiemap_extent_info_ptr_u64_u64(inode * param0, fiemap_extent_info * param1, u64 param2, u64 param3);
int _func_int_inode_ptr_file_ptr(inode * param0, file * param1);
int _func_int_inode_ptr_int(inode * param0, int param1);
int _func_int_inode_ptr_kprojid_t_ptr(inode * param0, kprojid_t * param1);
int _func_int_inode_ptr_posix_acl_ptr_int(inode * param0, posix_acl * param1, int param2);
int _func_int_inode_ptr_timespec_ptr_int(inode * param0, timespec * param1, int param2);
int _func_int_inode_ptr_writeback_control_ptr(inode * param0, writeback_control * param1);
int _func_int_int(int param0);
int _func_int_int_file_ptr_int(int param0, file * param1, int param2);
int _func_int_kernfs_node_ptr(kernfs_node * param0);
int _func_int_kernfs_node_ptr_char_ptr_umode_t(kernfs_node * param0, char * param1, umode_t param2);
int _func_int_kernfs_node_ptr_kernfs_node_ptr_char_ptr(kernfs_node * param0, kernfs_node * param1, char * param2);
int _func_int_kernfs_open_file_ptr_vm_area_struct_ptr(kernfs_open_file * param0, vm_area_struct * param1);
int _func_int_kernfs_root_ptr_int_ptr_char_ptr(kernfs_root * param0, int * param1, char * param2);
int _func_int_key_ptr_key_type_ptr_key_payload_ptr(key * param0, key_type * param1, key_payload * param2);
int _func_int_kset_ptr_kobject_ptr(kset * param0, kobject * param1);
int _func_int_kset_ptr_kobject_ptr_kobj_uevent_env_ptr(kset * param0, kobject * param1, kobj_uevent_env * param2);
int _func_int_module_ptr(module * param0);
int _func_int_notifier_block_ptr_ulong_void_ptr(notifier_block * param0, ulong param1, void * param2);
int _func_int_page_ptr(page * param0);
int _func_int_page_ptr_gfp_t(page * param0, gfp_t param1);
int _func_int_page_ptr_ulong_ulong(page * param0, ulong param1, ulong param2);
int _func_int_page_ptr_writeback_control_ptr(page * param0, writeback_control * param1);
int _func_int_seq_file_ptr_dentry_ptr(seq_file * param0, dentry * param1);
int _func_int_seq_file_ptr_kernfs_node_ptr_kernfs_root_ptr(seq_file * param0, kernfs_node * param1, kernfs_root * param2);
int _func_int_seq_file_ptr_kernfs_root_ptr(seq_file * param0, kernfs_root * param1);
int _func_int_seq_file_ptr_void_ptr(seq_file * param0, void * param1);
int _func_int_super_block_ptr(super_block * param0);
int _func_int_super_block_ptr_int(super_block * param0, int param1);
int _func_int_super_block_ptr_int_int_path_ptr(super_block * param0, int param1, int param2, path * param3);
int _func_int_super_block_ptr_int_ptr_char_ptr(super_block * param0, int * param1, char * param2);
int _func_int_super_block_ptr_int_qc_info_ptr(super_block * param0, int param1, qc_info * param2);
int _func_int_super_block_ptr_kqid_ptr(super_block * param0, kqid * param1);
int _func_int_super_block_ptr_kqid_ptr_qc_dqblk_ptr(super_block * param0, kqid * param1, qc_dqblk * param2);
int _func_int_super_block_ptr_kqid_qc_dqblk_ptr(super_block * param0, kqid param1, qc_dqblk * param2);
int _func_int_super_block_ptr_page_ptr_gfp_t(super_block * param0, page * param1, gfp_t param2);
int _func_int_super_block_ptr_qc_state_ptr(super_block * param0, qc_state * param1);
int _func_int_super_block_ptr_uint(super_block * param0, uint param1);
int _func_int_swap_info_struct_ptr_file_ptr_sector_t_ptr(swap_info_struct * param0, file * param1, sector_t * param2);
int _func_int_task_struct_ptr(task_struct * param0);
int _func_int_vfsmount_ptr_dentry_ptr_kstat_ptr(vfsmount * param0, dentry * param1, kstat * param2);
int _func_int_vm_area_struct_ptr(vm_area_struct * param0);
int _func_int_vm_area_struct_ptr_ulong_pmd_t_ptr_uint(vm_area_struct * param0, ulong param1, pmd_t * param2, uint param3);
int _func_int_vm_area_struct_ptr_ulong_void_ptr_int_int(vm_area_struct * param0, ulong param1, void * param2, int param3, int param4);
int _func_int_vm_area_struct_ptr_vm_fault_ptr(vm_area_struct * param0, vm_fault * param1);
kobj_ns_type_operations * _func_kobj_ns_type_operations_ptr_kobject_ptr(kobject * param0);
ktime_t _func_ktime_t(void);
loff_t _func_loff_t_file_ptr_loff_t_int(file * param0, loff_t param1, int param2);
long _func_long_file_ptr_int_loff_t_loff_t(file * param0, int param1, loff_t param2, loff_t param3);
long _func_long_file_ptr_uint_ulong(file * param0, uint param1, ulong param2);
long _func_long_int(int param0);
long _func_long_restart_block_ptr(restart_block * param0);
long _func_long_super_block_ptr_shrink_control_ptr(super_block * param0, shrink_control * param1);
page * _func_page_ptr_vm_area_struct_ptr_ulong(vm_area_struct * param0, ulong param1);
posix_acl * _func_posix_acl_ptr_inode_ptr_int(inode * param0, int param1);
qsize_t * _func_qsize_t_ptr_inode_ptr(inode * param0);
s64 _func_s64_cgroup_subsys_state_ptr_cftype_ptr(cgroup_subsys_state * param0, cftype * param1);
sector_t _func_sector_t_address_space_ptr_sector_t(address_space * param0, sector_t param1);
ssize_t _func_ssize_t_class_ptr_class_attribute_ptr_char_ptr(class * param0, class_attribute * param1, char * param2);
ssize_t _func_ssize_t_class_ptr_class_attribute_ptr_char_ptr_size_t(class * param0, class_attribute * param1, char * param2, size_t param3);
ssize_t _func_ssize_t_dentry_ptr_char_ptr_size_t(dentry * param0, char * param1, size_t param2);
ssize_t _func_ssize_t_device_ptr_device_attribute_ptr_char_ptr(device * param0, device_attribute * param1, char * param2);
ssize_t _func_ssize_t_device_ptr_device_attribute_ptr_char_ptr_size_t(device * param0, device_attribute * param1, char * param2, size_t param3);
ssize_t _func_ssize_t_file_ptr_char_ptr_size_t_loff_t_ptr(file * param0, char * param1, size_t param2, loff_t * param3);
ssize_t _func_ssize_t_file_ptr_kobject_ptr_bin_attribute_ptr_char_ptr_loff_t_size_t(file * param0, kobject * param1, bin_attribute * param2, char * param3, loff_t param4, size_t param5);
ssize_t _func_ssize_t_file_ptr_loff_t_file_ptr_loff_t_size_t_uint(file * param0, loff_t param1, file * param2, loff_t param3, size_t param4, uint param5);
ssize_t _func_ssize_t_file_ptr_loff_t_ptr_pipe_inode_info_ptr_size_t_uint(file * param0, loff_t * param1, pipe_inode_info * param2, size_t param3, uint param4);
ssize_t _func_ssize_t_file_ptr_page_ptr_int_size_t_loff_t_ptr_int(file * param0, page * param1, int param2, size_t param3, loff_t * param4, int param5);
ssize_t _func_ssize_t_file_ptr_u64_u64_file_ptr_u64(file * param0, u64 param1, u64 param2, file * param3, u64 param4);
ssize_t _func_ssize_t_kernfs_open_file_ptr_char_ptr_size_t_loff_t(kernfs_open_file * param0, char * param1, size_t param2, loff_t param3);
ssize_t _func_ssize_t_kiocb_ptr_iov_iter_ptr(kiocb * param0, iov_iter * param1);
ssize_t _func_ssize_t_kobject_ptr_attribute_ptr_char_ptr(kobject * param0, attribute * param1, char * param2);
ssize_t _func_ssize_t_kobject_ptr_attribute_ptr_char_ptr_size_t(kobject * param0, attribute * param1, char * param2, size_t param3);
ssize_t _func_ssize_t_kobject_ptr_kobj_attribute_ptr_char_ptr(kobject * param0, kobj_attribute * param1, char * param2);
ssize_t _func_ssize_t_kobject_ptr_kobj_attribute_ptr_char_ptr_size_t(kobject * param0, kobj_attribute * param1, char * param2, size_t param3);
ssize_t _func_ssize_t_module_attribute_ptr_module_kobject_ptr_char_ptr(module_attribute * param0, module_kobject * param1, char * param2);
ssize_t _func_ssize_t_module_attribute_ptr_module_kobject_ptr_char_ptr_size_t(module_attribute * param0, module_kobject * param1, char * param2, size_t param3);
ssize_t _func_ssize_t_pipe_inode_info_ptr_file_ptr_loff_t_ptr_size_t_uint(pipe_inode_info * param0, file * param1, loff_t * param2, size_t param3, uint param4);
ssize_t _func_ssize_t_super_block_ptr_int_char_ptr_size_t_loff_t(super_block * param0, int param1, char * param2, size_t param3, loff_t param4);
u64 _func_u64(void);
u64 _func_u64_cgroup_subsys_state_ptr_cftype_ptr(cgroup_subsys_state * param0, cftype * param1);
uint _func_uint_file_ptr_poll_table_struct_ptr(file * param0, poll_table_struct * param1);
ulong _func_ulong_file_lock_ptr(file_lock * param0);
ulong _func_ulong_file_ptr_ulong_ulong_ulong_ulong(file * param0, ulong param1, ulong param2, ulong param3, ulong param4);
ulong _func_ulong_shrinker_ptr_shrink_control_ptr(shrinker * param0, shrink_control * param1);
umode_t _func_umode_t_kobject_ptr_attribute_ptr_int(kobject * param0, attribute * param1, int param2);
umode_t _func_umode_t_kobject_ptr_bin_attribute_ptr_int(kobject * param0, bin_attribute * param1, int param2);
vfsmount * _func_vfsmount_ptr_path_ptr(path * param0);
void _func_void_callback_head_ptr(callback_head * param0);
void _func_void_cgroup_subsys_state_ptr(cgroup_subsys_state * param0);
void _func_void_cgroup_taskset_ptr(cgroup_taskset * param0);
void _func_void_class_ptr(class * param0);
void _func_void_cpumask_ptr_uint(cpumask * param0, uint param1);
void _func_void_dentry_ptr(dentry * param0);
void _func_void_dentry_ptr_inode_ptr(dentry * param0, inode * param1);
void _func_void_device_ptr(device * param0);
void _func_void_device_ptr_bool(device * param0, bool param1);
void _func_void_device_ptr_s32(device * param0, s32 param1);
void _func_void_dquot_ptr(dquot * param0);
void _func_void_fault_env_ptr_ulong_ulong(fault_env * param0, ulong param1, ulong param2);
void _func_void_file_lock_ptr(file_lock * param0);
void _func_void_file_lock_ptr_file_lock_ptr(file_lock * param0, file_lock * param1);
void _func_void_file_lock_ptr_void_ptr_ptr(file_lock * param0, void * * param1);
void _func_void_file_ptr(file * param0);
void _func_void_fl_owner_t(fl_owner_t param0);
void _func_void_inode_ptr(inode * param0);
void _func_void_inode_ptr_int(inode * param0, int param1);
void _func_void_kiocb_ptr_long_long(kiocb * param0, long param1, long param2);
void _func_void_kobject_ptr(kobject * param0);
void _func_void_module_ptr(module * param0);
void _func_void_module_ptr_char_ptr(module * param0, char * param1);
void _func_void_page_ptr_bool_ptr_bool_ptr(page * param0, bool * param1, bool * param2);
void _func_void_page_ptr_uint_uint(page * param0, uint param1, uint param2);
void * _func_void_ptr(void);
void * _func_void_ptr_device_ptr(device * param0);
void * _func_void_ptr_kobject_ptr(kobject * param0);
void * _func_void_ptr_seq_file_ptr_loff_t_ptr(seq_file * param0, loff_t * param1);
void * _func_void_ptr_seq_file_ptr_void_ptr_loff_t_ptr(seq_file * param0, void * param1, loff_t * param2);
void * _func_void_ptr_sock_ptr(sock * param0);
void _func_void_seq_file_ptr_file_ptr(seq_file * param0, file * param1);
void _func_void_seq_file_ptr_void_ptr(seq_file * param0, void * param1);
void _func_void_super_block_ptr(super_block * param0);
void _func_void_task_struct_ptr(task_struct * param0);
void _func_void_ulong(ulong param0);
void _func_void_vm_area_struct_ptr(vm_area_struct * param0);
void _func_void_void_ptr(void * param0);
void _func_void_work_struct_ptr(work_struct * param0);
void axi_fpga_dev_exit(void);
int axi_fpga_dev_init(void);
loff_t axi_fpga_dev_llseek(file * filp, loff_t offset, int whence);
int axi_fpga_dev_mmap(file * filp, vm_area_struct * vma);
int axi_fpga_dev_open(inode * inode, file * filp);
ssize_t axi_fpga_dev_read(file * f, char * buf, size_t len, loff_t * ppos);
void compound_page_dtor(page * param0);
void percpu_ref_func_t(percpu_ref * param0);
int proc_handler(ctl_table * param0, int param1, void * param2, size_t * param3, loff_t * param4);
bool pstate_check_t(ulong param0);

#endif // BITMAIN_AXI_KO_18DD4CAC57272383_DEBUG_TYPES_H
